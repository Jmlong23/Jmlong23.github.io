{"pages":[{"title":"目录","text":"","link":"/categories/index.html"},{"title":"关于","text":"等待更新……","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"83.删除排序链表中的重复元素","text":"给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例1： 12输入: 1-&gt;1-&gt;2输出: 1-&gt;2 这是一个简单的问题，仅测试你操作列表的结点指针的能力。由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。 12345678910111213class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode cur = head; while(cur != null &amp;&amp; cur.next != null){ if(cur.val == cur.next.val){ cur.next = cur.next.next; }else{ cur = cur.next; } } return head; }} 时间复杂度： 12时间复杂度：O(n)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为O(n)，其中 n 是链表表中的结点数。空间复杂度：O(1) 参考链接","link":"/2020/05/01/83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"title":"2.4 正规表达式到有限自动机的构造","text":"2.4.2 NFA确定化 $\\varepsilon$ 闭包的概念 子集法对NFA确定化","link":"/2020/04/28/2-4-%E6%AD%A3%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E6%9E%84%E9%80%A0/"},{"title":"win下Github和hexo搭建个人博客","text":"1 Git安装https://git-scm.com/download/win 2 Node.js安装https://nodejs.org/en/download/ 确认是否安装成功 123git –versionnode -vnpm -v 3 GitHub新建一个仓库名字：username.github.io 4 安装hexonpm install hexo-cli -g 好像要科学上网才可以成功安装 常用命令： 1234hexo g //生成hexo s //开启本地服务器hexo new &quot;标题&quot;hexo d //部署 配置config文件 12345url: https://Jmlong23.github.io deploy: type: git repo: https://github.com/Jmlong23/Jmlong23.github.io.git branch: master 更换主题 在GitHub复制主题仓库地址 把文件复制到themes目录下 在config里面改动theme: hexo-theme-next next主题基础操作 仓库readme有","link":"/2020/05/01/Github%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"Java关键字","text":"1 静态static关键字1.1 静态static关键字概述一旦用了static关键字修饰，那么这个元素就不再属于对象自己，而是属于类的，凡是本类的对象都共享同一份 比如下面的所在教室属性，用了static修饰，那么就属于这个学生类 2 private关键字2.1 概述问题描述：定义Person的年龄时，无法阻止不合理的数值被设置进来。解决方案：用private关键字将需要保护的成员变量进行修饰。 一旦使用了private进行修饰，那么本类当中仍然可以随意访问。但是！超出了本类范围之外就不能再直接访问了。 只可以间接访问private成员变量，就是定义一对儿Getter/Setter方法 1234567891011121314151617181920212223242526272829/*必须叫setXxx或者是getXxx命名规则。对于Getter来说，不能有参数，返回值类型和成员变量对应；对于Setter来说，不能有返回值，参数类型和成员变量对应。 */public class Person { String name; // 姓名 private int age; // 年龄 public void show() { System.out.println(\"我叫：\" + name + \"，年龄：\" + age); } // 这个成员方法，专门用于向age设置数据 public void setAge(int num) { if (num &lt; 100 &amp;&amp; num &gt;= 9) { // 如果是合理情况 age = num; } else { System.out.println(\"数据不合理！\"); } } // 这个成员方法，专门私语获取age的数据 public int getAge() { return age; }}","link":"/2020/05/06/Java%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"hexo、GitHubPage域名绑定","text":"1 域名解释在域名解释页面添加如下图所示记录 2 在source文件夹下新建CNAME文件里面写上自己的域名，如baidu.cn","link":"/2020/05/02/hexo%E3%80%81GitHubPage%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"},{"title":"InputStream和OutputStream","text":"1 例子 123456789101112131415161718192021222324import java.io.*;public class TestRead { public static void main(String[] args) throws IOException {//注意一定要抛出异常 String s; try (InputStream input = new FileInputStream(\"readme.c\")) {//1.创建 s = readAsString(input); } System.out.println(s); OutputStream output = new FileOutputStream(\"write.txt\");// 一、创建 output.write(s.getBytes(\"UTF-8\")); //二、调用方法 output.close(); } private static String readAsString(InputStream input) throws IOException { int n; StringBuilder sb = new StringBuilder(); while ((n = input.read()) != -1) {//2.使用方法 System.out.println(n); sb.append((char) n); } return sb.toString(); } }","link":"/2020/05/06/InputStream%E5%92%8COutputStream/"},{"title":"icarus主题gitalk评论配置踩坑","text":"1 在GitHub上面注册一个OAuth Apps获取相关的id和secret 2 在/Icarus/_config.yml下填写以下配置1234567comment: type: gitalk client_id: *******e35afa66dfd client_secret: ********eb0bf8c1 repo: username.github.io owner: username admin: [username] 3 遇到的错误我在写admin时直接写了username，结果报一下错误 1234567{keyword: 'type',dataPath: '.comment.admin',schemaPath: '/comment/gitalk.json/properties/admin/type',params: { type: 'array' },message: 'should be array'}, 错误是因为admin接收的时数组array而不是string。所以就算你可以正常应用，但还是会提示warn。 结果没看懂，这个错误，去GitHub问了Icarus原作者，才帮我指正，很谢谢原作者的指正。 参考资料 &lt;https://blog.zhangruipeng.me/hexo-theme-icarus/Plugins/Comment/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E7%94%A8%E6%88%B7%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#Gitalk&gt; icarus项目地址","link":"/2020/05/04/icarus%E4%B8%BB%E9%A2%98gitalk%E8%AF%84%E8%AE%BA%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/"},{"title":"java的api文档和Scanner类","text":"1 API概述 api概述 API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的 字典 ，是JDK中提供给 我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学 习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。 api使用步骤 打开帮助文档。 点击显示，找到索引，看到输入框。 你要找谁？在输入框里输入，然后回车。 看包。java.lang下的类不需要导包，其他需要。 看类的解释和说明。 学习构造方法。 使用成员方法。 2 引用类型的一般使用步骤 导包import 包路径.类名称;如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。只有java.lang包下的内容不需要导包，其他的包都需要import语句。 创建类名称 对象名 = new 类名称(); 使用对象名.成员方法名() 3 Scanner类12345678910111213141516171819202122232425262728package cn.itcast.day07.demo01;import java.util.Scanner; // 1. 导包/*Scanner类的功能：可以实现键盘输入数据，到程序当中。获取键盘输入的一个int数字：int num = sc.nextInt();获取键盘输入的一个字符串：String str = sc.next();遇到空格就会结束sc.nextLine();遇到Enter键才会结束 */public class Demo01Scanner { public static void main(String[] args) { // 2. 创建 // 备注：System.in代表从键盘进行输入 Scanner sc = new Scanner(System.in); // 3. 获取键盘输入的int数字 int num = sc.nextInt(); System.out.println(\"输入的int数字是：\" + num); // 4. 获取键盘输入的字符串 String str = sc.next(); System.out.println(\"输入的字符串是：\" + str); }}","link":"/2020/05/06/java%E7%9A%84api%E6%96%87%E6%A1%A3%E5%92%8CScanner%E7%B1%BB/"},{"title":"linux操作系统复习总结","text":"1操作系统概述1.1操作系统概述 从使用者角度看 程序开发者角度，调用操作系统的接口，如read（）函数，这些繁琐的操作留给操作系统 从所处位置看，操作系统是上层软件与硬件打交道的窗口和桥梁，是其他所有用户程序运行的基础 从设计者角度看，目标是让各种软件资源和硬件资源高效而协调地运转起来 操作系统的组成， 1. 2操作系统的发展 1946年宾夕法尼亚大学大学出现第一台通用计算机 第二代计算机，50s~60s，单道批处理系统 第三代计算机，60s中~70s初，多道批处理系统和分时系统和实时系统 四代，至今 软件角度下，操作系统的发展 单模块操作系统：进程管理，内存管理，设备管理，文件管理，通过调用函数交互，效率高，维护困难 微内核操作系统，用过通信机制交互，效率较低，维护简单 1.3开放源代码的Unix/Linux操作系统 Linux之父，linus torvalds linux遵循posix标准，所以流行 1.4Linux内核 内核子系统 进程调度 内存管理 虚拟文件系统 网络 进程间通信 1.5Linux内核源代码1.6Linux 内核模块编程入门1.7Linux 内核中链表的实现及应用2虚拟内存管理的硬件机制2.1内存寻址的演变 石器，8位寻址，Intel8080 青铜，16位寻址，Intel8086，段的引入 白银，保护模式的引入Intel80286 黄金，Intel80386，32位 常用寄存器 用于分页机制的控制寄存器 物理地址、虚拟地址及线性地址2.2段机制 段表 地址转换及保护2.3分页机制 页表 两级页表 线性地址到物理地址的转换 页面高速缓存2.4Linux中的分页机制2.5Linux中的汇编语言2.6Linux系统地址映射示例 3进程3.1进程介绍 程序和进程 进程层次结构 进程状态3.2进程控制块 信息分类 Linux进程状态及转换 进程标识符 进程之间的亲属关系 如何存放 3.3进程的组织方式 进程链表 哈希表 可运行队列 等待队列 等待队列的操作3.4进程调度 调度算法 时间片 调度时机 调度函数schedule( )-变量说明 调度程序的改进3.5进程的创建Fork()函数线程及其创建内核线程3.6与进程相关的系统调用及其应用3.7与调度相关的系统调用及应用4内存管理4.1Linux的内存管理内存的层次结构扩大了的记忆－虚拟内存虚地址到实地址转换虚拟内存、内核空间和用户空间Linux进程在虚拟内存中的标准内存段布局内核空间到物理内存的映射内核映像虚拟内存实现机制 4.2进程的用户空间管理mm_struct 结构VM_AREA_STRUCT 结构vm_operation结构创建进程用户空间虚存映射进程的虚存区举例与用户空间相关的主要系统调用mmap() 4.3请页机制实现虚存管理的重要手段页故障产生的原因缺页异常处理程序请求调页－动态内存分配技术写时复制 4.4物理内存的分配与回收物理页描述符 struct page结构页面分配与回收算法－伙伴算法物理页面的分配物理页面的回收Slab 分配机制－分配小内存通用缓冲区内核空间非连续内存区的分配vmalloc()与 kmalloc()之区别 4.5交换机制页面交换选择被换出的页面在交换区中存放页面页面交换策略页面交换守护进程kswapd 4.6内存管理实例5中断与异常5.1中断的基本知识中断源的类型外设可屏蔽中断异常及非屏蔽中断中断描述符表相关汇编指令 5.2中断描述符表的初始化IDT表项的设置初始化陷阱门和系统门中断门的设置 5.3中断处理中断和异常的硬件处理中断和异常处理中CPU的工作中断请求队列的建立中断服务例程与中断处理程序中断线共享的数据结构注册中断服务例程 5.4中断的下半部处理机制小任务机制工作队列机制下半部任务队列 5.5中断的应用－时钟中断时钟运作机制Linux时间系统时钟中断处理程序定时器及应用 6系统调用6.1系统调用与API、系统命令、内核函数系统调用与API系统调用与系统命令系统调用与内核函数系统调用与内核函数 6.2系统调用基本概念系统调用基本概念系统调用处理程序及服务例程 6.3系统调用实现调用一个系统调用初始化系统调用system_call( )函数参数传递跟踪系统调用的执行 6.4封装例程6.5添加新的系统调用6.6系统调用实例——日志收集7内核中的同步7.1临界区和竞争状态并发执行的原因临界区举例共享队列和加锁确定保护对象死 锁死锁的避免 7.2内核同步措施原子操作自旋锁信号量信号量与自旋锁的比较 7.3生产者-消费者并发实例7.4内核多任务并发实例内核任务及其之间的并发关系实现机制 8文件系统8.1Linux文件系统Linux的文件结构文件类型访问权限和文件模式软链接和硬链接安装文件系统 8.2虚拟文件系统虚拟文件系统的引入VFS中对象的演绎VFS超级块数据结构VFS的索引节点目录项对象目录项对象的数据结构与进程相关的文件结构 －文件对象文件对象数据结构的主要域与进程相关的文件结构 －用户打开文件表与进程相关的文件结构 － fs_struct结构主要数据结构间的关系 8.3文件系统的注册、安装与卸载文件系统的安装文件系统的卸载页缓冲区address_space对象的操作函数表 8.4文件的打开与读写generic_file_read()函数所执行的主要步骤从用户发出读请求到最终的从磁盘读取数据的步骤 8.5文件系统的编写Linux文件系统的实现要素什么是Romfs文件系统 9设备驱动9.1设备驱动概述9.2设备驱动程序设备驱动程序基础 9.3专用I/O端口I/O 端口设备文件中断处理用中断实现驱动程序的典型例子设备驱动程序框架 9.4字符设备驱动程序字符设备驱动程序的注册简单字符设备驱动程序举例 9.5块设备驱动程序块驱动程序的注册注册和注销一个驱动程序模块时所要调用的函数及数据结构块设备请求","link":"/2020/05/07/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"title":"win下ftp配置和使用","text":"1 用flashfxp连接ftp服务器与传输文件破解版下载地址： 链接：https://pan.baidu.com/s/1zY8vnCJvPBFycvZwV1L-pA提取码：kvhn 解压缩后打开flashfxp.exe如下图所示： 左边是本地文件夹，右边是服务器文件夹，点击箭头那里输入相应信息进行连接。 然后就可以进入服务器的文件夹。就可以传输文件了。 2 服务器收作业时文件夹权限分配 在根文件夹普通权限只给用户列出文件的权限 每个作业的文件夹给以下三个权限 这样该用户就只能上传文件而不能执行其他操作，保证作业不会被抄袭。","link":"/2020/05/01/win%E4%B8%8Bftp%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"title":"关于markdown文件不能正常显示数学公式的解决方案","text":"Typora编辑器不能正常显示解决方法 latex是markdown的扩展语法，必须要打开内联公式。首先，打开偏好设置。 选择内联公式 然后重启Typora google浏览器不能正常显示下载相应插件： https://chrome.google.com/webstore/detail/tex-all-the-things/cbimabofgmfdkicghcadidpemeenbffn 参考链接","link":"/2020/04/28/%E5%85%B3%E4%BA%8Emarkdown%E6%96%87%E4%BB%B6%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"对象数组和ArrayList集合","text":"1 引入–对象数组使用学生数组，存储三个学生对象 123456789101112131415161718192021222324252627282930313233343536373839public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } publicvoid setName(String name) { this.name = name; } publicint getAge() { return age; } publicvoid setAge(int age) { this.age = age; }} public class Test01StudentArray { //创建学生数组 Student[] students = new Student[3]; //创建学生对象 Student s1 = new Student(\"曹操\",40); Student s2 = new Student(\"刘备\",35); Student s3 = new Student(\"孙权\",30); //把学生对象作为元素赋值给学生数组 students[0] = s1; students[1] = s2; students[2] = s3; //遍历学生数组 for(int x=0; x&lt;students.length; x++) { Student s = students[x]; System.out.println(s.getName()+\"‐‐‐\"+s.getAge()); }} 到目前为止，我们想存储对象数据，选择的容器，只有对象数组。而数组的长度是固定的，无法适应数据变化的需 求。为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对象数据。 2 ArrayList类2.1 基本概念和使用 查看类 java.util.ArrayList &lt;E&gt; ：该类需要 import导入使后使用。&lt;E&gt; ：表示一种指定的数据类型，叫做泛型。 E ，取自Element（元素）的首字母。在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。代码如下： ArrayList&lt;String&gt;，ArrayList&lt;Student&gt; 查看构造方法public ArrayList() ：构造一个内容为空的集合。 基本格式: ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 在JDK 7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。简化格式： ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); 查看成员方法public boolean add(E e) ： 将指定的元素添加到此集合的尾部。 参数 E e ，在构造ArrayList对象时， &lt;E&gt; 指定了什么数据类型，那么 add(E e) 方法中，只能添加什么数据 类型的对象。 例子 使用ArrayList类，存储三个字符串元素，代码如下： 1234567891011121314151617public class Test02StudentArrayList { public static void main(String[] args) { //创建学生数组 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //创建学生对象 String s1 = \"曹操\"; String s3 = \"孙权\"; //打印学生ArrayList集合 System.out.println(list); //把学生对象作为元素添加到集合 list.add(s1); list.add(s2); list.add(s3); //打印学生ArrayList集合 System.out.println(list); } } 2.2 常用方法和遍历对于元素的操作,基本体现在——增、删、查。 常用的方法有： public boolean add(E e) ：将指定的元素添加到此集合的尾部。 public E remove(int index) ：移除此集合中指定位置上的元素。返回被删除的元素。 public E get(int index) ：返回此集合中指定位置上的元素。返回获取的元素。 public int size() ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。 这些都是基本的方法，操作非常简单，代码如下: 12345678910111213141516171819202122public class Demo91ArrayListMethod{ public static void main(String[] args) { //创建集合对象 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add(\"hello\"); list.add(\"world\"); list.add(\"java\"); //public E get(int index):返回指定索引处的元素 System.out.println(\"get:\"+list.get(0)); System.out.println(\"get:\"+list.get(1)); System.out.println(\"get:\"+list.get(2)); //public int size():返回集合中的元素的个数 System.out.println(\"size:\"+list.size()); //public E remove(int index):删除指定索引处的元素，返回被删除的元素 System.out.println(\"remove:\"+list.remove(0)); //遍历输出 for(int i = 0; i &lt; list.size(); i++){ System.out.println(list.get(i)); } } } 2.3 ArrayList练习*数值添加到集合 * 生成6个1~33之间的随机整数,添加到集合,并遍历 12345678910111213141516public class Test01ArrayList { public static void main(String[] args) { // 创建Random 对象 Random random = new Random(); // 创建ArrayList 对 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 添加随机数到集合 for (int i = 0; i &lt; 6; i++) { int r = random.nextInt(33) + 1; list.add(r); } // 遍历集合输出 for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); } } }","link":"/2020/05/06/%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%92%8CArrayList%E9%9B%86%E5%90%88/"},{"title":"HCL静态聚合链路实验","text":"1 题目 2 我的预览图 3 配置sw1 配置与pc连接的口vlan10 sw1与sw3之间的trunk口 sw1与sw2之间的聚合链路，先配置聚合集，再配置trunk类型 验证聚合链路是否配置成功 在聚合链路组上配置trunk类型 3 配置sw3接口配置为trunk类型 4 pc1 ping pc2 5 pc2 https://xiaoheidiannao.com/articles/HCL-Link-Aggregation.html","link":"/2020/05/02/%E7%BB%84%E7%BD%91HCL%E9%9D%99%E6%80%81%E8%81%9A%E5%90%88%E9%93%BE%E8%B7%AF%E5%AE%9E%E9%AA%8C/"},{"title":"词法分析器实验","text":"源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140import java.io.*;import java.util.ArrayList;public class JunMingAnalysis { public static void main(String[] args) throws IOException { String s; InputStream input = new FileInputStream(\"source.c\"); s = readAsString(input); if (s.isEmpty()||s.toCharArray()[0]=='#') { System.out.println(\"源代码为空，无法进行词法分析！\"); return ; } Analysis analysis = new Analysis(s); analysis.JudgeState(0); ArrayList&lt;String&gt; token = analysis.getToken(); OutputStream output = new FileOutputStream(\"word.txt\"); for(int i = 0; i &lt; token.size(); i++){ System.out.println(token.get(i)); output.write(token.get(i).getBytes(\"UTF-8\")); } } private static String readAsString(InputStream input) throws IOException { int n; StringBuilder sb = new StringBuilder(); while ((n = input.read()) != -1) { sb.append((char) n); } return sb.toString(); }}class Analysis{ private static char[] sourceCode; //字符数组，等待解析的源程序 private char ch; private String s; private static ArrayList&lt;String&gt; token = new ArrayList&lt;&gt;();//存放解析结果 public Analysis(String s){ sourceCode = s.toCharArray(); } public void JudgeState(int curponter){ ch = sourceCode[curponter]; while((int)ch == 13 || (int)ch == 32 || (int)ch == 10){ ch = sourceCode[++curponter]; } if( ch == '#'){ System.out.println(\"end\"); }else if(isAlpha(ch)){ s = Character.toString(ch); ch = sourceCode[++curponter]; while(isAlpha(ch) || isDigital(ch)){ s = s + ch; ch = sourceCode[++curponter]; } if(!reserve(s)){ s = \"(id,\" + s + \")\"; token.add(s); } JudgeState(curponter); }else if(isDigital(ch)){ s = Character.toString(ch); ch = sourceCode[++curponter]; while(isDigital(ch)){ s = s + ch; ch = sourceCode[++curponter]; } s = \"(num,\" + s + \")\"; token.add(s); JudgeState(curponter); }else if(ch == '+'){ s = \"(+,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '-'){ s = \"(-,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '*'){ s = \"(*,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '{'){ s = \"({,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '}'){ s = \"(},null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '('){ s = \"((,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == ')'){ s = \"(),null)\"; token.add(s); JudgeState(++curponter); }else if(ch == ';'){ s = \"(;,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '='){ s = \"(=,null)\"; token.add(s); JudgeState(++curponter); }else { System.out.println(\"未收录字符:\" + ch); return; } } public ArrayList&lt;String&gt; getToken(){ return token; } private boolean isAlpha(char ch){ return Character.isLetter(ch); } private boolean isDigital(char ch){ return Character.isDigit(ch); } private boolean reserve(String s){ switch(s){ case \"while\": token.add(\"(while,null)\"); return true; case \"if\": token.add(\"(if,null)\"); return true; case \"main\": token.add(\"(main,null)\"); return true; case \"int\": token.add(\"(int,null)\"); return true; case \"return\": token.add(\"(return,null)\"); return true; default: return false; } }}","link":"/2020/05/07/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%AE%9E%E9%AA%8C/"},{"title":"facenet人脸识别算法训练","text":"实验环境 win10 tensorflow 1.12.0 anaconda3.6 facenet源码地址：https://github.com/davidsandberg/facenet 数据预处理下载数据集fw—&gt;链接：https://pan.baidu.com/s/1kH-OcCCAvLVLP1wEQxlvRg提取码：twmg 64_CASIA-FaceV5链接：https://pan.baidu.com/s/1vHk_BE6ycoz7ujPSvB9e9A提取码：20a7 CASIA-WebFace链接：https://pan.baidu.com/s/17m9Ym45g4km7VLCxedQ7GA提取码：c951 Celeba链接：https://pan.baidu.com/s/18RmCCj7uHfvtkmmb8LZoHw提取码：a6ug 用人脸检测模型检测并且剪裁出人脸","link":"/2020/05/15/facenet%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"},{"title":"java读取指定文件夹下的文件名称和文件内容","text":"直接看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.io.*;/** * * 该类可以输出指定路径下所有的文件名（文件名和文件夹名） * 指定一个路径即可 * */ public class test { public static void main(String[] args) throws IOException { //这是需要获取的文件夹路径 String path = \"C:\\\\Users\\\\15626\\\\Documents\\\\庄育飞软件172项目管理论文选题\"; getFile(path,0); } /* * 函数名：getFile * 作用：使用递归，输出指定文件夹内的所有文件 * 参数：path：文件夹路径 deep：表示文件的层次深度，控制前置空格的个数 * 前置空格缩进，显示文件层次结构 */ private static void getFile (String path,int deep) throws IOException{ // 获得指定文件对象 File file = new File(path); // 获得该文件夹内的所有文件 File[] array = file.listFiles(); String str; Writer writer = new FileWriter(\"软件172项目管理选题.txt\"); for(int i=0;i&lt;array.length;i++) { if(array[i].isFile())//如果是文件 { for (int j = 0; j &lt; deep; j++)//输出前置空格 System.out.print(\" \"); // 只输出文件名字 System.out.println( array[i].getName().replace(\".txt\", \":\")); // 输出当前文件的完整路径 // System.out.println(\"#####\" + array[i]); // 同样输出当前文件的完整路径 大家可以去掉注释 测试一下 // System.out.println(array[i].getPath()); Reader reader = new FileReader(path +'\\\\'+array[i].getName()); // 字符编码是??? char[] buffer = new char[100]; int n; writer.append(array[i].getName().replace(\".txt\", \":\\n\")); while ((n = reader.read(buffer)) != -1) { System.out.println(buffer); for(int k = 0; k &lt; n; k++){ writer.append(buffer[k]); } } writer.write(\"\\n\"); reader.close(); // 关闭流 } else if(array[i].isDirectory())//如果是文件夹 { for (int j = 0; j &lt; deep; j++)//输出前置空格 System.out.print(\" \"); System.out.println( array[i].getName()); //System.out.println(array[i].getPath()); //文件夹需要调用递归 ，深度+1 getFile(array[i].getPath(),deep+1); } } writer.close(); } } 遇到的bug 把文件txt文件都转化成utf-8形式，不然会有乱码 write时记得关闭文件，不然数据停留在缓冲区，写不进磁盘，在txt文件里面看不见 这里用到的是字符流，区别之前的字节流 此代码参考廖雪峰老师的教程编写和jdk1.6中文文档编写","link":"/2020/05/12/java%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0%E5%92%8C%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/"},{"title":"基于ssd人脸检测训练实践","text":"实验环境 win10 tensorflow-gpu1.14.0 anaconda3.6 cuda10.0 cudnn7.6 数据预处理下载widerface数据集http://shuoyang1213.me/WIDERFACE/ 将数据打包成voc格式在我是在数据集下的相同目录下创建5个文件夹：JPEGImages：用来保存你的数据图片Annotations：这里是存放你对所有数据图片做的标注，每张照片的标注信息必须是xml格式ImageSets/Main：train.txt、val.txtTF-record:是将voc格式的数据转化成tfrecord文件的参考博客：https://blog.csdn.net/bingbign0607/article/details/105727746 运行：python widerface.py #文件名是widerface 注意文件夹的路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159import os,cv2,sys,shutil,numpyfrom xml.dom.minidom import Documentimport osdef writexml(filename, saveimg, bboxes, xmlpath): doc = Document() annotation = doc.createElement('annotation') doc.appendChild(annotation) folder = doc.createElement('folder') folder_name = doc.createTextNode('widerface') folder.appendChild(folder_name) annotation.appendChild(folder) filenamenode = doc.createElement('filename') filename_name = doc.createTextNode(filename) filenamenode.appendChild(filename_name) annotation.appendChild(filenamenode) source = doc.createElement('source') annotation.appendChild(source) database = doc.createElement('database') database.appendChild(doc.createTextNode('wider face Database')) source.appendChild(database) annotation_s = doc.createElement('annotation') annotation_s.appendChild(doc.createTextNode('PASCAL VOC2007')) source.appendChild(annotation_s) image = doc.createElement('image') image.appendChild(doc.createTextNode('flickr')) source.appendChild(image) flickrid = doc.createElement('flickrid') flickrid.appendChild(doc.createTextNode('-1')) source.appendChild(flickrid) owner = doc.createElement('owner') annotation.appendChild(owner) flickrid_o = doc.createElement('flickrid') flickrid_o.appendChild(doc.createTextNode('muke')) owner.appendChild(flickrid_o) name_o = doc.createElement('name') name_o.appendChild(doc.createTextNode('muke')) owner.appendChild(name_o) size = doc.createElement('size') annotation.appendChild(size) width = doc.createElement('width') width.appendChild(doc.createTextNode(str(saveimg.shape[1]))) height = doc.createElement('height') height.appendChild(doc.createTextNode(str(saveimg.shape[0]))) depth = doc.createElement('depth') depth.appendChild(doc.createTextNode(str(saveimg.shape[2]))) size.appendChild(width) size.appendChild(height) size.appendChild(depth) segmented = doc.createElement('segmented') segmented.appendChild(doc.createTextNode('0')) annotation.appendChild(segmented) for i in range(len(bboxes)): bbox = bboxes[i] objects = doc.createElement('object') annotation.appendChild(objects) object_name = doc.createElement('name') object_name.appendChild(doc.createTextNode('face')) objects.appendChild(object_name) pose = doc.createElement('pose') pose.appendChild(doc.createTextNode('Unspecified')) objects.appendChild(pose) truncated = doc.createElement('truncated') truncated.appendChild(doc.createTextNode('0')) objects.appendChild(truncated) difficult = doc.createElement('difficult') difficult.appendChild(doc.createTextNode('0')) objects.appendChild(difficult) bndbox = doc.createElement('bndbox') objects.appendChild(bndbox) xmin = doc.createElement('xmin') xmin.appendChild(doc.createTextNode(str(bbox[0]))) bndbox.appendChild(xmin) ymin = doc.createElement('ymin') ymin.appendChild(doc.createTextNode(str(bbox[1]))) bndbox.appendChild(ymin) xmax = doc.createElement('xmax') xmax.appendChild(doc.createTextNode(str(bbox[0] + bbox[2]))) bndbox.appendChild(xmax) ymax = doc.createElement('ymax') ymax.appendChild(doc.createTextNode(str(bbox[1] + bbox[3]))) bndbox.appendChild(ymax) f = open(xmlpath, \"w\") f.write(doc.toprettyxml(indent='')) f.close()rootdir = \"D:\\\\face\\\\dataset\\\\widerface\"gtfile = \"D:\\\\face\\\\dataset\\\\widerface\\\\wider_face_split\\\\\" \\ \"wider_face_val_bbx_gt.txt\";im_folder = \"D:\\\\face\\\\dataset\\\\widerface\\\\WIDER_val\\\\images\";##这里可以是test也可以是valfwrite = open(\"D:\\\\face\\\\dataset\\\\widerface\\\\ImageSets\\\\Main\\\\test.txt\", \"w\")with open(gtfile, \"r\") as gt: while(True): gt_con = gt.readline()[:-1] if gt_con is None or gt_con == \"\": break im_path = im_folder + \"/\" + gt_con; print(im_path) im_data = cv2.imread(im_path) if im_data is None: continue ##需要注意的一点是，图片直接经过resize之后，会存在更多的长宽比例，所以我们直接加pad sc = max(im_data.shape) im_data_tmp = numpy.zeros([sc, sc, 3], dtype=numpy.uint8) off_w = (sc - im_data.shape[1]) // 2 off_h = (sc - im_data.shape[0]) // 2 ##对图片进行周围填充，填充为正方形 im_data_tmp[off_h:im_data.shape[0]+off_h, off_w:im_data.shape[1]+off_w, ...] = im_data im_data = im_data_tmp # # cv2.imshow(\"1\", im_data) # cv2.waitKey(0) numbox = int(gt.readline()) #numbox = 0 bboxes = [] for i in range(numbox): line = gt.readline() infos = line.split(\" \") #x y w h --- #去掉最后一个（\\n） for j in range(infos.__len__() - 1): infos[j] = int(infos[j]) ##注意这里加入了数据清洗 ##保留resize到640×640 尺寸在8×8以上的人脸 if infos[2] * 80 &lt; im_data.shape[1] or infos[3] * 80 &lt; im_data.shape[0]: continue bbox = (infos[0] + off_w, infos[1] + off_h, infos[2], infos[3]) # cv2.rectangle(im_data, (int(infos[0]) + off_w, int(infos[1]) + off_h), # (int(infos[0]) + off_w + int(infos[2]), int(infos[1]) + off_h + int(infos[3])), # color=(0, 0, 255), thickness=1) bboxes.append(bbox) # cv2.imshow(\"1\", im_data) # cv2.waitKey(0) filename = gt_con.replace(\"/\", \"_\") fwrite.write(filename.split(\".\")[0] + \"\\n\") cv2.imwrite(\"{}/JPEGImages/{}\".format(rootdir, filename), im_data) xmlpath = \"{}/Annotations/{}.xml\".format(rootdir, filename.split(\".\")[0]) writexml(filename, im_data, bboxes, xmlpath)fwrite.close() 将voc数据转换成tfrecord格式参考博客:https://my.oschina.net/u/876354/blog/1927351 训练代码下载地址：https://github.com/balancap/SSD-Tensorflow 运行： 1python create_face_tf_record.py --data_dir=D:\\face\\dataset --year=widerface --output_path=D:\\face\\dataset\\widerface\\TF_data\\test.record --set=test 下载预训练模型链接：https://pan.baidu.com/s/1U9b7IlW6C4YDoFcLroL-DA提取码：idbz 训练模型12 参考博客:https://my.oschina.net/u/876354/blog/1927351 测试模型安装jupyter 运行: 1jupyter-notebook SSD-Tensorflow-master/ssd_notebook.ipynb 注意模型的路径命名 运行效果图","link":"/2020/05/10/%E5%9F%BA%E4%BA%8Essd%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E8%AE%AD%E7%BB%83%E5%AE%9E%E8%B7%B5/"},{"title":"Unit 01","text":"state12345graph LR;A[state n.] --&gt;B(statute) A --&gt; C(manifestation) A --&gt; D[assert] A --&gt; E[affirm]","link":"/2020/05/16/state/"},{"title":"HCL三层交换机配置路由","text":"开启交换机三层功能,配置合适的路由实现PC1能够ping通PC2，拓扑结构如下图所示 参考连接:https://www.xiaoheidiannao.com/HCL-Switch-Route.html","link":"/2020/05/22/HCL%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/"},{"title":"语法分析器","text":"1 实验目的掌握LR分析表的设计方法和语义加工程序的扩充 2 实验原理 自底向上的语法分析，从分析树的底部(叶节点)向顶部(根节点)方向构造分析树，可以看成是将输入串w归约为文法开始符号S的过程 自底向上语法分析的通用框架，移入-归约分析(Shift-Reduce Parsing)过程：在对输入串的一次从左到右扫描过程中，语法分析 器将零个或多个输入符号移入到栈的顶端，直到它可以对栈顶的一个文法符号串β进行归约为止。 然后，它将β归约为某个产生式的左部。 语法分析器不断地重复这个循环，直到它检测到一。 个语法错误，或者栈中包含了开始符号且输入缓冲 区为空(当进入这样的格局时，语法分析器停止运行， 并宣称成功完成了语法分析)为止。 增广文法(Augmented Grammar)，使得文法开始符号仅出现 在一个产生式的左边，从而使得分析器只有一个接受状态 FIRST ( X )：可以从X推导出的所有串首终结符构成的集合如果X ε，那么ε∈FIRST( X )。FOLLOW(A)：可能在某个句型中紧跟在A后边的终结符a的集合 FOLLOW(A)={a|S-&gt;*αAaβ, a∈VT，α,β∈(VT∪VN)} 如果A是某个句型的的最右符号，则将结束符“$”添加到FOLLOW(A)中。 构造LR(0)自动机的状态集，规范LR(0) 项集族(Canonical LR(0) Collection) SLR分析表,动作表 ACTION,转移表 GOTO sn：将符号a、状态n压入栈 rn：用第n个产生式进行归约 SLR分析表构造算法 SLR文法解决归约移入冲突的方法 已知项目集I： A1→α1.a1β1 A2→α2.a2β2 … Am→αm.amβm B1→γ1. B2→γ2. … Bn→γn. 如果集合{a1, a2, …, am}和 FOLLOW(B1)，FOLLOW(B2)，…， FOLLOW(Bn)两两不相交，则项目 集I中的冲突可以按以下原则解决： 设a是下一个输入符号 若a∈{ a1, a2, …, am}，则移进a 若a∈FOLLOW(Bi)，则用产生式 Bi→γi归约 此外，报错 3 实验环境Java Vscode 4 实验内容参照算术表达式LR分析表的设计方法，设计扩充后的算术表达式LR分析表，并对原语义加工程序修改，加入新添的内容。 算术表达式文法扩充如下： E→E+E| E-E|E*E |E/E| (E) | I 试根据该文法重新设计LR分析表，并修改语义加工程序，最后验证修改的结果。 增广文法G’为: 0) S-&gt;E 1) E-&gt;E+A 2) E-&gt;A 3) A-&gt;A-B 4) A-&gt;B 5) B-&gt;B*C 6) B-&gt;C 7) C-&gt;C/D 8) C-&gt;D 9) D-&gt;(E) 10) D-&gt;i 文法的first集和follow集 X First(X) S i ( E i ( A i ( B i ( C i ( D i ( X Follow(X) S $ E + $ ) A + - $ ) B + - * $ ) C + - * / $ ) D + - * / $ ) 自动机 SLR分析表 相关数据结构： 123456789private LinkedList&lt;Character&gt; list1 = new LinkedList&lt;Character&gt;();//保存输入字符串的列表private Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();//保存符号的栈,移入符号到该栈，用顶部的符号进行归约private Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;();//保存状态的栈，栈顶表示当前状态private Production production = new Production();//描述产生式的类private String[][] table//SLR分析表表的二维字符串数组 类设计: 一、实验结果分析 输入： i**i i+i-i*(i/i) 输出： state symbol input action 0 $ i**i$ Shift to state 7 07 $i **i$ Reduce by production 10 05 $D **i$ Reduce by production 8 04 $C **i$ Reduce by production 6 03 $B **i$ Shift to state 10 语法错误不符合SLR(1)文法 -—————————————- 在状态10，下一个符号*时，为空，所以出错 state symbol input action 0 $ i+i-i*(i/i)$ Shift to state 7 07 $i +i-i*(i/i)$ Reduce by production 10 05 $D +i-i*(i/i)$ Reduce by production 8 04 $C +i-i*(i/i)$ Reduce by production 6 03 $B +i-i*(i/i)$ Reduce by production 4 02 $A +i-i*(i/i)$ Reduce by production 2 01 $E +i-i*(i/i)$ Shift to state 8 018 $E+ i-i*(i/i)$ Shift to state 7 0187 $E+i -i*(i/i)$ Reduce by production 10 0185 $E+D -i*(i/i)$ Reduce by production 8 0184 $E+C -i*(i/i)$ Reduce by production 6 0183 $E+B -i*(i/i)$ Reduce by production 4 01813 $E+A -i*(i/i)$ Shift to state 9 018139 $E+A- i*(i/i)$ Shift to state 7 0181397 $E+A-i *(i/i)$ Reduce by production 10 0181395 $E+A-D *(i/i)$ Reduce by production 8 0181394 $E+A-C *(i/i)$ Reduce by production 6 01813914 $E+A-B *(i/i)$ Shift to state 10 0181391410 $E+A-B* (i/i)$ Shift to state 6 01813914106 $E+A-B*( i/i)$ Shift to state 7 018139141067 $E+A-B*(i /i)$ Reduce by production 10 018139141065 $E+A-B*(D /i)$ Reduce by production 8 018139141064 $E+A-B*(C /i)$ Shift to state 11 01813914106411 $E+A-B*(C/ i)$ Shift to state 7 018139141064117 $E+A-B*(C/i )$ Reduce by production 10 0181391410641116 $E+A-B*(C/D )$ Reduce by production 7 018139141064 $E+A-B*(C )$ Reduce by production 6 018139141063 $E+A-B*(B )$ Reduce by production 4 018139141062 $E+A-B*(A )$ Reduce by production 2 0181391410612 $E+A-B*(E )$ Shift to state 17 018139141061217 $E+A-B*(E) $ Reduce by production 9 01813914105 $E+A-B*D $ Reduce by production 8 018139141015 $E+A-B*C $ Reduce by production 5 01813914 $E+A-B $ Reduce by production 3 01813 $E+A $ Reduce by production 1 01 $E $ accept 语法正确，表达式符合SLR(1)文法 -—————————————- 实验结果与预期一致 5 实验总结 由于产生式是从0开始的，而我在规约时想成从1开始，从而导致归约时发生错误，如下图所示，状态13遇到+号时用了产生式3归约导致错误，my god让我又回到自动机推断了好久，我以为13是状态1和3，把我绕晕了，后来才理清思路， 导致分析表里的归约全都写错了 在状态7遇到$时忘记写上归约状态 导致归约时出错 后来我又按着自动机走了一遍并且查看follow集是否正确，才发现了错误 3.通过本次实验，使得我加深对自底向上分析方法的理解与操作，搞清楚了很多概念和算法，尤其是构造SLR1自动机和分析表，也使得我对栈链表等数据结构的使用更加熟练。 6 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.LinkedList;import java.util.Stack;public class JunMingAnalysis { private LinkedList&lt;Character&gt; list1 = new LinkedList&lt;Character&gt;();//保存输入字符串的列表 private Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();//保存符号的栈 private Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;();//保存状态的栈 private Production production = new Production();//描述产生式的类 private BufferedWriter output; private String temp1; private String actions = \"\"; //SLR分析表表的二维字符串数组 private String[][] table = { { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"2\", \"3\", \"4\", \"5\", \"1\" }, // 0 { \"\", \"S8\", \"\", \"\", \"\", \"\", \"\", \"accept\", \"\", \"\", \"\", \"\", \"\" }, // 1 { \"\", \"R2\", \"R9\", \"\", \"\", \"\", \"R2\", \"R2\", \"\", \"\", \"\", \"\", \"\" }, // 2 { \"\", \"R4\", \"R4\", \"S10\", \"\", \"\", \"R4\", \"R4\", \"\", \"\", \"\", \"\", \"\" },// 3 { \"\", \"R6\", \"R6\", \"R6\", \"S11\", \"\", \"R6\", \"R6\", \"\", \"\", \"\", \"\", \"\" },// 4 { \"\", \"R8\", \"R8\", \"R8\", \"R8\", \"\", \"R8\", \"R8\", \"\", \"\", \"\", \"\", \"\" },// 5 { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"2\", \"3\", \"4\", \"5\", \"12\" },// 6 { \"\", \"R10\", \"R10\", \"R10\", \"R10\", \"\", \"R10\", \"R10\", \"\", \"\", \"\", \"\", \"\" },// 7 { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"13\", \"3\", \"4\", \"5\", \"\" },// 8 { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"\", \"14\", \"4\", \"5\", \"\" },// 9 {\"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"\", \"\", \"15\", \"5\", \"\" },// 10 { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"\", \"\", \"\", \"16\", \"\" },// 11 { \"\", \"S8\", \"\", \"\", \"\", \"\", \"S17\", \"\", \"\", \"\", \"\", \"\", \"\" },//12 { \"\", \"R1\", \"S9\", \"\", \"\", \"\", \"R1\", \"R1\", \"\", \"\", \"\", \"\", \"\" },//13 { \"\", \"R3\", \"R3\", \"S10\", \"\", \"\", \"R3\", \"R3\", \"\", \"\", \"\", \"\", \"\" },//14 { \"\", \"R5\", \"R5\", \"R5\", \"S11\", \"\", \"R5\", \"R5\", \"\", \"\", \"\", \"\", \"\" },//15 { \"\", \"R7\", \"R7\", \"R7\", \"R7\", \"\", \"R7\", \"R7\", \"\", \"\", \"\", \"\", \"\" },//16 { \"\", \"R9\", \"R9\", \"R9\", \"R9\", \"\", \"R9\", \"R9\", \"\", \"\", \"\", \"\", \"\" },//17 }; public JunMingAnalysis() { try { output = new BufferedWriter(new FileWriter(\"output.txt\")); } catch (IOException e) { e.printStackTrace(); } } public void getText() { char a[]; BufferedReader bufferedReader = null; try { bufferedReader = new BufferedReader(new FileReader(\"input.txt\")); String lString; while ((lString = bufferedReader.readLine()) != null) { //数据预处理 stack.clear(); list1.clear(); stack2.clear(); temp1 = lString.trim(); temp1.replaceAll(\"\\\\s+\", \"\");// 去掉一个以上的空白符，用一个空白代替 a = temp1.toCharArray(); for (char _char : a) { list1.offer(_char); } list1.offerLast('$'); stack.push('$'); stack2.push(0); output.write(\"state\\t symbol\\t input\\t action\"); output.newLine(); boolean b = analysis(); if (b){ output.write(\"语法正确，表达式符合SLR(1)文法\"); output.newLine(); } else{ output.write(\"语法错误不符合SLR(1)文法\"); output.newLine(); } output.write(\"-----------------------------------------\"); output.newLine(); } } catch (Exception e) { } finally { // 关闭资源 if (bufferedReader != null) try { bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } if (output != null) try { output.close(); } catch (Exception e2) { } } } public int getOrder(char c) { //获取符号（终结符或非终结符）的编号（符号表中的横向顺序） if (c == 'i') return 0; else if (c == '+') return 1; else if (c == '-') return 2; else if (c == '*') return 3; else if (c == '/') return 4; else if (c == '(') return 5; else if (c == ')') return 6; else if (c == '$') return 7; else if(c=='A') return 8; else if(c=='B') return 9; else if(c=='C') return 10; else if(c=='D') return 11; else if(c=='E') return 12; else return -1; } public void display() { //读SymbolStack、StateStack和input里的所有字符，显示到输出文件 String symbols = \"\"; String states = \"\"; String input = \"\"; Object[] symbolObjects = stack.toArray(); for (int i = 0; i &lt; symbolObjects.length; i++) { symbols += symbolObjects[i].toString(); } Object[] stateObjects = stack2.toArray(); for (int i = 0; i &lt; stack2.size(); i++) { states += stateObjects[i].toString(); } Object[] inputObjects = list1.toArray(); for (int i = 0; i &lt; list1.size(); i++) { input += inputObjects[i].toString(); } try { output.write(states + \"\\t\" + symbols + \"\\t\" + input + \"\\t\" + actions); output.newLine(); } catch (IOException e) { e.printStackTrace(); } } public boolean analysis() { while (true) { actions = \"\"; char c = list1.peekFirst(); int i = getOrder(c); if(i==-1) //如果输入是除了规定的终结符和非终结符以外的符号，返回false return false; String string2 = table[stack2.peek()][i]; if (string2.trim().equals(\"\".trim())) return false; else if (string2.equals(\"accept\")) {//接收 actions+=\"accept\"; display(); return true; } else if (string2.charAt(0) == 'S') { // 移进 String s = string2.substring(1); // 取S后面的状态数 int n = Integer.parseInt(s); System.out.println(\"Shift \" + s); actions += \"Shift to state \" + s; display(); list1.pollFirst(); // 从输入带里弹出第一个字符，并把该字符送symbolStack,同时向StateStack压入取得的状态数 stack2.push(n); stack.push(c); } else if (string2.charAt(0) == 'R') { // 规约 String s = string2.substring(1); // 取r后面的产生式编号 int n = Integer.parseInt(s); System.out.println(\"Reduce \" + s); actions += \"Reduce by production \" + s; display(); int n2 = production.getNumOfP(n);// 取产生式右部的字符个数（应该在SymbolStack和StateStack中弹出来的个数） for (int i1 = 0; i1 &lt; n2; i1++) { stack.pop(); stack2.pop(); } char _char1 = production.getProduction(n).charAt(0);// 获取产生式左边的非终结符，压入SymbolStack stack.push(_char1); String s1 = table[stack2.peek()][getOrder(_char1)];// 查找goto字表，找到该终结符和当前状态对应的编号，压入StateStack if (s1.trim().equals(\"\")) return false; else stack2.push(Integer.parseInt(s1)); } } } public static void main(String[] args) { JunMingAnalysis ananlyzer = new JunMingAnalysis(); ananlyzer.getText(); }}public class Production { private String[] productions={\"S-&gt;E\",\"E-&gt;E+A\",\"E-&gt;A\",\"A-&gt;A-B\",\"A-&gt;B\",\"B-&gt;B*C\",\"B-&gt;C\",\"C-&gt;C/D\",\"C-&gt;D\",\"D-&gt;(E)\",\"D-&gt;i\"}; private int[] numOfP={1,3,1,3,1,3,1,3,1,3,1}; public String getProduction(int i){ return productions[i]; } public int getNumOfP(int i){ return numOfP[i]; }} ​ 资源地址：https://github.com/Jmlong23/note_src/tree/master/doc/CompilationPrinciple/exp2","link":"/2020/05/31/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"踩坑","slug":"踩坑","link":"/tags/%E8%B8%A9%E5%9D%91/"},{"name":"环境搭建","slug":"环境搭建","link":"/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"ftp","slug":"ftp","link":"/tags/ftp/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"ArrayList","slug":"ArrayList","link":"/tags/ArrayList/"},{"name":"hcl","slug":"hcl","link":"/tags/hcl/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"编译原理","slug":"编译原理","link":"/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"环境搭建","slug":"环境搭建","link":"/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"博客搭建","slug":"环境搭建/博客搭建","link":"/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"ftp配置","slug":"环境搭建/ftp配置","link":"/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ftp%E9%85%8D%E7%BD%AE/"},{"name":"组网技术","slug":"组网技术","link":"/categories/%E7%BB%84%E7%BD%91%E6%8A%80%E6%9C%AF/"},{"name":"深度学习","slug":"深度学习","link":"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"英语单词","slug":"英语单词","link":"/categories/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"}]}