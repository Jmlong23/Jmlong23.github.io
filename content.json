{"pages":[{"title":"目录","text":"","link":"/categories/index.html"},{"title":"关于","text":"等待更新……","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"83.删除排序链表中的重复元素","text":"给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例1： 12输入: 1-&gt;1-&gt;2输出: 1-&gt;2 这是一个简单的问题，仅测试你操作列表的结点指针的能力。由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。 12345678910111213class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode cur = head; while(cur != null &amp;&amp; cur.next != null){ if(cur.val == cur.next.val){ cur.next = cur.next.next; }else{ cur = cur.next; } } return head; }} 时间复杂度： 12时间复杂度：O(n)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为O(n)，其中 n 是链表表中的结点数。空间复杂度：O(1) 参考链接","link":"/2020/05/01/83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"title":"2.4 正规表达式到有限自动机的构造","text":"2.4.2 NFA确定化 $\\varepsilon$ 闭包的概念 子集法对NFA确定化","link":"/2020/04/28/2-4-%E6%AD%A3%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E6%9E%84%E9%80%A0/"},{"title":"Java关键字","text":"1 静态static关键字1.1 静态static关键字概述一旦用了static关键字修饰，那么这个元素就不再属于对象自己，而是属于类的，凡是本类的对象都共享同一份 比如下面的所在教室属性，用了static修饰，那么就属于这个学生类 2 private关键字2.1 概述问题描述：定义Person的年龄时，无法阻止不合理的数值被设置进来。解决方案：用private关键字将需要保护的成员变量进行修饰。 一旦使用了private进行修饰，那么本类当中仍然可以随意访问。但是！超出了本类范围之外就不能再直接访问了。 只可以间接访问private成员变量，就是定义一对儿Getter/Setter方法 1234567891011121314151617181920212223242526272829/*必须叫setXxx或者是getXxx命名规则。对于Getter来说，不能有参数，返回值类型和成员变量对应；对于Setter来说，不能有返回值，参数类型和成员变量对应。 */public class Person { String name; // 姓名 private int age; // 年龄 public void show() { System.out.println(\"我叫：\" + name + \"，年龄：\" + age); } // 这个成员方法，专门用于向age设置数据 public void setAge(int num) { if (num &lt; 100 &amp;&amp; num &gt;= 9) { // 如果是合理情况 age = num; } else { System.out.println(\"数据不合理！\"); } } // 这个成员方法，专门私语获取age的数据 public int getAge() { return age; }}","link":"/2020/05/06/Java%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"hexo、GitHubPage域名绑定","text":"1 域名解释在域名解释页面添加如下图所示记录 2 在source文件夹下新建CNAME文件里面写上自己的域名，如baidu.cn","link":"/2020/05/02/hexo%E3%80%81GitHubPage%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"},{"title":"InputStream和OutputStream","text":"1 例子 123456789101112131415161718192021222324import java.io.*;public class TestRead { public static void main(String[] args) throws IOException {//注意一定要抛出异常 String s; try (InputStream input = new FileInputStream(\"readme.c\")) {//1.创建 s = readAsString(input); } System.out.println(s); OutputStream output = new FileOutputStream(\"write.txt\");// 一、创建 output.write(s.getBytes(\"UTF-8\")); //二、调用方法 output.close(); } private static String readAsString(InputStream input) throws IOException { int n; StringBuilder sb = new StringBuilder(); while ((n = input.read()) != -1) {//2.使用方法 System.out.println(n); sb.append((char) n); } return sb.toString(); } }","link":"/2020/05/06/InputStream%E5%92%8COutputStream/"},{"title":"icarus主题gitalk评论配置踩坑","text":"1 在GitHub上面注册一个OAuth Apps获取相关的id和secret 2 在/Icarus/_config.yml下填写以下配置1234567comment: type: gitalk client_id: *******e35afa66dfd client_secret: ********eb0bf8c1 repo: username.github.io owner: username admin: [username] 3 遇到的错误我在写admin时直接写了username，结果报一下错误 1234567{keyword: 'type',dataPath: '.comment.admin',schemaPath: '/comment/gitalk.json/properties/admin/type',params: { type: 'array' },message: 'should be array'}, 错误是因为admin接收的时数组array而不是string。所以就算你可以正常应用，但还是会提示warn。 结果没看懂，这个错误，去GitHub问了Icarus原作者，才帮我指正，很谢谢原作者的指正。 参考资料 &lt;https://blog.zhangruipeng.me/hexo-theme-icarus/Plugins/Comment/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E7%94%A8%E6%88%B7%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#Gitalk&gt; icarus项目地址","link":"/2020/05/04/icarus%E4%B8%BB%E9%A2%98gitalk%E8%AF%84%E8%AE%BA%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/"},{"title":"java的api文档和Scanner类","text":"1 API概述 api概述 API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的 字典 ，是JDK中提供给 我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学 习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。 api使用步骤 打开帮助文档。 点击显示，找到索引，看到输入框。 你要找谁？在输入框里输入，然后回车。 看包。java.lang下的类不需要导包，其他需要。 看类的解释和说明。 学习构造方法。 使用成员方法。 2 引用类型的一般使用步骤 导包import 包路径.类名称;如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。只有java.lang包下的内容不需要导包，其他的包都需要import语句。 创建类名称 对象名 = new 类名称(); 使用对象名.成员方法名() 3 Scanner类12345678910111213141516171819202122232425262728package cn.itcast.day07.demo01;import java.util.Scanner; // 1. 导包/*Scanner类的功能：可以实现键盘输入数据，到程序当中。获取键盘输入的一个int数字：int num = sc.nextInt();获取键盘输入的一个字符串：String str = sc.next();遇到空格就会结束sc.nextLine();遇到Enter键才会结束 */public class Demo01Scanner { public static void main(String[] args) { // 2. 创建 // 备注：System.in代表从键盘进行输入 Scanner sc = new Scanner(System.in); // 3. 获取键盘输入的int数字 int num = sc.nextInt(); System.out.println(\"输入的int数字是：\" + num); // 4. 获取键盘输入的字符串 String str = sc.next(); System.out.println(\"输入的字符串是：\" + str); }}","link":"/2020/05/06/java%E7%9A%84api%E6%96%87%E6%A1%A3%E5%92%8CScanner%E7%B1%BB/"},{"title":"linux操作系统复习总结","text":"1操作系统概述1.1操作系统概述 从使用者角度看 程序开发者角度，调用操作系统的接口，如read（）函数，这些繁琐的操作留给操作系统 从所处位置看，操作系统是上层软件与硬件打交道的窗口和桥梁，是其他所有用户程序运行的基础 从设计者角度看，目标是让各种软件资源和硬件资源高效而协调地运转起来 操作系统的组成， 1. 2操作系统的发展 1946年宾夕法尼亚大学大学出现第一台通用计算机 第二代计算机，50s~60s，单道批处理系统 第三代计算机，60s中~70s初，多道批处理系统和分时系统和实时系统 四代，至今 软件角度下，操作系统的发展 单模块操作系统：进程管理，内存管理，设备管理，文件管理，通过调用函数交互，效率高，维护困难 微内核操作系统，用过通信机制交互，效率较低，维护简单 1.3开放源代码的Unix/Linux操作系统 Linux之父，linus torvalds linux遵循posix标准，所以流行 1.4Linux内核 内核子系统 进程调度 内存管理 虚拟文件系统 网络 进程间通信 1.5Linux内核源代码1.6Linux 内核模块编程入门1.7Linux 内核中链表的实现及应用2虚拟内存管理的硬件机制2.1内存寻址的演变 石器，8位寻址，Intel8080 青铜，16位寻址，Intel8086，段的引入 白银，保护模式的引入Intel80286 黄金，Intel80386，32位 常用寄存器 用于分页机制的控制寄存器 物理地址、虚拟地址及线性地址2.2段机制 段表 地址转换及保护2.3分页机制 页表 两级页表 线性地址到物理地址的转换 页面高速缓存2.4Linux中的分页机制2.5Linux中的汇编语言2.6Linux系统地址映射示例 3进程3.1进程介绍 程序和进程 进程层次结构 进程状态3.2进程控制块 信息分类 Linux进程状态及转换 进程标识符 进程之间的亲属关系 如何存放 3.3进程的组织方式 进程链表 哈希表 可运行队列 等待队列 等待队列的操作3.4进程调度 调度算法 时间片 调度时机 调度函数schedule( )-变量说明 调度程序的改进3.5进程的创建Fork()函数线程及其创建内核线程3.6与进程相关的系统调用及其应用3.7与调度相关的系统调用及应用4内存管理4.1Linux的内存管理内存的层次结构扩大了的记忆－虚拟内存虚地址到实地址转换虚拟内存、内核空间和用户空间Linux进程在虚拟内存中的标准内存段布局内核空间到物理内存的映射内核映像虚拟内存实现机制 4.2进程的用户空间管理mm_struct 结构VM_AREA_STRUCT 结构vm_operation结构创建进程用户空间虚存映射进程的虚存区举例与用户空间相关的主要系统调用mmap() 4.3请页机制实现虚存管理的重要手段页故障产生的原因缺页异常处理程序请求调页－动态内存分配技术写时复制 4.4物理内存的分配与回收物理页描述符 struct page结构页面分配与回收算法－伙伴算法物理页面的分配物理页面的回收Slab 分配机制－分配小内存通用缓冲区内核空间非连续内存区的分配vmalloc()与 kmalloc()之区别 4.5交换机制页面交换选择被换出的页面在交换区中存放页面页面交换策略页面交换守护进程kswapd 4.6内存管理实例5中断与异常5.1中断的基本知识中断源的类型外设可屏蔽中断异常及非屏蔽中断中断描述符表相关汇编指令 5.2中断描述符表的初始化IDT表项的设置初始化陷阱门和系统门中断门的设置 5.3中断处理中断和异常的硬件处理中断和异常处理中CPU的工作中断请求队列的建立中断服务例程与中断处理程序中断线共享的数据结构注册中断服务例程 5.4中断的下半部处理机制小任务机制工作队列机制下半部任务队列 5.5中断的应用－时钟中断时钟运作机制Linux时间系统时钟中断处理程序定时器及应用 6系统调用6.1系统调用与API、系统命令、内核函数系统调用与API系统调用与系统命令系统调用与内核函数系统调用与内核函数 6.2系统调用基本概念系统调用基本概念系统调用处理程序及服务例程 6.3系统调用实现调用一个系统调用初始化系统调用system_call( )函数参数传递跟踪系统调用的执行 6.4封装例程6.5添加新的系统调用6.6系统调用实例——日志收集7内核中的同步7.1临界区和竞争状态并发执行的原因临界区举例共享队列和加锁确定保护对象死 锁死锁的避免 7.2内核同步措施原子操作自旋锁信号量信号量与自旋锁的比较 7.3生产者-消费者并发实例7.4内核多任务并发实例内核任务及其之间的并发关系实现机制 8文件系统8.1Linux文件系统Linux的文件结构文件类型访问权限和文件模式软链接和硬链接安装文件系统 8.2虚拟文件系统虚拟文件系统的引入VFS中对象的演绎VFS超级块数据结构VFS的索引节点目录项对象目录项对象的数据结构与进程相关的文件结构 －文件对象文件对象数据结构的主要域与进程相关的文件结构 －用户打开文件表与进程相关的文件结构 － fs_struct结构主要数据结构间的关系 8.3文件系统的注册、安装与卸载文件系统的安装文件系统的卸载页缓冲区address_space对象的操作函数表 8.4文件的打开与读写generic_file_read()函数所执行的主要步骤从用户发出读请求到最终的从磁盘读取数据的步骤 8.5文件系统的编写Linux文件系统的实现要素什么是Romfs文件系统 9设备驱动9.1设备驱动概述9.2设备驱动程序设备驱动程序基础 9.3专用I/O端口I/O 端口设备文件中断处理用中断实现驱动程序的典型例子设备驱动程序框架 9.4字符设备驱动程序字符设备驱动程序的注册简单字符设备驱动程序举例 9.5块设备驱动程序块驱动程序的注册注册和注销一个驱动程序模块时所要调用的函数及数据结构块设备请求","link":"/2020/05/07/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"title":"关于markdown文件不能正常显示数学公式的解决方案","text":"Typora编辑器不能正常显示解决方法 latex是markdown的扩展语法，必须要打开内联公式。首先，打开偏好设置。 选择内联公式 然后重启Typora google浏览器不能正常显示下载相应插件： https://chrome.google.com/webstore/detail/tex-all-the-things/cbimabofgmfdkicghcadidpemeenbffn 参考链接","link":"/2020/04/28/%E5%85%B3%E4%BA%8Emarkdown%E6%96%87%E4%BB%B6%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"对象数组和ArrayList集合","text":"1 引入–对象数组使用学生数组，存储三个学生对象 123456789101112131415161718192021222324252627282930313233343536373839public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } publicvoid setName(String name) { this.name = name; } publicint getAge() { return age; } publicvoid setAge(int age) { this.age = age; }} public class Test01StudentArray { //创建学生数组 Student[] students = new Student[3]; //创建学生对象 Student s1 = new Student(\"曹操\",40); Student s2 = new Student(\"刘备\",35); Student s3 = new Student(\"孙权\",30); //把学生对象作为元素赋值给学生数组 students[0] = s1; students[1] = s2; students[2] = s3; //遍历学生数组 for(int x=0; x&lt;students.length; x++) { Student s = students[x]; System.out.println(s.getName()+\"‐‐‐\"+s.getAge()); }} 到目前为止，我们想存储对象数据，选择的容器，只有对象数组。而数组的长度是固定的，无法适应数据变化的需 求。为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对象数据。 2 ArrayList类2.1 基本概念和使用 查看类 java.util.ArrayList &lt;E&gt; ：该类需要 import导入使后使用。&lt;E&gt; ：表示一种指定的数据类型，叫做泛型。 E ，取自Element（元素）的首字母。在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。代码如下： ArrayList&lt;String&gt;，ArrayList&lt;Student&gt; 查看构造方法public ArrayList() ：构造一个内容为空的集合。 基本格式: ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 在JDK 7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。简化格式： ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); 查看成员方法public boolean add(E e) ： 将指定的元素添加到此集合的尾部。 参数 E e ，在构造ArrayList对象时， &lt;E&gt; 指定了什么数据类型，那么 add(E e) 方法中，只能添加什么数据 类型的对象。 例子 使用ArrayList类，存储三个字符串元素，代码如下： 1234567891011121314151617public class Test02StudentArrayList { public static void main(String[] args) { //创建学生数组 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //创建学生对象 String s1 = \"曹操\"; String s3 = \"孙权\"; //打印学生ArrayList集合 System.out.println(list); //把学生对象作为元素添加到集合 list.add(s1); list.add(s2); list.add(s3); //打印学生ArrayList集合 System.out.println(list); } } 2.2 常用方法和遍历对于元素的操作,基本体现在——增、删、查。 常用的方法有： public boolean add(E e) ：将指定的元素添加到此集合的尾部。 public E remove(int index) ：移除此集合中指定位置上的元素。返回被删除的元素。 public E get(int index) ：返回此集合中指定位置上的元素。返回获取的元素。 public int size() ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。 这些都是基本的方法，操作非常简单，代码如下: 12345678910111213141516171819202122public class Demo91ArrayListMethod{ public static void main(String[] args) { //创建集合对象 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add(\"hello\"); list.add(\"world\"); list.add(\"java\"); //public E get(int index):返回指定索引处的元素 System.out.println(\"get:\"+list.get(0)); System.out.println(\"get:\"+list.get(1)); System.out.println(\"get:\"+list.get(2)); //public int size():返回集合中的元素的个数 System.out.println(\"size:\"+list.size()); //public E remove(int index):删除指定索引处的元素，返回被删除的元素 System.out.println(\"remove:\"+list.remove(0)); //遍历输出 for(int i = 0; i &lt; list.size(); i++){ System.out.println(list.get(i)); } } } 2.3 ArrayList练习*数值添加到集合 * 生成6个1~33之间的随机整数,添加到集合,并遍历 12345678910111213141516public class Test01ArrayList { public static void main(String[] args) { // 创建Random 对象 Random random = new Random(); // 创建ArrayList 对 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 添加随机数到集合 for (int i = 0; i &lt; 6; i++) { int r = random.nextInt(33) + 1; list.add(r); } // 遍历集合输出 for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); } } }","link":"/2020/05/06/%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%92%8CArrayList%E9%9B%86%E5%90%88/"},{"title":"HCL静态聚合链路实验","text":"1 题目 2 我的预览图 3 配置sw1 配置与pc连接的口vlan10 sw1与sw3之间的trunk口 sw1与sw2之间的聚合链路，先配置聚合集，再配置trunk类型 验证聚合链路是否配置成功 在聚合链路组上配置trunk类型 3 配置sw3接口配置为trunk类型 4 pc1 ping pc2 5 pc2 https://xiaoheidiannao.com/articles/HCL-Link-Aggregation.html","link":"/2020/05/02/%E7%BB%84%E7%BD%91HCL%E9%9D%99%E6%80%81%E8%81%9A%E5%90%88%E9%93%BE%E8%B7%AF%E5%AE%9E%E9%AA%8C/"},{"title":"词法分析器实验","text":"源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140import java.io.*;import java.util.ArrayList;public class JunMingAnalysis { public static void main(String[] args) throws IOException { String s; InputStream input = new FileInputStream(\"source.c\"); s = readAsString(input); if (s.isEmpty()||s.toCharArray()[0]=='#') { System.out.println(\"源代码为空，无法进行词法分析！\"); return ; } Analysis analysis = new Analysis(s); analysis.JudgeState(0); ArrayList&lt;String&gt; token = analysis.getToken(); OutputStream output = new FileOutputStream(\"word.txt\"); for(int i = 0; i &lt; token.size(); i++){ System.out.println(token.get(i)); output.write(token.get(i).getBytes(\"UTF-8\")); } } private static String readAsString(InputStream input) throws IOException { int n; StringBuilder sb = new StringBuilder(); while ((n = input.read()) != -1) { sb.append((char) n); } return sb.toString(); }}class Analysis{ private static char[] sourceCode; //字符数组，等待解析的源程序 private char ch; private String s; private static ArrayList&lt;String&gt; token = new ArrayList&lt;&gt;();//存放解析结果 public Analysis(String s){ sourceCode = s.toCharArray(); } public void JudgeState(int curponter){ ch = sourceCode[curponter]; while((int)ch == 13 || (int)ch == 32 || (int)ch == 10){ ch = sourceCode[++curponter]; } if( ch == '#'){ System.out.println(\"end\"); }else if(isAlpha(ch)){ s = Character.toString(ch); ch = sourceCode[++curponter]; while(isAlpha(ch) || isDigital(ch)){ s = s + ch; ch = sourceCode[++curponter]; } if(!reserve(s)){ s = \"(id,\" + s + \")\"; token.add(s); } JudgeState(curponter); }else if(isDigital(ch)){ s = Character.toString(ch); ch = sourceCode[++curponter]; while(isDigital(ch)){ s = s + ch; ch = sourceCode[++curponter]; } s = \"(num,\" + s + \")\"; token.add(s); JudgeState(curponter); }else if(ch == '+'){ s = \"(+,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '-'){ s = \"(-,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '*'){ s = \"(*,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '{'){ s = \"({,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '}'){ s = \"(},null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '('){ s = \"((,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == ')'){ s = \"(),null)\"; token.add(s); JudgeState(++curponter); }else if(ch == ';'){ s = \"(;,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '='){ s = \"(=,null)\"; token.add(s); JudgeState(++curponter); }else { System.out.println(\"未收录字符:\" + ch); return; } } public ArrayList&lt;String&gt; getToken(){ return token; } private boolean isAlpha(char ch){ return Character.isLetter(ch); } private boolean isDigital(char ch){ return Character.isDigit(ch); } private boolean reserve(String s){ switch(s){ case \"while\": token.add(\"(while,null)\"); return true; case \"if\": token.add(\"(if,null)\"); return true; case \"main\": token.add(\"(main,null)\"); return true; case \"int\": token.add(\"(int,null)\"); return true; case \"return\": token.add(\"(return,null)\"); return true; default: return false; } }}","link":"/2020/05/07/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%AE%9E%E9%AA%8C/"},{"title":"facenet人脸识别算法训练","text":"实验环境 win10 tensorflow 1.12.0 anaconda3.6 facenet源码地址：https://github.com/davidsandberg/facenet 数据预处理下载数据集fw—&gt;链接：https://pan.baidu.com/s/1kH-OcCCAvLVLP1wEQxlvRg提取码：twmg 64_CASIA-FaceV5链接：https://pan.baidu.com/s/1vHk_BE6ycoz7ujPSvB9e9A提取码：20a7 CASIA-WebFace链接：https://pan.baidu.com/s/17m9Ym45g4km7VLCxedQ7GA提取码：c951 Celeba链接：https://pan.baidu.com/s/18RmCCj7uHfvtkmmb8LZoHw提取码：a6ug 用人脸检测模型检测并且剪裁出人脸","link":"/2020/05/15/facenet%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"},{"title":"基于ssd人脸检测训练实践","text":"实验环境 win10 tensorflow-gpu1.14.0 anaconda3.6 cuda10.0 cudnn7.6 数据预处理下载widerface数据集http://shuoyang1213.me/WIDERFACE/ 将数据打包成voc格式在我是在数据集下的相同目录下创建5个文件夹：JPEGImages：用来保存你的数据图片Annotations：这里是存放你对所有数据图片做的标注，每张照片的标注信息必须是xml格式ImageSets/Main：train.txt、val.txtTF-record:是将voc格式的数据转化成tfrecord文件的参考博客：https://blog.csdn.net/bingbign0607/article/details/105727746 运行：python widerface.py #文件名是widerface 注意文件夹的路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159import os,cv2,sys,shutil,numpyfrom xml.dom.minidom import Documentimport osdef writexml(filename, saveimg, bboxes, xmlpath): doc = Document() annotation = doc.createElement('annotation') doc.appendChild(annotation) folder = doc.createElement('folder') folder_name = doc.createTextNode('widerface') folder.appendChild(folder_name) annotation.appendChild(folder) filenamenode = doc.createElement('filename') filename_name = doc.createTextNode(filename) filenamenode.appendChild(filename_name) annotation.appendChild(filenamenode) source = doc.createElement('source') annotation.appendChild(source) database = doc.createElement('database') database.appendChild(doc.createTextNode('wider face Database')) source.appendChild(database) annotation_s = doc.createElement('annotation') annotation_s.appendChild(doc.createTextNode('PASCAL VOC2007')) source.appendChild(annotation_s) image = doc.createElement('image') image.appendChild(doc.createTextNode('flickr')) source.appendChild(image) flickrid = doc.createElement('flickrid') flickrid.appendChild(doc.createTextNode('-1')) source.appendChild(flickrid) owner = doc.createElement('owner') annotation.appendChild(owner) flickrid_o = doc.createElement('flickrid') flickrid_o.appendChild(doc.createTextNode('muke')) owner.appendChild(flickrid_o) name_o = doc.createElement('name') name_o.appendChild(doc.createTextNode('muke')) owner.appendChild(name_o) size = doc.createElement('size') annotation.appendChild(size) width = doc.createElement('width') width.appendChild(doc.createTextNode(str(saveimg.shape[1]))) height = doc.createElement('height') height.appendChild(doc.createTextNode(str(saveimg.shape[0]))) depth = doc.createElement('depth') depth.appendChild(doc.createTextNode(str(saveimg.shape[2]))) size.appendChild(width) size.appendChild(height) size.appendChild(depth) segmented = doc.createElement('segmented') segmented.appendChild(doc.createTextNode('0')) annotation.appendChild(segmented) for i in range(len(bboxes)): bbox = bboxes[i] objects = doc.createElement('object') annotation.appendChild(objects) object_name = doc.createElement('name') object_name.appendChild(doc.createTextNode('face')) objects.appendChild(object_name) pose = doc.createElement('pose') pose.appendChild(doc.createTextNode('Unspecified')) objects.appendChild(pose) truncated = doc.createElement('truncated') truncated.appendChild(doc.createTextNode('0')) objects.appendChild(truncated) difficult = doc.createElement('difficult') difficult.appendChild(doc.createTextNode('0')) objects.appendChild(difficult) bndbox = doc.createElement('bndbox') objects.appendChild(bndbox) xmin = doc.createElement('xmin') xmin.appendChild(doc.createTextNode(str(bbox[0]))) bndbox.appendChild(xmin) ymin = doc.createElement('ymin') ymin.appendChild(doc.createTextNode(str(bbox[1]))) bndbox.appendChild(ymin) xmax = doc.createElement('xmax') xmax.appendChild(doc.createTextNode(str(bbox[0] + bbox[2]))) bndbox.appendChild(xmax) ymax = doc.createElement('ymax') ymax.appendChild(doc.createTextNode(str(bbox[1] + bbox[3]))) bndbox.appendChild(ymax) f = open(xmlpath, \"w\") f.write(doc.toprettyxml(indent='')) f.close()rootdir = \"D:\\\\face\\\\dataset\\\\widerface\"gtfile = \"D:\\\\face\\\\dataset\\\\widerface\\\\wider_face_split\\\\\" \\ \"wider_face_val_bbx_gt.txt\";im_folder = \"D:\\\\face\\\\dataset\\\\widerface\\\\WIDER_val\\\\images\";##这里可以是test也可以是valfwrite = open(\"D:\\\\face\\\\dataset\\\\widerface\\\\ImageSets\\\\Main\\\\test.txt\", \"w\")with open(gtfile, \"r\") as gt: while(True): gt_con = gt.readline()[:-1] if gt_con is None or gt_con == \"\": break im_path = im_folder + \"/\" + gt_con; print(im_path) im_data = cv2.imread(im_path) if im_data is None: continue ##需要注意的一点是，图片直接经过resize之后，会存在更多的长宽比例，所以我们直接加pad sc = max(im_data.shape) im_data_tmp = numpy.zeros([sc, sc, 3], dtype=numpy.uint8) off_w = (sc - im_data.shape[1]) // 2 off_h = (sc - im_data.shape[0]) // 2 ##对图片进行周围填充，填充为正方形 im_data_tmp[off_h:im_data.shape[0]+off_h, off_w:im_data.shape[1]+off_w, ...] = im_data im_data = im_data_tmp # # cv2.imshow(\"1\", im_data) # cv2.waitKey(0) numbox = int(gt.readline()) #numbox = 0 bboxes = [] for i in range(numbox): line = gt.readline() infos = line.split(\" \") #x y w h --- #去掉最后一个（\\n） for j in range(infos.__len__() - 1): infos[j] = int(infos[j]) ##注意这里加入了数据清洗 ##保留resize到640×640 尺寸在8×8以上的人脸 if infos[2] * 80 &lt; im_data.shape[1] or infos[3] * 80 &lt; im_data.shape[0]: continue bbox = (infos[0] + off_w, infos[1] + off_h, infos[2], infos[3]) # cv2.rectangle(im_data, (int(infos[0]) + off_w, int(infos[1]) + off_h), # (int(infos[0]) + off_w + int(infos[2]), int(infos[1]) + off_h + int(infos[3])), # color=(0, 0, 255), thickness=1) bboxes.append(bbox) # cv2.imshow(\"1\", im_data) # cv2.waitKey(0) filename = gt_con.replace(\"/\", \"_\") fwrite.write(filename.split(\".\")[0] + \"\\n\") cv2.imwrite(\"{}/JPEGImages/{}\".format(rootdir, filename), im_data) xmlpath = \"{}/Annotations/{}.xml\".format(rootdir, filename.split(\".\")[0]) writexml(filename, im_data, bboxes, xmlpath)fwrite.close() 将voc数据转换成tfrecord格式参考博客:https://my.oschina.net/u/876354/blog/1927351 训练代码下载地址：https://github.com/balancap/SSD-Tensorflow 运行： 1python create_face_tf_record.py --data_dir=D:\\face\\dataset --year=widerface --output_path=D:\\face\\dataset\\widerface\\TF_data\\test.record --set=test 下载预训练模型链接：https://pan.baidu.com/s/1U9b7IlW6C4YDoFcLroL-DA提取码：idbz 训练模型12 参考博客:https://my.oschina.net/u/876354/blog/1927351 测试模型安装jupyter 运行: 1jupyter-notebook SSD-Tensorflow-master/ssd_notebook.ipynb 注意模型的路径命名 运行效果图","link":"/2020/05/10/%E5%9F%BA%E4%BA%8Essd%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E8%AE%AD%E7%BB%83%E5%AE%9E%E8%B7%B5/"},{"title":"Unit 01","text":"state12345graph LR;A[state n.] --&gt;B(statute) A --&gt; C(manifestation) A --&gt; D[assert] A --&gt; E[affirm]","link":"/2020/05/16/state/"},{"title":"HCL三层交换机配置路由","text":"开启交换机三层功能,配置合适的路由实现PC1能够ping通PC2，拓扑结构如下图所示 参考连接:https://www.xiaoheidiannao.com/HCL-Switch-Route.html","link":"/2020/05/22/HCL%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/"},{"title":"语法分析器","text":"1 实验目的掌握LR分析表的设计方法和语义加工程序的扩充 2 实验原理 自底向上的语法分析，从分析树的底部(叶节点)向顶部(根节点)方向构造分析树，可以看成是将输入串w归约为文法开始符号S的过程 自底向上语法分析的通用框架，移入-归约分析(Shift-Reduce Parsing)过程：在对输入串的一次从左到右扫描过程中，语法分析 器将零个或多个输入符号移入到栈的顶端，直到它可以对栈顶的一个文法符号串β进行归约为止。 然后，它将β归约为某个产生式的左部。 语法分析器不断地重复这个循环，直到它检测到一。 个语法错误，或者栈中包含了开始符号且输入缓冲 区为空(当进入这样的格局时，语法分析器停止运行， 并宣称成功完成了语法分析)为止。 增广文法(Augmented Grammar)，使得文法开始符号仅出现 在一个产生式的左边，从而使得分析器只有一个接受状态 FIRST ( X )：可以从X推导出的所有串首终结符构成的集合如果X ε，那么ε∈FIRST( X )。FOLLOW(A)：可能在某个句型中紧跟在A后边的终结符a的集合 FOLLOW(A)={a|S-&gt;*αAaβ, a∈VT，α,β∈(VT∪VN)} 如果A是某个句型的的最右符号，则将结束符“$”添加到FOLLOW(A)中。 构造LR(0)自动机的状态集，规范LR(0) 项集族(Canonical LR(0) Collection) SLR分析表,动作表 ACTION,转移表 GOTO sn：将符号a、状态n压入栈 rn：用第n个产生式进行归约 SLR分析表构造算法 SLR文法解决归约移入冲突的方法 已知项目集I： A1→α1.a1β1 A2→α2.a2β2 … Am→αm.amβm B1→γ1. B2→γ2. … Bn→γn. 如果集合{a1, a2, …, am}和 FOLLOW(B1)，FOLLOW(B2)，…， FOLLOW(Bn)两两不相交，则项目 集I中的冲突可以按以下原则解决： 设a是下一个输入符号 若a∈{ a1, a2, …, am}，则移进a 若a∈FOLLOW(Bi)，则用产生式 Bi→γi归约 此外，报错 3 实验环境Java Vscode 4 实验内容参照算术表达式LR分析表的设计方法，设计扩充后的算术表达式LR分析表，并对原语义加工程序修改，加入新添的内容。 算术表达式文法扩充如下： E→E+E| E-E|E*E |E/E| (E) | I 试根据该文法重新设计LR分析表，并修改语义加工程序，最后验证修改的结果。 增广文法G’为: 0) S-&gt;E 1) E-&gt;E+A 2) E-&gt;A 3) A-&gt;A-B 4) A-&gt;B 5) B-&gt;B*C 6) B-&gt;C 7) C-&gt;C/D 8) C-&gt;D 9) D-&gt;(E) 10) D-&gt;i 文法的first集和follow集 X First(X) S i ( E i ( A i ( B i ( C i ( D i ( X Follow(X) S $ E + $ ) A + - $ ) B + - * $ ) C + - * / $ ) D + - * / $ ) 自动机 SLR分析表 相关数据结构： 123456789private LinkedList&lt;Character&gt; list1 = new LinkedList&lt;Character&gt;();//保存输入字符串的列表private Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();//保存符号的栈,移入符号到该栈，用顶部的符号进行归约private Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;();//保存状态的栈，栈顶表示当前状态private Production production = new Production();//描述产生式的类private String[][] table//SLR分析表表的二维字符串数组 类设计: 5 实验结果分析输入： 12i**ii+i-i*(i/i) 输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596state symbol input action0 $ i**i$ Shift to state 707 $i **i$ Reduce by production 1005 $D **i$ Reduce by production 804 $C **i$ Reduce by production 603 $B **i$ Shift to state 10语法错误不符合SLR(1)文法\\-----------------------------------------在状态10，下一个符号*时，为空，所以出错state symbol input action0 $ i+i-i*(i/i)$ Shift to state 707 $i +i-i*(i/i)$ Reduce by production 1005 $D +i-i*(i/i)$ Reduce by production 804 $C +i-i*(i/i)$ Reduce by production 603 $B +i-i*(i/i)$ Reduce by production 402 $A +i-i*(i/i)$ Reduce by production 201 $E +i-i*(i/i)$ Shift to state 8018 $E+ i-i*(i/i)$ Shift to state 70187 $E+i -i*(i/i)$ Reduce by production 100185 $E+D -i*(i/i)$ Reduce by production 80184 $E+C -i*(i/i)$ Reduce by production 60183 $E+B -i*(i/i)$ Reduce by production 401813 $E+A -i*(i/i)$ Shift to state 9018139 $E+A- i*(i/i)$ Shift to state 70181397 $E+A-i *(i/i)$ Reduce by production 100181395 $E+A-D *(i/i)$ Reduce by production 80181394 $E+A-C *(i/i)$ Reduce by production 601813914 $E+A-B *(i/i)$ Shift to state 100181391410 $E+A-B* (i/i)$ Shift to state 601813914106 $E+A-B*( i/i)$ Shift to state 7018139141067 $E+A-B*(i /i)$ Reduce by production 10018139141065 $E+A-B*(D /i)$ Reduce by production 8018139141064 $E+A-B*(C /i)$ Shift to state 1101813914106411 $E+A-B*(C/ i)$ Shift to state 7018139141064117 $E+A-B*(C/i )$ Reduce by production 100181391410641116 $E+A-B*(C/D )$ Reduce by production 7018139141064 $E+A-B*(C )$ Reduce by production 6018139141063 $E+A-B*(B )$ Reduce by production 4018139141062 $E+A-B*(A )$ Reduce by production 20181391410612 $E+A-B*(E )$ Shift to state 17018139141061217 $E+A-B*(E) $ Reduce by production 901813914105 $E+A-B*D $ Reduce by production 8018139141015 $E+A-B*C $ Reduce by production 501813914 $E+A-B $ Reduce by production 301813 $E+A $ Reduce by production 101 $E $ accept语法正确，表达式符合SLR(1)文法\\-----------------------------------------实验结果与预期一致 6 实验总结 由于产生式是从0开始的，而我在规约时想成从1开始，从而导致归约时发生错误，如下图所示，状态13遇到+号时用了产生式3归约导致错误，my god让我又回到自动机推断了好久，我以为13是状态1和3，把我绕晕了，后来才理清思路， 导致分析表里的归约全都写错了 在状态7遇到$时忘记写上归约状态 导致归约时出错 后来我又按着自动机走了一遍并且查看follow集是否正确，才发现了错误 3.通过本次实验，使得我加深对自底向上分析方法的理解与操作，搞清楚了很多概念和算法，尤其是构造SLR1自动机和分析表，也使得我对栈链表等数据结构的使用更加熟练。 7 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.LinkedList;import java.util.Stack;public class JunMingAnalysis { private LinkedList&lt;Character&gt; list1 = new LinkedList&lt;Character&gt;();//保存输入字符串的列表 private Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();//保存符号的栈 private Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;();//保存状态的栈 private Production production = new Production();//描述产生式的类 private BufferedWriter output; private String temp1; private String actions = \"\"; //SLR分析表表的二维字符串数组 private String[][] table = { { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"2\", \"3\", \"4\", \"5\", \"1\" }, // 0 { \"\", \"S8\", \"\", \"\", \"\", \"\", \"\", \"accept\", \"\", \"\", \"\", \"\", \"\" }, // 1 { \"\", \"R2\", \"R9\", \"\", \"\", \"\", \"R2\", \"R2\", \"\", \"\", \"\", \"\", \"\" }, // 2 { \"\", \"R4\", \"R4\", \"S10\", \"\", \"\", \"R4\", \"R4\", \"\", \"\", \"\", \"\", \"\" },// 3 { \"\", \"R6\", \"R6\", \"R6\", \"S11\", \"\", \"R6\", \"R6\", \"\", \"\", \"\", \"\", \"\" },// 4 { \"\", \"R8\", \"R8\", \"R8\", \"R8\", \"\", \"R8\", \"R8\", \"\", \"\", \"\", \"\", \"\" },// 5 { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"2\", \"3\", \"4\", \"5\", \"12\" },// 6 { \"\", \"R10\", \"R10\", \"R10\", \"R10\", \"\", \"R10\", \"R10\", \"\", \"\", \"\", \"\", \"\" },// 7 { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"13\", \"3\", \"4\", \"5\", \"\" },// 8 { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"\", \"14\", \"4\", \"5\", \"\" },// 9 {\"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"\", \"\", \"15\", \"5\", \"\" },// 10 { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"\", \"\", \"\", \"16\", \"\" },// 11 { \"\", \"S8\", \"\", \"\", \"\", \"\", \"S17\", \"\", \"\", \"\", \"\", \"\", \"\" },//12 { \"\", \"R1\", \"S9\", \"\", \"\", \"\", \"R1\", \"R1\", \"\", \"\", \"\", \"\", \"\" },//13 { \"\", \"R3\", \"R3\", \"S10\", \"\", \"\", \"R3\", \"R3\", \"\", \"\", \"\", \"\", \"\" },//14 { \"\", \"R5\", \"R5\", \"R5\", \"S11\", \"\", \"R5\", \"R5\", \"\", \"\", \"\", \"\", \"\" },//15 { \"\", \"R7\", \"R7\", \"R7\", \"R7\", \"\", \"R7\", \"R7\", \"\", \"\", \"\", \"\", \"\" },//16 { \"\", \"R9\", \"R9\", \"R9\", \"R9\", \"\", \"R9\", \"R9\", \"\", \"\", \"\", \"\", \"\" },//17 }; public JunMingAnalysis() { try { output = new BufferedWriter(new FileWriter(\"output.txt\")); } catch (IOException e) { e.printStackTrace(); } } public void getText() { char a[]; BufferedReader bufferedReader = null; try { bufferedReader = new BufferedReader(new FileReader(\"input.txt\")); String lString; while ((lString = bufferedReader.readLine()) != null) { //数据预处理 stack.clear(); list1.clear(); stack2.clear(); temp1 = lString.trim(); temp1.replaceAll(\"\\\\s+\", \"\");// 去掉一个以上的空白符，用一个空白代替 a = temp1.toCharArray(); for (char _char : a) { list1.offer(_char); } list1.offerLast('$'); stack.push('$'); stack2.push(0); output.write(\"state\\t symbol\\t input\\t action\"); output.newLine(); boolean b = analysis(); if (b){ output.write(\"语法正确，表达式符合SLR(1)文法\"); output.newLine(); } else{ output.write(\"语法错误不符合SLR(1)文法\"); output.newLine(); } output.write(\"-----------------------------------------\"); output.newLine(); } } catch (Exception e) { } finally { // 关闭资源 if (bufferedReader != null) try { bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } if (output != null) try { output.close(); } catch (Exception e2) { } } } public int getOrder(char c) { //获取符号（终结符或非终结符）的编号（符号表中的横向顺序） if (c == 'i') return 0; else if (c == '+') return 1; else if (c == '-') return 2; else if (c == '*') return 3; else if (c == '/') return 4; else if (c == '(') return 5; else if (c == ')') return 6; else if (c == '$') return 7; else if(c=='A') return 8; else if(c=='B') return 9; else if(c=='C') return 10; else if(c=='D') return 11; else if(c=='E') return 12; else return -1; } public void display() { //读SymbolStack、StateStack和input里的所有字符，显示到输出文件 String symbols = \"\"; String states = \"\"; String input = \"\"; Object[] symbolObjects = stack.toArray(); for (int i = 0; i &lt; symbolObjects.length; i++) { symbols += symbolObjects[i].toString(); } Object[] stateObjects = stack2.toArray(); for (int i = 0; i &lt; stack2.size(); i++) { states += stateObjects[i].toString(); } Object[] inputObjects = list1.toArray(); for (int i = 0; i &lt; list1.size(); i++) { input += inputObjects[i].toString(); } try { output.write(states + \"\\t\" + symbols + \"\\t\" + input + \"\\t\" + actions); output.newLine(); } catch (IOException e) { e.printStackTrace(); } } public boolean analysis() { while (true) { actions = \"\"; char c = list1.peekFirst(); int i = getOrder(c); if(i==-1) //如果输入是除了规定的终结符和非终结符以外的符号，返回false return false; String string2 = table[stack2.peek()][i]; if (string2.trim().equals(\"\".trim())) return false; else if (string2.equals(\"accept\")) {//接收 actions+=\"accept\"; display(); return true; } else if (string2.charAt(0) == 'S') { // 移进 String s = string2.substring(1); // 取S后面的状态数 int n = Integer.parseInt(s); System.out.println(\"Shift \" + s); actions += \"Shift to state \" + s; display(); list1.pollFirst(); // 从输入带里弹出第一个字符，并把该字符送symbolStack,同时向StateStack压入取得的状态数 stack2.push(n); stack.push(c); } else if (string2.charAt(0) == 'R') { // 规约 String s = string2.substring(1); // 取r后面的产生式编号 int n = Integer.parseInt(s); System.out.println(\"Reduce \" + s); actions += \"Reduce by production \" + s; display(); int n2 = production.getNumOfP(n);// 取产生式右部的字符个数（应该在SymbolStack和StateStack中弹出来的个数） for (int i1 = 0; i1 &lt; n2; i1++) { stack.pop(); stack2.pop(); } char _char1 = production.getProduction(n).charAt(0);// 获取产生式左边的非终结符，压入SymbolStack stack.push(_char1); String s1 = table[stack2.peek()][getOrder(_char1)];// 查找goto字表，找到该终结符和当前状态对应的编号，压入StateStack if (s1.trim().equals(\"\")) return false; else stack2.push(Integer.parseInt(s1)); } } } public static void main(String[] args) { JunMingAnalysis ananlyzer = new JunMingAnalysis(); ananlyzer.getText(); }}public class Production { private String[] productions={\"S-&gt;E\",\"E-&gt;E+A\",\"E-&gt;A\",\"A-&gt;A-B\",\"A-&gt;B\",\"B-&gt;B*C\",\"B-&gt;C\",\"C-&gt;C/D\",\"C-&gt;D\",\"D-&gt;(E)\",\"D-&gt;i\"}; private int[] numOfP={1,3,1,3,1,3,1,3,1,3,1}; public String getProduction(int i){ return productions[i]; } public int getNumOfP(int i){ return numOfP[i]; }} ​ 资源地址：https://github.com/Jmlong23/note_src/tree/master/doc/CompilationPrinciple/exp2","link":"/2020/05/31/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"},{"title":"Google浏览器被恶意网站劫持","text":"解决方案如下图： 参考链接：https://blog.csdn.net/qq_32635971/article/details/72793115","link":"/2020/06/05/Google%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A2%AB%E6%81%B6%E6%84%8F%E7%BD%91%E7%AB%99%E5%8A%AB%E6%8C%81/"},{"title":"hcl配置路由器dhcp和acl","text":"配置合适的ACL,实现PC1可以访问telnetserver但是PC1不可以远程登录telnetserver,拓扑结构如下所示: 参考链接：https://www.xiaoheidiannao.com/HCL-DHCP.html 参考链接：https://www.xiaoheidiannao.com/HCL-ACL.html","link":"/2020/06/16/hcl%E9%85%8D%E7%BD%AEdhcp%E5%92%8Cacl/"},{"title":"hcl路由器ospf和交换机rip配置","text":"实现RT1和RT3的两个环回路lo0互相之间可以通信 实现SW1和SW3的两个环回路lo0互相之间可以通信 注意sw1时network那里错了,应该是172.16.1.1 然后，port的时候还应该有其他信息，没有信息，应该重启一下交换机，因为后来改了的时候没有截图，命令都差不多就放这些图片了。 参考链接： https://www.xiaoheidiannao.com/HCL-Switch-RIP-Configuration.html https://www.xiaoheidiannao.com/HCL-Router-OSPF-Configuration.html","link":"/2020/06/05/hcl%E8%B7%AF%E7%94%B1%E5%99%A8ospf%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BArip%E9%85%8D%E7%BD%AE/"},{"title":"hexo d出现错误","text":"hexo d 部署时出现以下错误1234567fatal: unable to access 'https://github.com/Jmlong23/Jmlong23.github.io.git/': Failed to connect to github.com port 443: Timed outFATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (D:\\blog\\blog\\node_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (events.js:310:20) at ChildProcess.cp.emit (D:\\blog\\blog\\node_modules\\cross-spawn\\lib\\enoent.js:34:29) at Process.ChildProcess._handle.onexit (internal/child_process.js:275:12) 解决方法用以下配置，我也不知道为什么 1git config --global http.proxy http://127.0.0.1:1080 参考链接：https://github.com/jeffsui/jeffsui.github.io/issues/76","link":"/2020/06/04/hexo-d%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF/"},{"title":"friends S03E5","text":"Excuse me!Is this your …..Sorry,sir.lesson 4 Is this your ….. No.It isn’t my umbrella. It is your umbrella. No.It isn’t my pen. It is your pen. pencil book watch coat skirt 裙子 lesson 5 Nice to meet you.","link":"/2020/06/17/friends-S03E5/"},{"title":"安装openssl和gmssl","text":"参考链接：https://blog.csdn.net/apianmuse/article/details/107353574 一、安装openssl直接安装下载地址，一直下一步 https://slproweb.com/products/Win32OpenSSL.html 测试 二、安装gmssl1 下载Strawberry PerlActiveState Perl和 Strawberry Perl最大的区别是 Strawberry Perl 里面有多包含一些 CPAN 里的模块， 所以Strawberry Perl 下载的安装文件有 80多M, 而ActiveState Perl 只有20M 左右。 下载链接：http://strawberryperl.com/ 2 下载gmsslhttp://gmssl.org/docs/quickstart.html 3 NASM下载地址：&lt;www.nasm.us&gt;4 perl Configure VC-WIN32时出错This issue is due to the Perl package File::Glob, 一些简单的修改就能修复这个. 在 Configure文件和 test/build.info这个文件,把 123use if $^O ne &quot;VMS&quot;, 'File::Glob' =&gt; qw/glob/;改成use if $^O ne &quot;VMS&quot;, 'File::Glob' =&gt; qw/:glob/; https://www.xiaoheidiannao.com/211129.html 5 nmake时出错libcrypto.* libcrypto-1_1.* &amp;&amp; EXIT 1)libcrypto-1_1.def : error LNK2001: 无法解析的外部符号 EVP_get_ciphernameslibcrypto-1_1.def : error LNK2001: 无法解析的外部符号 EVP_get_digestnameslibcrypto.lib : fatal error LNK1120: 2 个无法解析的外部命令NMAKE : fatal error U1077: “link”: 返回代码“0x1 解决方法： https://github.com/guanzhi/GmSSL/issues/992 6 nmake install关于glob的错误，未找到解决方法 测试，安装成功在C:\\Program Files (x86)\\GmSSL目录下","link":"/2020/09/21/%E5%AE%89%E8%A3%85openssl%E5%92%8Cgmssl/"},{"title":"用openssl对代码进行签名和验证的例子跑通","text":"参考例子： 源码：https://gist.github.com/irbull/08339ddcd5686f509e9826964b17bb59 源码解析：https://eclipsesource.com/blogs/2016/09/07/tutorial-code-signing-and-verification-with-openssl/ 一、vs2019项目属性配置项目目录，把openssl的bin、lib、include目录拷贝进来 引入include目录../../include 引入lib目录../../lib 导入lib里面的libcrypto.lib文件名 这部要留意，如果显示“无法解析的外部符号 _BIO_new，函数 “void __cdecl Base64Decode(char const *,unsigned char * *,unsigned int *)” (?Base64Decode@@YAXPBDPAPAEPAI@Z) 中引用了该符号”的错误就是没有导入该文件。 运行结果图： 二、原理代码签名和验证代码签名和验证是对可执行文件或脚本进行数字签名的过程，以确保您执行的软件自签名以来没有被更改。代码签名有助于防止损坏的工件，进程崩溃（意外传送错误的东西），甚至恶意意图。 代码签名和验证的工作原理如下，作者还以代码为输入执行 哈希函数，从而产生 摘要。摘要使用作者的私钥进行进行加密，得到数字签名。然后，将代码，数字签名和哈希函数传递给验证者。验证者使用相同的哈希函数从代码生成摘要，然后使用公钥解密签名。如果两个摘要都匹配，则验证者可以确信代码未被篡改。 生成密钥https://cloud.tencent.com/developer/article/1622834 1234567891011121314151617181920212223242526272829生成私钥openssl.exe genrsa -out rsa.private 1024-----BEGIN RSA PRIVATE KEY-----MIICXQIBAAKBgQC6gR460tNZV9+rjeC46Jlba6vcwgPHlh0kWdebg+/lkR5uYs3WesBmlox7W1mFfWbv93X2WTVMdVbo/MteKKR2A4Hs7+kg+BFriXhdyCazBhP5ts9fvSQUOjGjq/hI6q6oIKOfXNez1VQ5SfNKGO6grFvQq2pmrO/SyQOh2BK7XwIDAQABAoGAbtFbwf4VYOfq2kfSOGzU+tJOazzI/CXBKSFNEHXj7Jc+6r5AqmmDuzFHReDwn3X03S8/42H8XnL2cjgLKuahWQzvyCltBRYsWU/lFGg2baGsnEEeuq5OgTZZ0z5WNKAL31u8XBFlv5sCuFGu3e71ggnenkMl4GMdjx3mnMdOLpkCQQDzQxKrOhMztN5WrDzTav85+RjGFQAtSw41lwACp0+lzj+Q2rWIBl/Lt4h1Ov9MXVAaEHtyYS6DyIvdvNCIvOB7AkEAxEU1hXM7r3xuuDOzbIHCe6giveQZntDNcwIkzrg9Nc48MH1BBJeuMGWVvJQp6rab/Ih73Cnc0iwsVKClw5JFbQJBALf6CTuAj5cyelk4qEQJDwAsWUUuCtU2h4eWLQbUvNMcWkzWbCZ1E6xBoS1wMjbx96vOvV4zC3fVi5pmu5w+pNMCQQCN81xFO1V0kzNkyAfBt4uYcb9GxX1+LpgY0PkcBYZHrvQ7QavPjYBvAlmsvSAf4JiqqW+jiSdrXoVlY5bf/p91AkAwHhRLuUxplgQcyRkEXzHud5znBiOKdpztI+ngTiWOFiaC6rRtqJYJnPphqtHp4jns7nOYmy8mzJDKGmwsdCXj-----END RSA PRIVATE KEY-----生成公钥openssl.exe rsa -in rsa.private -out rsa.public -pubout -outform PEM-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC6gR460tNZV9+rjeC46Jlba6vcwgPHlh0kWdebg+/lkR5uYs3WesBmlox7W1mFfWbv93X2WTVMdVbo/MteKKR2A4Hs7+kg+BFriXhdyCazBhP5ts9fvSQUOjGjq/hI6q6oIKOfXNez1VQ5SfNKGO6grFvQq2pmrO/SyQOh2BK7XwIDAQAB-----END PUBLIC KEY----- 数字签名数字签名在发送方，分两步： （1）从内容算摘要（哈希算法） （2）从摘要明文到摘要密文，也称数字签名（发送方私钥+加密算法） 数字验证数字签名验证在接收方，分两步： （1）从摘要密文（数字签名）到摘要明文（发送方公钥+解密算法） （2）从收到的内容当场计算摘要（哈希算法），与（1）的结果比对是否一致 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &lt;iostream&gt;#include &lt;openssl/aes.h&gt;#include &lt;openssl/evp.h&gt;#include &lt;openssl/rsa.h&gt;#include &lt;openssl/pem.h&gt;#include &lt;openssl/ssl.h&gt;#include &lt;openssl/bio.h&gt;#include &lt;openssl/err.h&gt;#include &lt;assert.h&gt;std::string privateKey = &quot;-----BEGIN RSA PRIVATE KEY-----\\n&quot;\\&quot;MIIEowIBAAKCAQEAy8Dbv8prpJ/0kKhlGeJYozo2t60EG8L0561g13R29LvMR5hy\\n&quot;\\&quot;vGZlGJpmn65+A4xHXInJYiPuKzrKUnApeLZ+vw1HocOAZtWK0z3r26uA8kQYOKX9\\n&quot;\\&quot;Qt/DbCdvsF9wF8gRK0ptx9M6R13NvBxvVQApfc9jB9nTzphOgM4JiEYvlV8FLhg9\\n&quot;\\&quot;yZovMYd6Wwf3aoXK891VQxTr/kQYoq1Yp+68i6T4nNq7NWC+UNVjQHxNQMQMzU6l\\n&quot;\\&quot;WCX8zyg3yH88OAQkUXIXKfQ+NkvYQ1cxaMoVPpY72+eVthKzpMeyHkBn7ciumk5q\\n&quot;\\&quot;gLTEJAfWZpe4f4eFZj/Rc8Y8Jj2IS5kVPjUywQIDAQABAoIBADhg1u1Mv1hAAlX8\\n&quot;\\&quot;omz1Gn2f4AAW2aos2cM5UDCNw1SYmj+9SRIkaxjRsE/C4o9sw1oxrg1/z6kajV0e\\n&quot;\\&quot;N/t008FdlVKHXAIYWF93JMoVvIpMmT8jft6AN/y3NMpivgt2inmmEJZYNioFJKZG\\n&quot;\\&quot;X+/vKYvsVISZm2fw8NfnKvAQK55yu+GRWBZGOeS9K+LbYvOwcrjKhHz66m4bedKd\\n&quot;\\&quot;gVAix6NE5iwmjNXktSQlJMCjbtdNXg/xo1/G4kG2p/MO1HLcKfe1N5FgBiXj3Qjl\\n&quot;\\&quot;vgvjJZkh1as2KTgaPOBqZaP03738VnYg23ISyvfT/teArVGtxrmFP7939EvJFKpF\\n&quot;\\&quot;1wTxuDkCgYEA7t0DR37zt+dEJy+5vm7zSmN97VenwQJFWMiulkHGa0yU3lLasxxu\\n&quot;\\&quot;m0oUtndIjenIvSx6t3Y+agK2F3EPbb0AZ5wZ1p1IXs4vktgeQwSSBdqcM8LZFDvZ\\n&quot;\\&quot;uPboQnJoRdIkd62XnP5ekIEIBAfOp8v2wFpSfE7nNH2u4CpAXNSF9HsCgYEA2l8D\\n&quot;\\&quot;JrDE5m9Kkn+J4l+AdGfeBL1igPF3DnuPoV67BpgiaAgI4h25UJzXiDKKoa706S0D\\n&quot;\\&quot;4XB74zOLX11MaGPMIdhlG+SgeQfNoC5lE4ZWXNyESJH1SVgRGT9nBC2vtL6bxCVV\\n&quot;\\&quot;WBkTeC5D6c/QXcai6yw6OYyNNdp0uznKURe1xvMCgYBVYYcEjWqMuAvyferFGV+5\\n&quot;\\&quot;nWqr5gM+yJMFM2bEqupD/HHSLoeiMm2O8KIKvwSeRYzNohKTdZ7FwgZYxr8fGMoG\\n&quot;\\&quot;PxQ1VK9DxCvZL4tRpVaU5Rmknud9hg9DQG6xIbgIDR+f79sb8QjYWmcFGc1SyWOA\\n&quot;\\&quot;SkjlykZ2yt4xnqi3BfiD9QKBgGqLgRYXmXp1QoVIBRaWUi55nzHg1XbkWZqPXvz1\\n&quot;\\&quot;I3uMLv1jLjJlHk3euKqTPmC05HoApKwSHeA0/gOBmg404xyAYJTDcCidTg6hlF96\\n&quot;\\&quot;ZBja3xApZuxqM62F6dV4FQqzFX0WWhWp5n301N33r0qR6FumMKJzmVJ1TA8tmzEF\\n&quot;\\&quot;yINRAoGBAJqioYs8rK6eXzA8ywYLjqTLu/yQSLBn/4ta36K8DyCoLNlNxSuox+A5\\n&quot;\\&quot;w6z2vEfRVQDq4Hm4vBzjdi3QfYLNkTiTqLcvgWZ+eX44ogXtdTDO7c+GeMKWz4XX\\n&quot;\\&quot;uJSUVL5+CVjKLjZEJ6Qc2WZLl94xSwL71E41H4YciVnSCQxVc4Jw\\n&quot;\\&quot;-----END RSA PRIVATE KEY-----\\n\\0&quot;;std::string publicKey = &quot;-----BEGIN PUBLIC KEY-----\\n&quot;\\&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAy8Dbv8prpJ/0kKhlGeJY\\n&quot;\\&quot;ozo2t60EG8L0561g13R29LvMR5hyvGZlGJpmn65+A4xHXInJYiPuKzrKUnApeLZ+\\n&quot;\\&quot;vw1HocOAZtWK0z3r26uA8kQYOKX9Qt/DbCdvsF9wF8gRK0ptx9M6R13NvBxvVQAp\\n&quot;\\&quot;fc9jB9nTzphOgM4JiEYvlV8FLhg9yZovMYd6Wwf3aoXK891VQxTr/kQYoq1Yp+68\\n&quot;\\&quot;i6T4nNq7NWC+UNVjQHxNQMQMzU6lWCX8zyg3yH88OAQkUXIXKfQ+NkvYQ1cxaMoV\\n&quot;\\&quot;PpY72+eVthKzpMeyHkBn7ciumk5qgLTEJAfWZpe4f4eFZj/Rc8Y8Jj2IS5kVPjUy\\n&quot;\\&quot;wQIDAQAB\\n&quot;\\&quot;-----END PUBLIC KEY-----\\n&quot;;RSA* createPrivateRSA(std::string key) { RSA* rsa = NULL; const char* c_string = key.c_str(); BIO* keybio = BIO_new_mem_buf((void*)c_string, -1); if (keybio == NULL) { return 0; } rsa = PEM_read_bio_RSAPrivateKey(keybio, &amp;rsa, NULL, NULL); return rsa;}RSA* createPublicRSA(std::string key) { RSA* rsa = NULL; BIO* keybio; const char* c_string = key.c_str(); keybio = BIO_new_mem_buf((void*)c_string, -1); if (keybio == NULL) { return 0; } rsa = PEM_read_bio_RSA_PUBKEY(keybio, &amp;rsa, NULL, NULL); return rsa;}//With an RSA object and plaintext you can create the digest and binary digital signature:bool RSASign(RSA* rsa, const unsigned char* Msg, size_t MsgLen, unsigned char** EncMsg, size_t* MsgLenEnc) { EVP_MD_CTX* m_RSASignCtx = EVP_MD_CTX_create(); EVP_PKEY* priKey = EVP_PKEY_new(); EVP_PKEY_assign_RSA(priKey, rsa); if (EVP_DigestSignInit(m_RSASignCtx, NULL, EVP_sha256(), NULL, priKey) &lt;= 0) { return false; } if (EVP_DigestSignUpdate(m_RSASignCtx, Msg, MsgLen) &lt;= 0) { return false; } if (EVP_DigestSignFinal(m_RSASignCtx, NULL, MsgLenEnc) &lt;= 0) { return false; } *EncMsg = (unsigned char*)malloc(*MsgLenEnc); if (EVP_DigestSignFinal(m_RSASignCtx, *EncMsg, MsgLenEnc) &lt;= 0) { return false; } EVP_MD_CTX_free(m_RSASignCtx); return true;}//with the RSA object, original message and binary encoded signature, you can verify that the signature matches the plain text.bool RSAVerifySignature(RSA* rsa, unsigned char* MsgHash, size_t MsgHashLen, const char* Msg, size_t MsgLen, bool* Authentic) { *Authentic = false; EVP_PKEY* pubKey = EVP_PKEY_new(); EVP_PKEY_assign_RSA(pubKey, rsa); EVP_MD_CTX* m_RSAVerifyCtx = EVP_MD_CTX_create(); if (EVP_DigestVerifyInit(m_RSAVerifyCtx, NULL, EVP_sha256(), NULL, pubKey) &lt;= 0) { return false; } if (EVP_DigestVerifyUpdate(m_RSAVerifyCtx, Msg, MsgLen) &lt;= 0) { return false; } int AuthStatus = EVP_DigestVerifyFinal(m_RSAVerifyCtx, MsgHash, MsgHashLen); if (AuthStatus == 1) { *Authentic = true; EVP_MD_CTX_free(m_RSAVerifyCtx); return true; } else if (AuthStatus == 0) { *Authentic = false; EVP_MD_CTX_free(m_RSAVerifyCtx); return true; } else { *Authentic = false; EVP_MD_CTX_free(m_RSAVerifyCtx); return false; }}void Base64Encode(const unsigned char* buffer, size_t length, char** base64Text) { BIO* bio, * b64; BUF_MEM* bufferPtr; b64 = BIO_new(BIO_f_base64()); bio = BIO_new(BIO_s_mem()); bio = BIO_push(b64, bio); BIO_write(bio, buffer, length); BIO_flush(bio); BIO_get_mem_ptr(bio, &amp;bufferPtr); BIO_set_close(bio, BIO_NOCLOSE); BIO_free_all(bio); *base64Text = (*bufferPtr).data;}size_t calcDecodeLength(const char* b64input) { size_t len = strlen(b64input), padding = 0; if (b64input[len - 1] == '=' &amp;&amp; b64input[len - 2] == '=') //last two chars are = padding = 2; else if (b64input[len - 1] == '=') //last char is = padding = 1; return (len * 3) / 4 - padding;}void Base64Decode(const char* b64message, unsigned char** buffer, size_t* length) { BIO* bio, * b64; int decodeLen = calcDecodeLength(b64message); *buffer = (unsigned char*)malloc(decodeLen + 1); (*buffer)[decodeLen] = '\\0'; bio = BIO_new_mem_buf(b64message, -1); b64 = BIO_new(BIO_f_base64()); bio = BIO_push(b64, bio); *length = BIO_read(bio, *buffer, strlen(b64message)); BIO_free_all(bio);}char* signMessage(std::string privateKey, std::string plainText) { //用私钥初始化一个rsa对象 RSA* privateRSA = createPrivateRSA(privateKey); unsigned char* encMessage; char* base64Text; size_t encMessageLength; RSASign(privateRSA, (unsigned char*)plainText.c_str(), plainText.length(), &amp;encMessage, &amp;encMessageLength); Base64Encode(encMessage, encMessageLength, &amp;base64Text); free(encMessage); return base64Text;}bool verifySignature(std::string publicKey, std::string plainText, char* signatureBase64) { RSA* publicRSA = createPublicRSA(publicKey); unsigned char* encMessage; size_t encMessageLength; bool authentic; Base64Decode(signatureBase64, &amp;encMessage, &amp;encMessageLength); bool result = RSAVerifySignature(publicRSA, encMessage, encMessageLength, plainText.c_str(), plainText.length(), &amp;authentic); return result &amp; authentic;}int main() { std::string plainText = &quot;My secret message.\\n&quot;; //得到用base64表示的数字签名 char* signature = signMessage(privateKey, plainText); bool authentic = verifySignature(publicKey, &quot;My secret message.\\n&quot;, signature); if (authentic) { std::cout &lt;&lt; &quot;Authentic&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Not Authentic&quot; &lt;&lt; std::endl; }}","link":"/2020/09/22/%E7%94%A8openssl%E5%AF%B9%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E8%AF%81%E7%9A%84%E4%BE%8B%E5%AD%90%E8%B7%91%E9%80%9A/"},{"title":"数字签名相关内容","text":"一、数字签名等概念https://zhuanlan.zhihu.com/p/32754315 私钥签名，公钥解密。有不可抵赖性。用于检验内容是否被篡改，丢失等。如数字签名与验证。 公钥加密，私钥解密。用于保密 只有你有私钥，所以只有你能解开，换句话说，有私钥才能看到信息，很安全。","link":"/2020/09/22/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"},{"title":"win下Github和hexo搭建个人博客","text":"1 Git安装https://git-scm.com/download/win 2 Node.js安装https://nodejs.org/en/download/ 确认是否安装成功 123git –versionnode -vnpm -v 3 GitHub新建一个仓库名字：username.github.io 4 安装hexonpm install hexo-cli -g 好像要科学上网才可以成功安装 常用命令： 1234hexo g //生成hexo s //开启本地服务器hexo new &quot;标题&quot;hexo d //部署 配置config文件 12345url: https://Jmlong23.github.io deploy: type: git repo: https://github.com/Jmlong23/Jmlong23.github.io.git branch: master 更换主题 在GitHub复制主题仓库地址 把文件复制到themes目录下 在config里面改动theme: hexo-theme-next next主题基础操作 仓库readme有 hexo隐藏文章https://github.com/printempw/hexo-hide-posts 加上： hidden: true icarus文章布局换成两行https://blog.nowcoder.net/n/0ccada7d538b4b62b4587298d8468553 更多配置https://kuang.netlify.app/blog/hexo.html","link":"/2020/05/01/hexo+icarus%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"},{"title":"x.509数字证书的解析","text":"要求X509规格的证书，要求解析出他的 1、序列号 2、签名算法 3、使用者 4、公钥 5、有效期开始，有效期结束 时间 什么是x.509数字证书https://blog.csdn.net/xy010902100449/article/details/52145009 数字证书：数字证书就是互联网通讯中标志通讯各方身份信息的一系列数据，提供了一种在Internet上验证您身份的方式，其作用类似于司机的驾驶执照或日常生活中的身份证。它是由一个由权威机构—–CA机构，又称为证书授权，（Certificate Authority）中心发行的，人们可以在网上用它来识别对方的身份。数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。 什么叫X.509数字证书X.509 标准规定了证书可以包含什么信息，并说明了记录信息的方法（数据格式）。除了签名外，所有 X.509 证书还包含以下数据： 12345678910111213141516**版本**识别用于该证书的 X.509 标准的版本，这可以影响证书中所能指定的信息。迄今为止，已定义的版本有三个。**序列号**发放证书的实体有责任为证书指定序列号，以使其区别于该实体发放的其它证书。此信息用途很多。例如，如果某一证书被撤消，其序列号将放到证书撤消清单 (CRL) 中。**签名算法标识符**用于识别 CA 签写证书时所用的算法。**签发人姓名**签写证书的实体的 X.500 名称。它通常为一个 CA。 使用该证书意味着信任签写该证书的实体（注意：有些情况下（例如根或顶层 CA 证书），签发人会签写自己的证书）。**有效期**每个证书均只能在一个有限的时间段内有效。该有效期以起始日期和时间及终止日期和时间表示，可以短至几秒或长至一世纪。所选有效期取决于许多因素，例如用于签写证书的私钥的使用频率及愿为证书支付的金钱等。它是在没有危及相关私钥的条件下，实体可以依赖公钥值的预计时间。**主体名**证书可以识别其公钥的实体名。此名称使用 X.500 标准，因此在Internet中应是唯一的。它是实体的特征名 (DN)，例如，CN=Java Duke，OU=Java Software Division，O=Sun Microsystems Inc，C=US（这些指主体的通用名、组织单位、组织和国家）。**主体公钥信息**这是被命名实体的公钥，同时包括指定该密钥所属公钥密码系统的算法标识符及所有相关的密钥参数。 x509数字证书的数据结构和存储结构https://www.cnblogs.com/chnking/archive/2007/08/28/872104.html x.509数据证书的解码法一：用openssl解析证书格式是Base64的 https://blog.csdn.net/liumiaocn/article/details/103483123 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758解析命令-in 输入文件-out 输出文件openssl x509 -in icbc_rsa.cer -out icbc_rsa.txt -text结果：Certificate: Data: Version: 3 (0x2) Serial Number: 6c:82:ca:10:24:96:00:29:9c:49 Signature Algorithm: sha1WithRSAEncryption Issuer: CN = ICBC Test Personal CA, O = personaltest.icbc.com.cn Validity Not Before: Nov 25 07:45:12 2019 GMT Not After : Nov 25 15:59:59 2024 GMT Subject: CN = 360200274427634.p.3602, OU = 3602, O = personaltest.icbc.com.cn Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (1024 bit) Modulus: 00:f1:01:f0:ee:6c:3e:ea:8d:48:23:5a:21:99:14: 09:80:b2:b8:ba:42:e5:0e:ff:ef:33:d4:5c:e3:5f: ec:52:d1:5b:13:c0:d5:f6:ea:9e:7d:a1:33:fa:02: fe:bd:d5:fb:33:d2:55:b2:6c:c1:3c:88:61:32:37: 3e:bc:8a:36:a2:86:4c:99:be:01:e8:4e:b9:9f:92: 12:a9:01:32:e3:fe:b2:7a:88:11:07:40:67:c9:69: f9:3a:60:59:60:72:13:11:8f:f7:ad:47:a0:d6:a7: 96:01:60:22:19:84:aa:11:30:ad:63:51:d0:a1:d3: 16:d7:2a:2f:a3:48:10:cd:0d Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Authority Key Identifier: keyid:76:F9:60:A6:1D:E6:99:24:D5:F2:80:D6:87:D9:4E:A8:4B:FF:B9:51 X509v3 CRL Distribution Points: Full Name: DirName:CN = crl546, OU = crl, O = personaltest.icbc.com.cn X509v3 Subject Key Identifier: AA:A2:9C:AA:1C:74:29:F6:2E:DF:DC:B8:11:85:94:57:66:8A:60:57 Signature Algorithm: sha1WithRSAEncryption 56:5b:fb:80:e2:12:e2:0d:97:07:b5:e3:c7:a6:b4:67:52:24: 38:11:b0:ba:ff:2a:92:20:c3:77:77:19:d4:7f:74:74:35:18: 99:64:71:5b:1e:c2:71:3a:44:d9:bf:a4:49:fd:2b:da:cc:de: bf:be:dc:74:3d:a8:0e:81:4d:0a:1a:e2:b1:28:b6:12:4a:61: 79:b4:f9:1f:d2:2c:9b:40:34:4f:a7:13:bd:7b:1a:da:40:21: 8d:44:dc:58:f7:26:d3:17:68:03:82:fc:6c:72:7a:fc:fa:26: 7d:7e:94:60:0a:41:92:99:f4:fd:c0:db:12:fa:ed:f3:67:eb: db:5a:79:c6:81:4c:fa:33:ca:1c:0d:e4:e4:6b:e1:14:d7:5a: 9e:85:25:aa:d0:d2:50:99:61:a2:cc:4b:32:3f:ee:65:b7:b4: 4c:c5:19:d7:0a:2e:ca:ce:69:46:f5:5b:64:86:68:c8:db:fb: c7:ac:2a:cb:1b:7c:27:b0:b5:7a:f8:85:3c:72:bb:15:ca:4e: e0:35:bf:51:31:e1:d0:44:c7:ba:41:f8:61:a1:52:42:2d:64: 52:42:45:62:7c:56:33:ad:0b:56:d2:67:d3:78:c0:0f:8a:c4: 0a:f4:e9:1b:45:10:c0:22:26:5d:94:09:44:03:7d:d7:c1:89: 85:3f:e7:f3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051解析命令-in 输入文件-out 输出文件openssl x509 -in netca.cer -out netca.txt -text Data: Version: 3 (0x2) Serial Number: 10:e1:11:9b:0d:78:0a:3c:f3:05:3b Signature Algorithm: 1.2.156.10197.1.501 Issuer: C = CN, O = NETCA Certificate Authority, CN = NETCA SM2 TEST01 and Evaluation CA01 Validity Not Before: Sep 25 09:04:26 2018 GMT Not After : Sep 25 09:04:26 2021 GMT Subject: C = CN, ST = Guangdong, L = \\E5\\B9\\BF\\E5\\B7\\9E\\E5\\B8\\82\\E5\\A4\\A9\\E6\\B2\\B3\\E5\\8C\\BA\\E4\\BA\\94\\E5\\B1\\B1\\E8\\B7\\AF246\\E3\\80\\81248\\E3\\80\\81250\\E5\\8F\\B7302\\E8\\87\\AA\\E7\\BC\\9601C, O = \\E5\\B9\\BF\\E5\\B7\\9E\\E7\\84\\B6\\E6\\80\\A1\\E8\\BD\\AF\\E4\\BB\\B6\\E6\\9C\\89\\E9\\99\\90\\E5\\85\\AC\\E5\\8F\\B8, CN = \\E5\\B9\\BF\\E5\\B7\\9E\\E7\\84\\B6\\E6\\80\\A1\\E8\\BD\\AF\\E4\\BB\\B6\\E6\\9C\\89\\E9\\99\\90\\E5\\85\\AC\\E5\\8F\\B8 Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (256 bit) pub: 04:ea:27:31:27:ce:1d:45:fe:ce:fb:db:18:76:cc: 91:f2:9e:03:95:f7:5f:96:2c:57:c3:07:e5:7f:cf: 39:58:a7:a0:c1:a4:40:22:ee:8d:6f:92:93:93:74: 9e:59:85:90:51:c6:63:11:a8:49:38:cd:42:98:71: b9:9d:fd:35:9a ASN1 OID: SM2 X509v3 extensions: X509v3 Basic Constraints: critical CA:FALSE X509v3 Subject Key Identifier: 46:F1:FF:54:72:C5:6E:4D:DD:2C:F0:E8:8D:0E:94:8A:95:55:E8:88 X509v3 Authority Key Identifier: keyid:0C:7B:EB:62:73:03:75:FA:8C:4A:24:0C:F6:8F:3B:21:65:7E:17:E9 X509v3 Certificate Policies: Policy: 1.3.6.1.4.1.18760.13.10 CPS: http://www.cnca.net/cs/knowledge/whitepaper/cps/netCAtestcertcps.pdf X509v3 CRL Distribution Points: Full Name: URI:http://test.cnca.net/crl/SM2CA.crl X509v3 Key Usage: critical Digital Signature, Non Repudiation 1.3.6.1.4.1.18760.1.14: .$bf86d4e64b664d84deabccb6baa898bf@S02 Signature Algorithm: 1.2.156.10197.1.501 30:45:02:21:00:a5:40:8b:40:17:41:53:d0:f1:4e:3c:25:61: e7:98:ac:76:da:e1:f2:05:0a:01:8d:3d:c2:0a:e7:5d:a8:88: c1:02:20:15:64:98:1a:72:3a:bb:54:f3:fb:23:f3:67:b8:e0: da:07:a6:9f:0a:70:c4:e6:6f:c9:07:30:44:3f:c0:b2:77 用c++来解码实验效果图用SM2签名的算法 用RSA签名的算法 https://www.cnblogs.com/jiu0821/p/4598352.html https://blog.csdn.net/think_A_lot/article/details/86326604 解码RSA算法加密的证书的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567#include &quot;decodeX509Cert.h&quot;int main() { X509Reader reader; reader.loadFile(&quot;netSm2.der&quot;); reader.compileContent(); reader.showX509(); reader.displayResult(); return 0;}#pragma once#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstdlib&gt;using namespace std;/*1、序列号2、签名算法3、使用者4、公钥5、有效期开始，有效期结束 时间*/struct Seg { int num; Seg(unsigned char s) { num = (int)s; }; Seg() { num = -1; }};typedef struct Seg Seg;struct TLV { Seg type; vector&lt;Seg&gt; length; vector&lt;Seg&gt; value;};typedef struct TLV TLV;struct SignatureAlgorithm { TLV algorithm; TLV parameters;};struct subjectPublicKey { TLV algorithm; TLV parameters; TLV PKey;};struct SignatureValue { TLV signatureValue;};struct signatureArray { TLV s1, s2;};typedef struct SignatureAlgorithm SignatureAlgorithm;typedef struct subjectPublicKey subjectPublicKey;typedef struct SignatureValue SignatureValue;typedef struct signatureArray signatureArray;struct TbsCertificate { TLV version; TLV serialNumber; SignatureAlgorithm signature; vector&lt;signatureArray&gt; issuer_; vector&lt;TLV&gt; validity; vector&lt;signatureArray&gt; subject_; subjectPublicKey subjectPublicKeyInfo; TLV issuerUniqueID; TLV subjectUniqueID; vector&lt;TLV&gt; extensions;};struct X509cer { struct TbsCertificate catb; struct SignatureAlgorithm casa; struct SignatureValue casv;};class X509Reader {private: vector&lt;Seg&gt; segList; vector&lt;TLV&gt; tlvList; struct X509cer x509cert; map&lt;string, string&gt; OIDMap;public: X509Reader() { OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.10040.4.1&quot;, &quot;DSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.10040.4.3&quot;, &quot;sha1DSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.113549.1.1.1&quot;, &quot;RSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.113549.1.1.2&quot;, &quot;md2RSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.113549.1.1.3&quot;, &quot;md4RSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.113549.1.1.4&quot;, &quot;md5RSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.113549.1.1.5&quot;, &quot;sha1RSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.113549.1.1.11&quot;, &quot;sha256RSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.10045.2.1&quot;, &quot;ECC&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.10045.3.1.7&quot;, &quot;ECDSA_P256&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.156.10197.1.501&quot;, &quot;SM2&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;2.5.4.6&quot;, &quot;C&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;2.5.4.8&quot;, &quot;S&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;2.5.4.7&quot;, &quot;L&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;2.5.4.10&quot;, &quot;O&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;2.5.4.11&quot;, &quot;OU&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;2.5.4.3&quot;, &quot;CN&quot;)); } void loadFile(string filename) { std::ifstream file; file.open(filename.c_str(), ios::in | ios::binary); while (!file.eof()) { char first; file.read(&amp;first, 1); segList.push_back(Seg((unsigned char)first)); } file.close(); } //把文本的所有字节解释成tlv结构保存在tlvlist中 void compileContent() { //由于要访问i+1的地址，所以i只能到size-1 for (int i = 0; i &lt; segList.size() - 1; ) { //如果是context-specific类型的数据 if (segList[i].num &gt;&gt; 6 == 2) { int n = segList[i].num &amp; 0x1f; //如果是3，表示扩展字段 if (n == 3) { TLV t; t.type = segList[i]; if (segList[i + 1].num &lt;= 0x7f) { t.length.push_back(segList[i + 1]); i += 2; } else { int l = segList[i + 1].num - 0x80; int s = 0, base = 1; for (int j = i + 2 + l - 1; j &gt;= i + 2; j--) { s += segList[j].num * base; base *= 256; } for (int j = i + 1; j &lt; i + 2 + l; j++) { t.length.push_back(segList[j]); } i += 2 + l; } tlvList.push_back(t); } else { TLV t; t.type = segList[i]; t.length.push_back(segList[i + 1]); tlvList.push_back(t); i += 2; } } //如果是结构类型的数据 else { if (segList[i].num &gt;&gt; 5 == 1) { TLV t; t.type = segList[i]; //如果该类型的长度小于127，用一个字节表示长度 if (segList[i + 1].num &lt;= 0x7f) { t.length.push_back(segList[i + 1]); i += 2; } //否则，用多个字节表示长度 else { //l记录长度由多少个字节表示 int l = segList[i + 1].num - 0x80; //s记录长度值 int s = 0, base = 1; for (int j = i + 2 + l - 1; j &gt;= i + 2; j--) { s += segList[j].num * base; base *= 256; } //把表示长度的字节放入tlv结构中的length中 for (int j = i + 1; j &lt; i + 2 + l; j++) { t.length.push_back(segList[j]); } //偏移2+L i += 2 + l; } tlvList.push_back(t); } //其他类型的数据，如简单类型 else { TLV t; t.type = segList[i]; if (segList[i + 1].num &lt;= 0x7f) { t.length.push_back(segList[i + 1]); for (int j = i + 2; j &lt; i + 2 + segList[i + 1].num; j++) { t.value.push_back(segList[j]); } i += segList[i + 1].num + 2; } else { int l = segList[i + 1].num - 0x80; int s = 0, base = 1; for (int j = i + 2 + l - 1; j &gt;= i + 2; j--) { s += segList[j].num * base; base *= 256; } for (int j = i + 1; j &lt; i + 2 + l; j++) { t.length.push_back(segList[j]); } for (int j = i + 2 + l; j &lt; i + 2 + l + s; j++) { t.value.push_back(segList[j]); } i += 2 + l + s; } tlvList.push_back(t); } } } } //把tlvlist里面的信息段，转化成证书类x509cert里面的信息 void showX509() { //count记录证书的第几部分信息 int count = 0, extensionSize = 0; bool isExtension = false; bool isBlock31 = false; for (int i = 0; i &lt; tlvList.size() - 1; i++) { if (isExtension) { //计算扩展部分的长度还剩下多少 extensionSize -= 1 + tlvList[i].length.size() + tlvList[i].value.size(); } //如果是SET类型 if (tlvList[i].type.num == 0x31) { isBlock31 = true; continue; } else { //如果是SEQUENCE类型，且没有在SET里面时 if (tlvList[i].type.num == 0x30 &amp;&amp; isBlock31 == false) { count++; continue; } else if (tlvList[i].type.num == 0x30 &amp;&amp; isBlock31 == true) { isBlock31 = false; continue; } //如果是证书的扩展字段 else if (tlvList[i].type.num == 0xa3) { count++; isExtension = true; int base = 1; for (int j = tlvList[i].length.size() - 1; j &gt;= 1; j--) { extensionSize += tlvList[i].length[j].num * base; base *= 256; } continue; } } //第二个SEQUENCE，版本信息，证书序号，一个SEQUENCE类型，对应一段信息 if (count == 2) { if (tlvList[i].type.num == 0xa0) { x509cert.catb.version = tlvList[i + 1]; i++; } else { x509cert.catb.serialNumber = tlvList[i]; } } //第3个SEQUENCE，证书签名算法标识，和参数 else if (count == 3) { if (tlvList[i].type.num == 0x06) { x509cert.catb.signature.algorithm = tlvList[i]; } else { x509cert.catb.signature.parameters = tlvList[i]; } } //证书发行者名称 else if (count == 4) { signatureArray a; if (tlvList[i].type.num == 0x06) { a.s1 = tlvList[i]; a.s2 = tlvList[i + 1]; x509cert.catb.issuer_.push_back(a); i += 1; } } //证书有效期 else if (count == 5) { x509cert.catb.validity.push_back(tlvList[i]); x509cert.catb.validity.push_back(tlvList[i + 1]); i += 1; } //证书主题名称 else if (count == 6) { signatureArray a; if (tlvList[i].type.num == 0x06) { a.s1 = tlvList[i]; a.s2 = tlvList[i + 1]; x509cert.catb.subject_.push_back(a); i += 1; } } //count=7 没有信息 //证书公钥信息 else if (count == 8) { if (tlvList[i].type.num == 0x06) { subjectPublicKey sbk; sbk.algorithm = tlvList[i]; sbk.parameters = tlvList[i + 1]; sbk.PKey = tlvList[i + 2]; x509cert.catb.subjectPublicKeyInfo = sbk; i += 2; } } //证书扩展部分 else if (count &gt;= 9 &amp;&amp; isExtension) { if (extensionSize &gt;= 0) { x509cert.catb.extensions.push_back(tlvList[i]); } if (extensionSize == 0) { isExtension = false; } } //最后，证书签名算法标志，签名值 else { if (tlvList[i].type.num == 0x06) { if (formatOID(x509cert.catb.signature.algorithm)._Equal(&quot;SM2&quot;)) { x509cert.casa.algorithm = tlvList[i]; x509cert.casv.signatureValue = tlvList[i + 1]; i += 1; } else { x509cert.casa.algorithm = tlvList[i]; x509cert.casa.parameters = tlvList[i + 1]; x509cert.casv.signatureValue = tlvList[i + 2]; i += 2; } } } } } //有效时间的输出 string formatDate(TLV&amp; p) { string result = &quot;20&quot;; if (p.type.num == 0x17) { int count = 0; for (int i = 0; i &lt; p.value.size() - 1; i += 2) { //根据ASCII码表转化成正常时间 result = result + (char)p.value[i].num + (char)p.value[i + 1].num; if (count &lt;= 1) { result += &quot;/&quot;; } else if (count == 2) { result += &quot; &quot;; } else if (count &lt;= 4) { result += &quot;:&quot;; } count++; } return result + &quot; GMT&quot;; } else { return &quot;&quot;; } } //对OID进行还原 string formatOID(TLV&amp; p) { string result = &quot;&quot;; char num[9]; vector&lt;int&gt; V; //如果是OBJECT IDENTIFIER类型 if (p.type.num == 0x06) { for (int i = 0; i &lt; p.value.size(); i++) { //第一个字节 if (i == 0) { int v2 = p.value[i].num % 40; int v1 = (p.value[i].num - v2) / 40; V.push_back(v1); V.push_back(v2); } else { int j = i, res = 0; int base = 128; //如果大于等于128，那么该字节不是最后一位 while (p.value[j].num &gt;= 0x80) { j++; } //计算出被表示值 res = p.value[j].num; for (int k = j - 1; k &gt;= i; k--) { res += (p.value[k].num - 0x80) * base; base *= 128; } V.push_back(res); i = j; } } //拼凑成oid标识串，并且在hash表中找到相应名 for (int i = 0; i &lt; V.size(); i++) { sprintf(num, &quot;%d&quot;, V[i]); result += num; if (i &lt; V.size() - 1) { result += &quot;.&quot;; } } return OIDMap[result]; } else { return &quot;&quot;; } } //输出segList的十六进制表示 void displayOrigin() { int count = 0; for (int i = 0; i &lt; segList.size(); i++) { printf(&quot;%02x &quot;, segList[i].num); count++; if (count == 16) { cout &lt;&lt; endl; count = 0; } } } //输出tlvList里面的内容 void displayTLVOrigin() { int count = 0; bool isBlock31 = false; for (int i = 0; i &lt; tlvList.size(); i++) { if (tlvList[i].type.num == 0x31) { isBlock31 = true; } else { if (tlvList[i].type.num == 0x30 &amp;&amp; isBlock31 == false) { count++; } else if (tlvList[i].type.num == 0x30 &amp;&amp; isBlock31 == true) { isBlock31 = false; } else if (tlvList[i].type.num == 0xa3) { count++; } } cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; endl; printf(&quot;type: %02x &quot;, tlvList[i].type); printf(&quot;length: &quot;); for (int j = 0; j &lt; tlvList[i].length.size(); j++) { printf(&quot;%02x &quot;, tlvList[i].length[j]); } printf(&quot;value(%02x): &quot;, tlvList[i].value.size()); for (int j = 0; j &lt; tlvList[i].value.size(); j++) { printf(&quot;%02x &quot;, tlvList[i].value[j]); } printf(&quot;\\n&quot;); } } void printValue(TLV&amp; p, int mode = 0) { if (p.value.size() == 0) { printf(&quot;NULL&quot;); } else { for (int i = 0; i &lt; p.value.size(); i++) { //如果时BIG STRING类型，那么把前面没用的那个字节省略掉 if (p.type.num == 0x03 &amp;&amp; i == 0) continue; //如果是表示ASCII码的类型，那么按字符输出 if (p.type.num == 0x13 || p.type.num == 0x0c) { printf(&quot;%c&quot;, p.value[i].num); } //否则按十六进制输出 else { //如果没指定参数，有空格输出 if (mode == 0) { printf(&quot;%02x &quot;, p.value[i].num); } else { printf(&quot;%02x&quot;, p.value[i].num); } } } //如果是表示ASCII码的类型 if (p.type.num == 0x0c) { printf(&quot;(UTF-8)&quot;); } } printf(&quot;\\n&quot;); } void displayResult() { printf(&quot;SerialNumber: &quot;); printValue(x509cert.catb.serialNumber, 1); printf(&quot;SignatureAlgorithm: &quot;); cout &lt;&lt; formatOID(x509cert.catb.signature.algorithm) &lt;&lt; endl; printf(&quot;Subject:\\n&quot;); for (int i = 0; i &lt; x509cert.catb.subject_.size(); i++) { cout &lt;&lt; &quot; &quot; &lt;&lt; formatOID(x509cert.catb.subject_[i].s1); printf(&quot; = &quot;); printValue(x509cert.catb.subject_[i].s2); } printf(&quot;Validity:\\n notBefore: &quot;); cout &lt;&lt; formatDate(x509cert.catb.validity[0]) &lt;&lt; endl; printf(&quot; notAfter: &quot;); cout &lt;&lt; formatDate(x509cert.catb.validity[1]) &lt;&lt; endl; /*其他信息 printf(&quot; PKey: &quot;); printValue(x509cert.catb.subjectPublicKeyInfo.PKey); printf(&quot;Version: V%d\\n&quot;, x509cert.catb.version.value[0].num + 1); printf(&quot; Params: &quot;); printValue(x509cert.catb.signature.parameters); printf(&quot;Issuer: \\n&quot;); for (int i = 0; i &lt; x509cert.catb.issuer_.size(); i++) { cout &lt;&lt; &quot; &quot; &lt;&lt; formatOID(x509cert.catb.issuer_[i].s1); printf(&quot; = &quot;); printValue(x509cert.catb.issuer_[i].s2); } printf(&quot;subjectPublicKeyInfo:\\n&quot;); //公钥算法 printf(&quot; Algorithm: &quot;); cout &lt;&lt; formatOID(x509cert.catb.subjectPublicKeyInfo.algorithm) &lt;&lt; endl; printf(&quot; Params: &quot;); printValue(x509cert.catb.subjectPublicKeyInfo.parameters); printf(&quot;issuerUniqueID: &quot;); printValue(x509cert.catb.issuerUniqueID); printf(&quot;subjectUniqueID: &quot;); printValue(x509cert.catb.subjectUniqueID); printf(&quot;Extensions:\\n&quot;); printf(&quot; Other: ellipsis\\n&quot;); /* 拓展部分不翻译 for(int i = 0; i &lt; x509cert.catb.extensions.size(); i++) { if(x509cert.catb.extensions[i].type.num == 0x01) { printf(&quot; isCACertification: &quot;); printValue(x509cert.catb.extensions[i]); printf(&quot; Other: ellipsis\\n&quot;); break; } } printf(&quot;SignatureAlgorithm:\\n&quot;); printf(&quot; Algorithm: &quot;); cout &lt;&lt; formatOID(x509cert.casa.algorithm) &lt;&lt; endl; printf(&quot; Params: &quot;); printValue(x509cert.casa.parameters); printf(&quot;SignatureValue: &quot;); printValue(x509cert.casv.signatureValue); */ }}; 算法描述1）、打开一个二进制的证书文件，按字节把文件中所有字节读入到字符容器中 2）、","link":"/2020/09/24/x-509%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E8%A7%A3%E6%9E%90/"},{"title":"Base64编码与解码","text":"原理http://blog.chacuo.net/719.html 工具https://base64.guru/converter/decode/file c语言实现https://blog.csdn.net/qq_26093511/article/details/78836087","link":"/2020/09/28/Base64%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/"},{"title":"ascii码表","text":"ASCII对照表 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 “ 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL 特殊字符解释 NUL空 VT 垂直制表 SYN 空转同步 STX 正文开始 CR 回车 CAN 作废 ETX 正文结束 SO 移位输出 EM 纸尽 EOY 传输结束 SI 移位输入 SUB 换置 ENQ 询问字符 DLE 空格 ESC 换码 ACK 承认 DC1 设备控制1 FS 文字分隔符 BEL 报警 DC2 设备控制2 GS 组分隔符 BS 退一格 DC3 设备控制3 RS 记录分隔符 HT 横向列表 DC4 设备控制4 US 单元分隔符 LF 换行 NAK 否定 DEL 删除 https://tool.oschina.net/commons?type=4","link":"/2020/09/25/ascii%E7%A0%81%E8%A1%A8/"},{"title":"windows窗口程序基础","text":"学习资料： https://docs.microsoft.com/zh-cn/cpp/mfc/mfc-desktop-applications?view=msvc-160 http://c.biancheng.net/cpp/mfc/ 网融解析证书项目：https://github.com/Jmlong23/signVerifyWithCSP 无法解析的错误，看csp那篇博客 第一个程序打开vs-》新建-》Windows桌面向导-》桌面程序-》空项目 https://blog.csdn.net/hyman_c/article/details/53057037 123456789#include &quot;windows.h&quot;int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow){ MessageBoxA(NULL, &quot;Hello Win32&quot;, &quot;sdk&quot;, MB_ABORTRETRYIGNORE | MB_ICONERROR); return 0;} “const char *” 类型的实参与 “LPCWSTR” 类型的形参不兼容,改成字符集改成多字节才不会出现乱码 https://blog.csdn.net/harrywater123/article/details/51418888 官方例子 https://docs.microsoft.com/zh-cn/cpp/windows/walkthrough-creating-windows-desktop-applications-cpp?view=vs-2019 从零开始创建Windows窗口https://blog.csdn.net/hyman_c/article/details/53447695 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;windows.h&gt;HINSTANCE g_hInstance = 0;//窗口处理函数LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam){ switch (uMsg) { case WM_DESTROY: PostQuitMessage(0);//可以使GetMessage返回0 break; default: break; } return DefWindowProc(hWnd, uMsg, wParam, lParam);}//注册窗口类BOOL Register(LPCSTR lpClassName, WNDPROC wndProc){ WNDCLASSEX wce = { 0 }; wce.cbSize = sizeof(wce); wce.cbClsExtra = 0; wce.cbWndExtra = 0; wce.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); wce.hCursor = NULL; wce.hIcon = NULL; wce.hIconSm = NULL; wce.hInstance = g_hInstance; wce.lpfnWndProc = wndProc; wce.lpszClassName = lpClassName; wce.lpszMenuName = NULL; wce.style = CS_HREDRAW | CS_VREDRAW; ATOM nAtom = RegisterClassEx(&amp;wce); if (nAtom == 0) return FALSE; return true;}//创建主窗口HWND CreateMain(LPCSTR lpClassName, LPCSTR lpWndName){ HWND hWnd = CreateWindowEx(0, lpClassName, lpWndName, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, g_hInstance, NULL); return hWnd;}//显示窗口void Display(HWND hWnd){ ShowWindow(hWnd, SW_SHOW); UpdateWindow(hWnd);}//消息循环void Message(){ MSG nMsg = { 0 }; while (GetMessage(&amp;nMsg, NULL, 0, 0)) { TranslateMessage(&amp;nMsg); DispatchMessage(&amp;nMsg); }}int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow){ // TODO: Place code here. g_hInstance = hInstance; BOOL nRet = Register((LPCSTR)&quot;Main&quot;, WndProc); if (!nRet) { MessageBox(NULL, &quot;注册失败&quot;, &quot;Infor&quot;, MB_OK); return 0; } HWND hWnd = CreateMain((LPCSTR)&quot;Main&quot;, (LPCSTR)&quot;window&quot;); Display(hWnd); Message(); return 0;} windows程序创建过程https://blog.csdn.net/hyman_c/article/details/53447695 创建一个Windows界面程序共分为7步： （1）定义WinMain函数（这是windows界面程序的入口）。 （2）定义窗口处理函数。 （3）注册窗口 （4）创建窗口 （5）显示窗口 （6）编写消息循环函数 （7）处理消息(在第二步的窗口处理函数中) windows消息机制https://blog.csdn.net/hyman_c/article/details/53729066 看代码1 代码1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;windows.h&gt;// C 运行时头文件#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;memory.h&gt;#include &lt;tchar.h&gt;#include &lt;stdio.h&gt;HINSTANCE g_hInstance = 0;//窗口处理函数 LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam){ switch (uMsg) { case WM_DESTROY: PostQuitMessage(0);//可以使GetMessage返回0 break; case WM_CREATE: { CREATESTRUCT crt = *((CREATESTRUCT*)lParam); char buf[256] = { 0 }; sprintf(buf, &quot;创建的窗口类名称是%s，窗口名称是%s&quot;, crt.lpszClass, crt.lpszName); MessageBox(NULL, buf, &quot;消息处理&quot;, MB_OK); } case WM_QUIT: { int param = (int)wParam; char buf[256]; sprintf(buf, &quot;进程退出，退出码:%d&quot;, param); MessageBox(NULL, buf, &quot;消息处理&quot;, MB_OK); } case WM_SYSCOMMAND: { if (wParam == SC_MAXIMIZE) { short x = LOWORD(lParam); short y = HIWORD(lParam); char buf[256]; sprintf(buf, &quot;窗口最大化，x坐标:%d，y坐标:%d&quot;, x, y); MessageBox(NULL, buf, &quot;消息处理&quot;, MB_OK); } } case WM_SIZE: { if (wParam == SIZE_MAXIMIZED) { short width = LOWORD(lParam); short hight = HIWORD(lParam); char buf[256]; sprintf(buf, &quot;窗口最大化，高度:%d，宽度:%d&quot;, hight, width); MessageBox(NULL, buf, &quot;消息处理&quot;, MB_OK); } } default: break; } return DefWindowProc(hWnd, uMsg, wParam, lParam);}//注册窗口类 BOOL Register(LPSTR lpClassName, WNDPROC wndProc){ WNDCLASSEX wce = { 0 }; wce.cbSize = sizeof(wce); wce.cbClsExtra = 0; wce.cbWndExtra = 0; wce.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); wce.hCursor = NULL; wce.hIcon = NULL; wce.hIconSm = NULL; wce.hInstance = g_hInstance; wce.lpfnWndProc = wndProc; wce.lpszClassName = lpClassName; wce.lpszMenuName = NULL; wce.style = CS_HREDRAW | CS_VREDRAW; ATOM nAtom = RegisterClassEx(&amp;wce); if (nAtom == 0) return FALSE; return true;}//创建主窗口 HWND CreateMain(LPSTR lpClassName, LPSTR lpWndName){ HWND hWnd = CreateWindowEx(0, lpClassName, lpWndName, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, g_hInstance, NULL); return hWnd;}//显示窗口 void Display(HWND hWnd){ ShowWindow(hWnd, SW_SHOW); UpdateWindow(hWnd);}//消息循环 void Message(){ MSG nMsg = { 0 }; //GetMessage()不断的在消息队列中抓取消息 while (GetMessage(&amp;nMsg, NULL, 0, 0)) { /* GetMessage()获取到消息后，TranslateMessage会将消息进行翻译， 主要是把虚拟键消息转换为字符消息。字符消息被寄送到调用线程的消息队列里， 当下一次线程调用函数GetMessage或PeekMessage时被读出。 Windows中每一个键盘按键，都对应了一个宏，这个键盘按键发出的消息就是虚拟键消息。 TranslateMessage的作用就是将虚拟键消息转成字符消息WM_CHAR、WM_SYSCHAR等等。 */ TranslateMessage(&amp;nMsg); //把信息发给信息处理函数 DispatchMessage(&amp;nMsg); }}int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow){ // TODO: Place code here. g_hInstance = hInstance; BOOL nRet = Register((LPSTR)&quot;Main&quot;, WndProc); if (!nRet) { MessageBox(NULL, &quot;注册失败&quot;, &quot;Infor&quot;, MB_OK); return 0; } HWND hWnd = CreateMain((LPSTR)&quot;Main&quot;, (LPSTR)&quot;window&quot;); Display(hWnd); Message(); return 0;}","link":"/2020/09/28/windows%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"},{"title":"微软的CSP架构","text":"问题无法解析的外部符号impCertFreeCertificateContext https://blog.csdn.net/diaoxuesong/article/details/78664663 在跑用csp获取证书那个例子时，遇到错误，只要在 项目属性 - 链接器 - 输入 - 附加依赖项 中加入： Crypt32.lib 即可。 CSP入门简介https://blog.csdn.net/liuhuiyi/article/details/7778742 CryptAcquireContext函数https://blog.csdn.net/Qiplus/article/details/8086100?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.edu_weight Csp第一个例子https://blog.csdn.net/liuhuiyi/article/details/7778968 看代码一 CSP第二个例子https://blog.csdn.net/liuhuiyi/article/details/7787435 运行结果 1234567891011121314151617打开句柄成功获得签名密钥成功。we get the length of the public key.we get the memory.export the public key.CreateHash succeed.HashData succeed. Get the length of signature.get the memory.signature succeed.Signature:8a7595ada1c9125a86b4d01687a35768bd22728519302bfdd37559be6e2e1a64b5ff2d33803debb17d43cf3c6e50f21bbebe8ae2dfb7eab3c27d6c1b7142cd1ca4b28527021bd9849d63f6421a2e7a0f3df12371bd03ba18d9f608b3a5f4d21384b634a77f621b79991de2a8c324c7d968abf5a076bace2fd09c3f4e3708a1aeOK.Import the key.创建哈希对象成功数据哈希完成.验证签名成功。 看代码二 https://www.cnblogs.com/whbCNW/tag/CSP/ 探索用CSP获取商店里面的证书来进行签名和验证https://www.sysadmins.lv/retired-msft-blogs/alejacma/how-to-sign-and-verify-with-cryptoapi-and-a-user-certificate.aspx https://zhuanlan.zhihu.com/p/38105475 - 看代码4 用CSP获取系统里面的证书并且显示https://www.coder.work/article/982837 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;conio.h&gt;#include &lt;windows.h&gt;#include &lt;wincrypt.h&gt;#include &lt;string&gt;using namespace std;#define CERT_PERSONAL_STORE_NAME L&quot;My&quot;#define CERT_OTHER_PEOPLE_STORE_NAME L&quot;AddressBook&quot;#define MY_TYPE (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)#define BUFSIZE 1024void printfSerial(unsigned long count,unsigned char* str) { for (int i = 0; i &lt; count; i++) { printf(&quot;%2.2x&quot;, str[count - i -1]); } printf(&quot;\\n&quot;);}void printfPublicKey(unsigned long count, unsigned char* str) { for (int i = 0; i &lt; count; i++) { printf(&quot;%2.2x&quot;, str[i]); } printf(&quot;\\n&quot;);}void printfSubject(unsigned long count, unsigned char* str) { for (int i = 0; i &lt; count; i++) { printf(&quot;%c&quot;, str[i]); } printf(&quot;\\n&quot;);}void main() { HCERTSTORE hCertStore = NULL; PCCERT_CONTEXT pCertContext = NULL; PBYTE pbPKEY = NULL; DWORD iPKEYSize; const char* str = &quot;360200265999946.p.3602&quot;; DWORD dwNum = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0); // 转换成 宽字节大小9 (8+1) wchar_t* SignerName = new WCHAR[dwNum]; // 按宽字节 new 内存 memset(SignerName, 0, dwNum * sizeof(wchar_t)); // 全置0 可以用这句 memset(wch, 0, sizeof(wch)); // memset( the_array, '\\0', sizeof(the_array) ); 这是将一个数组的所以分量设置成零的很便捷的方法 MultiByteToWideChar(CP_ACP, 0, str, -1, SignerName, dwNum * sizeof(wchar_t)); //s转换到宽字节wch hCertStore = CertOpenStore( CERT_STORE_PROV_SYSTEM, 0, NULL, CERT_SYSTEM_STORE_CURRENT_USER, CERT_PERSONAL_STORE_NAME ); pCertContext = CertFindCertificateInStore( hCertStore, MY_TYPE, 0, CERT_FIND_SUBJECT_STR, SignerName, pCertContext ); //printf(&quot;version:%ld&quot;, pCertContext-&gt;pCertInfo-&gt;dwVersion + 1); printf(&quot;SerialNumber:&quot;); printfSerial(pCertContext-&gt;pCertInfo-&gt;SerialNumber.cbData, pCertContext-&gt;pCertInfo-&gt;SerialNumber.pbData); printf(&quot;SignatureAlgorithm:%s\\n&quot;, pCertContext-&gt;pCertInfo-&gt;SignatureAlgorithm.pszObjId); printf(&quot;Subject:\\n&quot;); printfSubject(pCertContext-&gt;pCertInfo-&gt;Subject.cbData,pCertContext-&gt;pCertInfo-&gt;Subject.pbData); printf(&quot;PublicKey:&quot;); printfPublicKey(pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo.PublicKey.cbData, pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo.PublicKey.pbData);} 读取usbkey中的密钥容器https://www.geek-share.com/detail/2730619280.html https://blog.csdn.net/xuebing1995/article/details/79388971 看代码3 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;direct.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;Windows.h&gt;using namespace std;void main() { DWORD dwIndex = 9; DWORD dwType = 0; DWORD dwNameLen = 0; HCRYPTPROV hProv = NULL; DWORD dwErr; while (CryptEnumProviders(dwIndex, NULL, 0, &amp;dwType, NULL, &amp;dwNameLen)) { DWORD dwItem = 0; TCHAR* pName = new TCHAR[dwNameLen + 1]; if (CryptEnumProviders(dwIndex++, NULL, 0, &amp;dwType, pName, &amp;dwNameLen)) { if (!CryptAcquireContext(&amp;hProv, NULL, pName, dwType, 0)) { dwErr = GetLastError(); } else { int num = WideCharToMultiByte(CP_OEMCP, NULL, (LPWSTR)pName, -1, NULL, 0, NULL, FALSE); char* pchar = new char[num]; WideCharToMultiByte(CP_OEMCP, NULL, (LPWSTR)pName, -1, pchar, num, NULL, FALSE); printf(&quot;%s\\n&quot;, pchar); } } } printf(&quot;end&quot;);} 调用网融公司包来签名验证的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include&lt;pkiapi.h&gt;#include&lt;pkiapp.h&gt;using namespace std;void main() { if (!pkiInit()) { cout &lt;&lt; &quot;succeed\\n&quot;; } else { cout &lt;&lt; &quot;error\\n&quot;; } BYTE* label = (unsigned char*)&quot;360200265999946.p.3602&quot;; LABEL_TYPE type = LBL_CERT; BYTE* buf; int size; if (!pkiReadLabel(label, type, NULL, &amp;size)) { cout &lt;&lt; &quot;succeed\\n&quot;; } else { cout &lt;&lt; &quot;error\\n&quot;; } BYTE* i_keyLabel = (unsigned char*)&quot;76f960a61de69924d5f280d687d94ea84bffb951&quot;; BYTE* i_keyPasswd = (unsigned char*)&quot;123456&quot;; ALG_ID digestAlgo = 32780; PKI_DATA i_inData; i_inData.size = 3; i_inData.value = (unsigned char*)&quot;abc&quot;; /// &lt;summary&gt; //分配内存 /// &lt;/summary&gt; PKI_DATA* signature = (PKI_DATA*)malloc(1000); /*PKI_DATA signature; signature.size = 300; signature.value = (BYTE*)malloc(signature.size);*/ //cout&lt;&lt;pkiSignData(i_keyLabel, i_keyPasswd, i_inData, signature)&lt;&lt;endl; cout &lt;&lt; pkiGetSignature(i_keyLabel, i_keyPasswd, digestAlgo, i_inData, signature) &lt;&lt; endl; if (!pkiGetSignature(i_keyLabel, i_keyPasswd, digestAlgo, i_inData, signature)) { cout &lt;&lt; &quot;succeed\\n&quot;; } else { cout &lt;&lt; &quot;error\\n&quot;; } /*if (!pkiVerifySignature(NULL, i_inData, *signature)) { cout &lt;&lt; &quot;succeed\\n&quot;; } else { cout &lt;&lt; &quot;error\\n&quot;; }*/ if (!pkiEnd()) { cout &lt;&lt; &quot;succeed\\n&quot;; } else { cout &lt;&lt; &quot;error\\n&quot;; }} 代码4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400// Includes#include &lt;stdio.h&gt;#include &lt;conio.h&gt;#include &lt;windows.h&gt;#include &lt;wincrypt.h&gt;// Defines#define CERT_PERSONAL_STORE_NAME L&quot;My&quot;#define CERT_OTHER_PEOPLE_STORE_NAME L&quot;AddressBook&quot;#define MY_TYPE (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)#define BUFSIZE 1024// Local functionsvoid Sign(wchar_t* SignerName, wchar_t* DataFileName, wchar_t* SignatureFileName);void Verify(wchar_t* SignerName, wchar_t* SignatureFileName, wchar_t* DataFileName);// ShowUsageAndExitvoid ShowUsageAndExit(){ wprintf(L&quot;Usage:\\n&quot;); wprintf(L&quot; - To sign: SignVerify s signer_name data_file signature_file\\n&quot;); wprintf(L&quot; - To verify: SignVerify v signer_name data_file signature_file\\n&quot;); wprintf(L&quot;\\n&lt;&lt; Press any key to continue &gt;&gt;\\n&quot;); _getch(); exit(1);}// End of ShowUsageAndExit// CheckErrorvoid CheckError(BOOL condition, const wchar_t* message){ wprintf(message); if (condition) { wprintf(L&quot;SUCCESS\\n&quot;); } else { // TODO: Some cleanup wprintf(L&quot;FAILURE (0x%x)\\n&quot;, GetLastError()); wprintf(L&quot;\\n&lt;&lt; Press any key to continue &gt;&gt;\\n&quot;); _getch(); exit(1); }}// End CheckError// Mainvoid wmain(int argc, wchar_t* argv[]){ // Usage if (argc != 5) { ShowUsageAndExit(); } if (!wcscmp(argv[1], L&quot;s&quot;)) { // Sign Sign(argv[2], argv[3], argv[4]); } else if (!wcscmp(argv[1], L&quot;v&quot;)) { // Verify Verify(argv[2], argv[3], argv[4]); } else { // Error ShowUsageAndExit(); } // The end wprintf(L&quot;\\n&lt;&lt; Press any key to continue &gt;&gt;\\n&quot;); _getch();}// End of main// Signvoid Sign(wchar_t* SignerName, wchar_t* DataFileName, wchar_t* SignatureFileName){ // Variables HCERTSTORE hStoreHandle = NULL; PCCERT_CONTEXT pSignerCert = NULL; HCRYPTPROV hCryptProv = NULL; DWORD dwKeySpec = 0; HCRYPTHASH hHash = NULL; HANDLE hDataFile = NULL; BOOL bResult = FALSE; BYTE rgbFile[BUFSIZE]; DWORD cbRead = 0; DWORD dwSigLen = 0; BYTE* pbSignature = NULL; HANDLE hSignatureFile = NULL; DWORD lpNumberOfBytesWritten = 0; wprintf(L&quot;SIGNING\\n\\n&quot;); // Open the certificate store. hStoreHandle = CertOpenStore( CERT_STORE_PROV_SYSTEM, 0, NULL, CERT_SYSTEM_STORE_CURRENT_USER, CERT_PERSONAL_STORE_NAME ); CheckError((BOOL)hStoreHandle, L&quot;CertOpenStore....................... &quot;); // Get signer's certificate with access to private key. do { // Get a certificate that matches the search criteria pSignerCert = CertFindCertificateInStore( hStoreHandle, MY_TYPE, 0, CERT_FIND_SUBJECT_STR, SignerName, pSignerCert ); CheckError((BOOL)pSignerCert, L&quot;CertFindCertificateInStore.......... &quot;); // Get the CSP, and check if we can sign with the private key bResult = CryptAcquireCertificatePrivateKey( pSignerCert, 0, NULL, &amp;hCryptProv, &amp;dwKeySpec, NULL ); CheckError(bResult, L&quot;CryptAcquireCertificatePrivateKey... &quot;); } while ((dwKeySpec &amp; AT_SIGNATURE) != AT_SIGNATURE); // Create the hash object. bResult = CryptCreateHash( hCryptProv, CALG_MD5, 0, 0, &amp;hHash ); CheckError(bResult, L&quot;CryptCreateHash..................... &quot;); // Open the file with the content to be signed hDataFile = CreateFileW(DataFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL ); CheckError((hDataFile != INVALID_HANDLE_VALUE), L&quot;CreateFile.......................... &quot;); // Compute the cryptographic hash of the data. while (bResult = ReadFile(hDataFile, rgbFile, BUFSIZE, &amp;cbRead, NULL)) { if (cbRead == 0) { break; } CheckError(bResult, L&quot;ReadFile............................ &quot;); bResult = CryptHashData( hHash, rgbFile, cbRead, 0 ); CheckError(bResult, L&quot;CryptHashData....................... &quot;); } CheckError(bResult, L&quot;ReadFile............................ &quot;); // Sign the hash object dwSigLen = 0; bResult = CryptSignHash( hHash, AT_SIGNATURE, NULL, 0, NULL, &amp;dwSigLen ); CheckError(bResult, L&quot;CryptSignHash....................... &quot;); pbSignature = (BYTE*)malloc(dwSigLen); CheckError((BOOL)pbSignature, L&quot;malloc.............................. &quot;); bResult = CryptSignHash( hHash, AT_SIGNATURE, NULL, 0, pbSignature, &amp;dwSigLen ); CheckError(bResult, L&quot;CryptSignHash....................... &quot;); // Create a file to save the signature hSignatureFile = CreateFileW( SignatureFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ); CheckError((hSignatureFile != INVALID_HANDLE_VALUE), L&quot;CreateFile.......................... &quot;); // Write the signature to the file bResult = WriteFile( hSignatureFile, (LPCVOID)pbSignature, dwSigLen, &amp;lpNumberOfBytesWritten, NULL ); CheckError(bResult, L&quot;WriteFile........................... &quot;); // Clean up and free memory. free(pbSignature); CloseHandle(hDataFile); CloseHandle(hSignatureFile); bResult = CryptDestroyHash(hHash); CheckError(bResult, L&quot;CryptDestroyHash.................... &quot;); bResult = CertFreeCertificateContext(pSignerCert); CheckError(bResult, L&quot;CertFreeCertificateContext.......... &quot;); bResult = CertCloseStore( hStoreHandle, CERT_CLOSE_STORE_CHECK_FLAG ); CheckError(bResult, L&quot;CertCloseStore...................... &quot;);}// End of Sign// Verifyvoid Verify(wchar_t* SignerName, wchar_t* DataFileName, wchar_t* SignatureFileName){ // Variables HCERTSTORE hStoreHandle = NULL; PCCERT_CONTEXT pSignerCert = NULL; DWORD dwKeySpec = 0; HCRYPTPROV hCryptProv = NULL; HCRYPTHASH hHash = NULL; HANDLE hDataFile = NULL; BOOL bResult = FALSE; BYTE rgbFile[BUFSIZE]; DWORD cbRead = 0; HANDLE hSignatureFile = NULL; BYTE* pbBinary = NULL; DWORD cbBinary = 0; HCRYPTKEY hPubKey = NULL; wprintf(L&quot;VERIFYING\\n\\n&quot;); // Open the certificate store. hStoreHandle = CertOpenStore( CERT_STORE_PROV_SYSTEM, 0, NULL, CERT_SYSTEM_STORE_CURRENT_USER, CERT_PERSONAL_STORE_NAME ); CheckError((BOOL)hStoreHandle, L&quot;CertOpenStore....................... &quot;); // Get a certificate that matches the search criteria pSignerCert = CertFindCertificateInStore( hStoreHandle, MY_TYPE, 0, CERT_FIND_SUBJECT_STR, SignerName, pSignerCert ); CheckError((BOOL)pSignerCert, L&quot;CertFindCertificateInStore.......... &quot;); // Get the CSP bResult = CryptAcquireContext( &amp;hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT ); CheckError(bResult, L&quot;CryptAcquireContext................. &quot;); // Create the hash object. bResult = CryptCreateHash( hCryptProv, CALG_MD5, 0, 0, &amp;hHash ); CheckError(bResult, L&quot;CryptCreateHash..................... &quot;); // Open the file with the content that was signed. hDataFile = CreateFileW( DataFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL ); CheckError((hDataFile != INVALID_HANDLE_VALUE), L&quot;CreateFile.......................... &quot;); // Compute the cryptographic hash of the data. while (bResult = ReadFile(hDataFile, rgbFile, BUFSIZE, &amp;cbRead, NULL)) { if (cbRead == 0) { break; } CheckError(bResult, L&quot;ReadFile............................ &quot;); bResult = CryptHashData( hHash, rgbFile, cbRead, 0 ); CheckError(bResult, L&quot;CryptHashData....................... &quot;); } CheckError(bResult, L&quot;ReadFile............................ &quot;); // Open the file with the signature hSignatureFile = CreateFileW( SignatureFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL ); CheckError((hSignatureFile != INVALID_HANDLE_VALUE), L&quot;CreateFile.......................... &quot;); // Read the signature from the file pbBinary = (BYTE*)malloc(BUFSIZE); CheckError((BOOL)pbBinary, L&quot;malloc.............................. &quot;); bResult = ReadFile(hSignatureFile, pbBinary, BUFSIZE, &amp;cbBinary, NULL); CheckError(bResult, L&quot;ReadFile............................ &quot;); // Get the public key from the certificate CryptImportPublicKeyInfo( hCryptProv, MY_TYPE, &amp;pSignerCert-&gt;pCertInfo-&gt;SubjectPublicKeyInfo, &amp;hPubKey ); CheckError(bResult, L&quot;CryptImportPublicKeyInfo............ &quot;); // Verify the signature bResult = CryptVerifySignature( hHash, pbBinary, cbBinary, hPubKey, NULL, 0 ); CheckError(bResult, L&quot;CryptVerifySignature................ &quot;); // Clean up and free memory. free(pbBinary); CloseHandle(hDataFile); CloseHandle(hSignatureFile); bResult = CryptDestroyHash(hHash); CheckError(bResult, L&quot;CryptDestroyHash.................... &quot;); bResult = CertFreeCertificateContext(pSignerCert); CheckError(bResult, L&quot;CertFreeCertificateContext.......... &quot;); bResult = CertCloseStore( hStoreHandle, CERT_CLOSE_STORE_CHECK_FLAG ); CheckError(bResult, L&quot;CertCloseStore...................... &quot;); bResult = CryptReleaseContext( hCryptProv, 0 ); CheckError(bResult, L&quot;CryptReleaseContext................. &quot;);}// End of Verify 代码3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include &lt;stdio.h&gt;#include &lt;direct.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;Windows.h&gt;#include &lt;Wincrypt.h&gt;using namespace std;#pragma warning(disable:4996)#pragma comment(lib, &quot;Crypt32&quot;)#define PROV_LENGTH 255#define MY_ENCODING_TYPE (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)struct keyInfo{ string certUserName; string providerName; string containerName;};void GetListProvider(vector&lt;string&gt;&amp; vProList){ DWORD dwIndex = 0; DWORD dwType = 0; char szKeyName[PROV_LENGTH] = { 0 }; DWORD dwMaxSubKey = PROV_LENGTH; while (CryptEnumProviders(dwIndex++, NULL, 0, &amp;dwType, (LPWSTR)szKeyName, &amp;dwMaxSubKey)) { int num = WideCharToMultiByte(CP_OEMCP, NULL, (LPWSTR)szKeyName, -1, NULL, 0, NULL, FALSE); char* pchar = new char[num]; WideCharToMultiByte(CP_OEMCP, NULL, (LPWSTR)szKeyName, -1, pchar, num, NULL, FALSE); if (dwType == PROV_RSA_FULL &amp;&amp; strnicmp(&quot;Microsoft&quot;, pchar, 9)) //csp类型 + 不区分大小写比较前9个字符 { vProList.push_back(pchar); } memset(szKeyName, 0, PROV_LENGTH); dwMaxSubKey = PROV_LENGTH; }}DWORD GetCertificate(HCRYPTPROV hProv, BYTE* pCertificate, DWORD* pCertificateLen){ if (hProv == NULL) return -1; //获取所获取密钥类型的句柄 //获取公私钥对和交换密钥,公私钥用来签名,而交换密钥用来导出会话密钥 HCRYPTKEY hSignKey; if (CryptGetUserKey(hProv, AT_SIGNATURE, &amp;hSignKey) == FALSE) { printf(&quot;CSP获取密钥句柄失败\\n&quot;); return -1; } if (CryptGetKeyParam(hSignKey, KP_CERTIFICATE, pCertificate, pCertificateLen, 0) == FALSE) { printf(&quot;CSP得到密钥参数失败\\n&quot;); return -1; } if (CryptDestroyKey(hSignKey) == FALSE) { printf(&quot;CSP销毁密钥失败\\n&quot;); return -1; } return 0;}DWORD DecodeX509Cert(BYTE* pCertificate, DWORD certificateLen, char keyID[255], char userName[255]){ PCCERT_CONTEXT pctx = CertCreateCertificateContext(MY_ENCODING_TYPE, pCertificate, certificateLen); //从编码证书中创建一个证书上下文。但这个上下文并不放到证书库里 if (pctx == NULL) { printf(&quot;解析证书失败\\n&quot;); return -1; } //找到扩展对象 PCERT_EXTENSION pCertExt = CertFindExtension(szOID_AUTHORITY_KEY_IDENTIFIER2, pctx-&gt;pCertInfo-&gt;cExtension, pctx-&gt;pCertInfo-&gt;rgExtension); //通过OID来查找扩展 if (!pCertExt) { printf(&quot;证书属性不存在\\n&quot;); return -1; } //解码对象,得到属性结构体 DWORD ulDataLen = 512; BYTE btData[512] = { 0 }; CHAR csProperty[512] = { 0 }; PCERT_AUTHORITY_KEY_ID2_INFO pAuthorityKeyID2 = (PCERT_AUTHORITY_KEY_ID2_INFO)btData; if (CryptDecodeObject(MY_ENCODING_TYPE, szOID_AUTHORITY_KEY_IDENTIFIER2, pCertExt-&gt;Value.pbData, pCertExt-&gt;Value.cbData, CRYPT_DECODE_NOCOPY_FLAG, pAuthorityKeyID2, &amp;ulDataLen)) //对属性结构体进行解码 { //获取颁发机构标识符 for (ULONG ulIndex = 0; ulIndex &lt; pAuthorityKeyID2-&gt;KeyId.cbData; ulIndex++) { CHAR csKeyID[8] = { 0 }; sprintf_s(csKeyID, 8, &quot;%02x &quot;, pAuthorityKeyID2-&gt;KeyId.pbData[ulIndex]); strcat_s(csProperty, 512, csKeyID); } csProperty[strlen(csProperty) - 1] = 0; strcpy(keyID, csProperty); //获取userName TCHAR sName[255]; DWORD nNameSize = 255; DWORD nNameType = 0; CertGetNameString(pctx, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, &amp;nNameType, sName, nNameSize); //得到证书的主题或颁发者名称并且把它转换成字符串 strcpy(userName, (char*)sName); CertFreeCertificateContext(pctx); return 0; } else { CertFreeCertificateContext(pctx); return -1; }}int getKeyList(){ //1.获取注册表中的Provider printf(&quot;\\n**1**---------------------------------获取Provider-------------------------------\\n&quot;); vector&lt;string&gt; vProvList; GetListProvider(vProvList); int numProv = vProvList.size(); if (numProv == 0) { printf(&quot;获取注册表中的Provider失败\\n&quot;); return -1; } for (int i = 0; i &lt; numProv; i++) { printf(&quot;%s\\n&quot;, vProvList[i].c_str()); } printf(&quot;\\n&quot;); vector&lt;string&gt; vContainer; printf(&quot;\\n**2**---------------------------------取出Container-------------------------------\\n&quot;); //2.获取Provider对应的句柄，枚举Container for (int i = 0; i &lt; numProv; i++) { HCRYPTPROV hProv = NULL; size_t size = vProvList[i].length(); wchar_t* buffer = new wchar_t[size + 1]; MultiByteToWideChar(CP_ACP, 0, vProvList[i].c_str(), size, buffer, size * sizeof(wchar_t)); buffer[size] = 0; //确保以 '\\0' 结尾 if (CryptAcquireContext(&amp;hProv, NULL, buffer, PROV_RSA_FULL, 0)) //获取Provider对应的句柄 { printf(&quot;%s---ok\\n&quot;, vProvList[i].c_str()); BYTE pbData[512] = { 0 }; DWORD cbData = 512; if (CryptGetProvParam(hProv, PP_ENUMCONTAINERS, pbData, &amp;cbData, CRYPT_FIRST)) //枚举container { printf(&quot;[%s]\\n&quot;, pbData); vContainer.push_back((char*)pbData); memset(pbData, 0, sizeof(pbData)); cbData = 512; while (CryptGetProvParam(hProv, PP_ENUMCONTAINERS, pbData, &amp;cbData, CRYPT_NEXT)) { printf(&quot;[%s]\\n&quot;, pbData); vContainer.push_back((char*)pbData); memset(pbData, 0, sizeof(pbData)); cbData = 512; } } else { DWORD errcode = GetLastError(); printf(&quot;[%s]CryptGetProvParam失败！--%d\\n&quot;, vProvList[i].c_str(), errcode); } CryptReleaseContext(hProv, 0); printf(&quot;\\n&quot;); } else { DWORD errcode = GetLastError(); printf(&quot;[%s]------CryptAcquireContext失败！---%d\\n&quot;, vProvList[i].c_str(), errcode); } } printf(&quot;\\n**3**---------------------------------取出Container对应证书-------------------------------\\n&quot;); //3.打开Container、Provider对应的加密设备，取出签名证书，取出证书信息（颁发机构标识符等） for (size_t i = 0; i &lt; vContainer.size(); i++) { for (int j = 0; j &lt; numProv; j++) { HCRYPTPROV hProv = NULL; if (CryptAcquireContext(&amp;hProv, (LPCWSTR)vContainer[i].c_str(), (LPCWSTR)vProvList[j].c_str(), PROV_RSA_FULL, 0)) { printf(&quot;[%s]------open container ok\\n&quot;, vContainer[i].c_str()); BYTE pbData[512] = { 0 }; DWORD cbData = 512; BYTE pCertificate[4096] = { 0 }; DWORD certificateLen = 4096; if (!GetCertificate(hProv, pCertificate, &amp;certificateLen)) //获取签名证书 { char userName[255] = { 0 }; char keyID[255] = { 0 }; if (!DecodeX509Cert(pCertificate, certificateLen, keyID, userName)) //获取证书【颁发机构标识符】-【用户名】 { printf(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;证书信息\\n&quot;); printf(&quot;keyID=%s\\n&quot;, keyID); printf(&quot;userName=%s\\n&quot;, userName); } } CryptReleaseContext(hProv, 0); printf(&quot;\\n&quot;); } else { printf(&quot;[%s]------CryptAcquireContext失败！\\n&quot;, vProvList[j].c_str()); } } } return 0;}int main(){ char buffer[100] = { 0 }; getcwd(buffer, 100); printf(&quot;%s\\n&quot;, buffer); getKeyList(); printf(&quot;\\n\\n########################################################################\\n\\n&quot;); Sleep(1000); getKeyList(); getchar(); return 0;} 代码2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;#include &lt;wincrypt.h&gt;void main() { HCRYPTPROV hProv; BYTE* puBuffer = (BYTE*)&quot;data hash and sign.one plus.&quot;; DWORD dwBufferLen = strlen((char*)puBuffer) + 1; HCRYPTHASH hHash; HCRYPTKEY hKey; //签名密钥句柄 HCRYPTKEY hPubKey; BYTE* pbKeyBlob; //保存密钥blob缓冲区指针 BYTE* pbSignature; DWORD dwSigLen; DWORD dwBlobLen; DWORD i; if (CryptAcquireContext(&amp;hProv, (LPCWSTR)&quot;test&quot;, NULL, PROV_RSA_FULL, 0)) printf(&quot;打开句柄成功\\n&quot;); else { if (!CryptAcquireContext(&amp;hProv, (LPCWSTR)&quot;test&quot;, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET)) printf(&quot;创建失败。\\n&quot;); } if (CryptGetUserKey(hProv, AT_SIGNATURE, &amp;hKey)) printf(&quot;获得签名密钥成功。\\n&quot;); else { printf(&quot;获取失败，现在创建新的RSA密钥对。\\n&quot;); if (!CryptAcquireContext(&amp;hProv, (LPCWSTR)&quot;test&quot;, NULL, PROV_RSA_FULL, 0)) printf(&quot;获取CSP句柄失败\\n&quot;); if (!CryptGenKey(hProv, 2, CRYPT_EXPORTABLE | 0X04000000, &amp;hKey)) printf(&quot;CryptGenKey error.\\n&quot;); } if (CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, NULL, &amp;dwBlobLen)) printf(&quot;we get the length of the public key.\\n&quot;); else printf(&quot;CryptExportKey erro.\\n&quot;); if (pbKeyBlob = (BYTE*)malloc(dwBlobLen)) printf(&quot;we get the memory.\\n&quot;); else printf(&quot;malloc erro.\\n&quot;); if (CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, pbKeyBlob, &amp;dwBlobLen)) printf(&quot;export the public key.\\n&quot;); else printf(&quot;CryptExportKeya error.\\n&quot;); if (CryptCreateHash(hProv, CALG_SHA1, 0, 0, &amp;hHash)) printf(&quot;CreateHash succeed.\\n&quot;); else printf(&quot;CreatHash error.\\n&quot;); //获得摘要 if (CryptHashData(hHash, puBuffer, dwBufferLen, 0)) printf(&quot;HashData succeed.\\n &quot;); else printf(&quot;HashData error.\\n&quot;); dwSigLen = 0; if (CryptSignHash(hHash, AT_SIGNATURE, NULL, 0, NULL, &amp;dwSigLen)) printf(&quot;Get the length of signature.\\n&quot;); else printf(&quot;CryptSignHash error.\\n&quot;); if (pbSignature = (BYTE*)malloc(dwSigLen)) printf(&quot;get the memory.\\n&quot;); else printf(&quot;memory error.\\n&quot;); //获得签名 if (CryptSignHash(hHash, AT_SIGNATURE, NULL, 0, pbSignature, &amp;dwSigLen)) printf(&quot;signature succeed.\\n&quot;); else printf(&quot;Signature error.\\n&quot;); printf(&quot;Signature: \\n&quot;); for (i = 0; i &lt; dwSigLen; i++) { if ((i == 0) &amp;&amp; (i != 0)) printf(&quot;\\n&quot;); //小数点后的数字代表最大宽度,小数点前的数字代表最小宽度，十六进制输出 printf(&quot;%2.2x&quot;, pbSignature[i]); } printf(&quot;\\n&quot;); printf(&quot;OK.\\n&quot;); if (hHash) CryptDestroyHash(hHash); if (CryptImportKey(hProv, pbKeyBlob, dwBlobLen, 0, 0, &amp;hPubKey)) printf(&quot;Import the key.\\n&quot;); else printf(&quot;erro&quot;); if (CryptCreateHash(hProv, CALG_SHA1, 0, 0, &amp;hHash)) printf(&quot;创建哈希对象成功 \\n&quot;); else printf(&quot;调用CryptCreateHash失败&quot;); if (CryptHashData(hHash, puBuffer, dwBufferLen, 0)) printf(&quot;数据哈希完成.\\n&quot;); else printf(&quot;调用CryptHashData失败&quot;); if (CryptVerifySignature(hHash, pbSignature, dwSigLen, hPubKey, NULL, 0)) printf(&quot;验证签名成功。\\n&quot;); else printf(&quot;签名验证失败，签名无效&quot;); if (pbSignature) free(pbSignature); if (hHash) CryptDestroyHash(hHash); if (hProv) CryptReleaseContext(hProv, 0); system(&quot;pause&quot;);} 代码1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;wincrypt.h&gt;#define MY_ENCODING_TYPE (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)#define KEYLENGTH 0x00800000void HandleError(const char* s);//--------------------------------------------------------------------// These additional #define statements are required.#define ENCRYPT_ALGORITHM CALG_RC4 #define ENCRYPT_BLOCK_SIZE 8 // Declare the function EncryptFile. The function definition// follows main.BOOL EncryptFile( PCHAR szSource, PCHAR szDestination, PCHAR szPassword);//--------------------------------------------------------------------// Begin main.void main(void){ CHAR szSource[100]; CHAR szDestination[100]; CHAR szPassword[100]; printf(&quot;Encrypt a file. \\n\\n&quot;); printf(&quot;Enter the name of the file to be encrypted: &quot;); scanf(&quot;%s&quot;, szSource); printf(&quot;Enter the name of the output file: &quot;); scanf(&quot;%s&quot;, szDestination); printf(&quot;Enter the password:&quot;); scanf(&quot;%s&quot;, szPassword); //-------------------------------------------------------------------- // Call EncryptFile to do the actual encryption. if (EncryptFile(szSource, szDestination, szPassword)) { printf(&quot;Encryption of the file %s was a success. \\n&quot;, szSource); printf(&quot;The encrypted data is in file %s.\\n&quot;, szDestination); } else { HandleError(&quot;Error encrypting file!&quot;); }} // End of main//--------------------------------------------------------------------// Code for the function EncryptFile called by main.static BOOL EncryptFile( PCHAR szSource, PCHAR szDestination, PCHAR szPassword) //-------------------------------------------------------------------- // Parameters passed are: // szSource, the name of the input, a plaintext file. // szDestination, the name of the output, an encrypted file to be // created. // szPassword, the password.{ //-------------------------------------------------------------------- // Declare and initialize local variables. FILE* hSource; FILE* hDestination; HCRYPTPROV hCryptProv; HCRYPTKEY hKey; HCRYPTHASH hHash; PBYTE pbBuffer; DWORD dwBlockLen; DWORD dwBufferLen; DWORD dwCount; //-------------------------------------------------------------------- // Open source file. if (hSource = fopen(szSource, &quot;rb&quot;)) { printf(&quot;The source plaintext file, %s, is open. \\n&quot;, szSource); } else { HandleError(&quot;Error opening source plaintext file!&quot;); } //-------------------------------------------------------------------- // Open destination file. if (hDestination = fopen(szDestination, &quot;wb&quot;)) { printf(&quot;Destination file %s is open. \\n&quot;, szDestination); } else { HandleError(&quot;Error opening destination ciphertext file!&quot;); } //以下获得一个CSP句柄 if (CryptAcquireContext( &amp;hCryptProv, NULL, //NULL表示使用默认密钥容器，默认密钥容器名 //为用户登陆名 NULL, PROV_RSA_FULL, 0)) { printf(&quot;A cryptographic provider has been acquired. \\n&quot;); } else { if (CryptAcquireContext( &amp;hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))//创建密钥容器 { //创建密钥容器成功，并得到CSP句柄 printf(&quot;A new key container has been created.\\n&quot;); } else { HandleError(&quot;Could not create a new key container.\\n&quot;); } } //-------------------------------------------------------------------- // 创建一个会话密钥（session key） // 会话密钥也叫对称密钥，用于对称加密算法。 // （注: 一个Session是指从调用函数CryptAcquireContext到调用函数 // CryptReleaseContext 期间的阶段。会话密钥只能存在于一个会话过程） //-------------------------------------------------------------------- // Create a hash object. if (CryptCreateHash( hCryptProv, CALG_MD5, 0, 0, &amp;hHash)) { printf(&quot;A hash object has been created. \\n&quot;); } else { HandleError(&quot;Error during CryptCreateHash!\\n&quot;); } //-------------------------------------------------------------------- // 用输入的密码产生一个散列 if (CryptHashData( hHash, (BYTE*)szPassword, strlen(szPassword), 0)) { printf(&quot;The password has been added to the hash. \\n&quot;); } else { HandleError(&quot;Error during CryptHashData. \\n&quot;); } //-------------------------------------------------------------------- // 通过散列生成会话密钥 if (CryptDeriveKey( hCryptProv, ENCRYPT_ALGORITHM, hHash, KEYLENGTH, &amp;hKey)) { printf(&quot;An encryption key is derived from the password hash. \\n&quot;); } else { HandleError(&quot;Error during CryptDeriveKey!\\n&quot;); } //-------------------------------------------------------------------- // Destroy the hash object. CryptDestroyHash(hHash); hHash = NULL; //-------------------------------------------------------------------- // The session key is now ready. //-------------------------------------------------------------------- // 因为加密算法是按ENCRYPT_BLOCK_SIZE 大小的块加密的，所以被加密的 // 数据长度必须是ENCRYPT_BLOCK_SIZE 的整数倍。下面计算一次加密的 // 数据长度。 dwBlockLen = 1000 - 1000 % ENCRYPT_BLOCK_SIZE; //-------------------------------------------------------------------- // Determine the block size. If a block cipher is used, // it must have room for an extra block. if (ENCRYPT_BLOCK_SIZE &gt; 1) dwBufferLen = dwBlockLen + ENCRYPT_BLOCK_SIZE; else dwBufferLen = dwBlockLen; //-------------------------------------------------------------------- // Allocate memory. if (pbBuffer = (BYTE*)malloc(dwBufferLen)) { printf(&quot;Memory has been allocated for the buffer. \\n&quot;); } else { HandleError(&quot;Out of memory. \\n&quot;); } //-------------------------------------------------------------------- // In a do loop, encrypt the source file and write to the source file. do { //-------------------------------------------------------------------- // Read up to dwBlockLen bytes from the source file. dwCount = fread(pbBuffer, 1, dwBlockLen, hSource); if (ferror(hSource)) { HandleError(&quot;Error reading plaintext!\\n&quot;); } //-------------------------------------------------------------------- // 加密数据 if (!CryptEncrypt( hKey, //密钥 0, //如果数据同时进行散列和加密，这里传入一个 //散列对象 feof(hSource), //如果是最后一个被加密的块，输入TRUE.如果不是输 //入FALSE这里通过判断是否到文件尾来决定是否为 //最后一块。 0, //保留 pbBuffer, //输入被加密数据，输出加密后的数据 &amp;dwCount, //输入被加密数据实际长度，输出加密后数据长度 dwBufferLen)) //pbBuffer的大小。 { HandleError(&quot;Error during CryptEncrypt. \\n&quot;); } //-------------------------------------------------------------------- // Write data to the destination file. fwrite(pbBuffer, 1, dwCount, hDestination); if (ferror(hDestination)) { HandleError(&quot;Error writing ciphertext.&quot;); } } while (!feof(hSource)); //-------------------------------------------------------------------- // End the do loop when the last block of the source file has been // read, encrypted, and written to the destination file. //-------------------------------------------------------------------- // Close files. if (hSource) fclose(hSource); if (hDestination) fclose(hDestination); //-------------------------------------------------------------------- // Free memory. if (pbBuffer) free(pbBuffer); //-------------------------------------------------------------------- // Destroy session key. if (hKey) CryptDestroyKey(hKey); //-------------------------------------------------------------------- // Destroy hash object. if (hHash) CryptDestroyHash(hHash); //-------------------------------------------------------------------- // Release provider handle. if (hCryptProv) CryptReleaseContext(hCryptProv, 0); return(TRUE);} // End of Encryptfile//--------------------------------------------------------------------// This example uses the function HandleError, a simple error// handling function, to print an error message to the standard error // (stderr) file and exit the program. // For most applications, replace this function with one // that does more extensive error reporting.void HandleError(const char* s){ fprintf(stderr, &quot;An error occurred in running the program. \\n&quot;); fprintf(stderr, &quot;%s\\n&quot;, s); fprintf(stderr, &quot;Error number %x.\\n&quot;, GetLastError()); fprintf(stderr, &quot;Program terminating. \\n&quot;); exit(1);} // End of HandleError","link":"/2020/09/30/%E5%BE%AE%E8%BD%AF%E7%9A%84CSP%E6%9E%B6%E6%9E%84/"},{"title":"vs编译器相关问题","text":"c++fopen函数unsafehttps://blog.csdn.net/sgfmby1994/article/details/80432205 输入_CRT_SECURE_NO_WARNINGS 打不开源文件12在已安装好的情况下,编译时报E1696等一堆错误时,可采用此方法解决该问题.工具 -&gt; 获取工具和功能 -&gt; 在windows平台开发中的可选项中将windows 10SDK (10.0.177630.0)勾选上安装即可解决. https://blog.csdn.net/weixin_44094541/article/details/103854082?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight vs2019添加外部包项目目录，把openssl的bin、lib、include目录拷贝进来 引入include目录../../include 引入lib目录../../lib 导入lib里面的libcrypto.lib文件名 这部要留意，如果显示“无法解析的外部符号 _BIO_new，函数 “void __cdecl Base64Decode(char const *,unsigned char * *,unsigned int *)” (?Base64Decode@@YAXPBDPAPAEPAI@Z) 中引用了该符号”的错误就是没有导入该文件。 运行结果图：","link":"/2020/09/24/vs%E7%BC%96%E8%AF%91%E5%99%A8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"},{"title":"栈、队列、堆","text":"b站：https://www.bilibili.com/video/BV1GW411Q77S?p=1 知乎：https://zhuanlan.zhihu.com/p/143334754 STL基础栈： 1234567#include&lt;stack&gt;std::stack&lt;int&gt; S;S.top()：取出栈顶S.empty()：判断栈是否为空S.push(x)：将x添加至栈S.pop()·弹出栈顶S.size()栈的存储元累个数 队列： 12345678#include&lt;queue&gt;std::queue&lt;int&gt; Q;Q.empty():判断队列是否为空，return://true if the underlying container's size is 0, false otherwise.Q.front():返回队列头部元素Q.back():返回队列尾部元素Q.pop()：出队列头部元素Q.push(x)：将×添加至队列Q.size()：返回队列的存储元禦的个数 225.用队列实现栈：链接：https://leetcode-cn.com/problems/implement-stack-using-queues 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyStack {public: /** Initialize your data structure here. */ MyStack() { } queue&lt;int&gt; stackWithQ; /** Push element x onto stack. */ void push(int x) { queue&lt;int&gt; temp; temp.push(x); while(!stackWithQ.empty()){ temp.push(stackWithQ.front()); stackWithQ.pop(); } while(!temp.empty()){ stackWithQ.push(temp.front()); temp.pop(); } } /** Removes the element on top of the stack and returns that element. */ int pop() { int temp1; temp1 = stackWithQ.front(); stackWithQ.pop(); return temp1; } /** Get the top element. */ int top() { return stackWithQ.front(); } /** Returns whether the stack is empty. */ bool empty() { return stackWithQ.empty(); }};/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 232.用栈实现队列 https://leetcode-cn.com/problems/implement-queue-using-stacks/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyQueue {public: /** Initialize your data structure here. */ MyQueue() { } stack&lt;int&gt; queueData; stack&lt;int&gt; queueTemp; /** Push element x to the back of queue. */ void push(int x) { //queueTemp.push(x); while(!queueData.empty()){ queueTemp.push(queueData.top()); queueData.pop(); } queueTemp.push(x); while(!queueTemp.empty()){ queueData.push(queueTemp.top()); queueTemp.pop(); } } /** Removes the element from in front of queue and returns that element. */ int pop() { int temp = queueData.top(); queueData.pop(); return temp; } /** Get the front element. */ int peek() { return queueData.top(); } /** Returns whether the queue is empty. */ bool empty() { return queueData.empty(); }};/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */ 215 最小栈123456789101112131415161718192021222324252627282930313233class MinStack {public: /** initialize your data structure here. */ MinStack() { } std::stack&lt;int&gt; dataStack; std::stack&lt;int&gt; _minStack; void push(int x) { dataStack.push(x); if(_minStack.empty()){ _minStack.push(x);//这里写成dataStack.push(x)了 }else{ if(x &gt; _minStack.top()){ x = _minStack.top(); } _minStack.push(x); } } void pop() { dataStack.pop(); _minStack.pop(); } int top() { return dataStack.top(); } int getMin() { return _minStack.top(); }}; 222.基本计算器（栈）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//并不能提交成功#include&lt;stack&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Solution {public: stack&lt;int&gt; numStack; stack&lt;int&gt; operatorStack; void compute(){ if(numStack.size() &lt; 2){ return; }else{ int temp2 = numStack.top(); numStack.pop(); int temp1 = numStack.top(); numStack.pop(); if(operatorStack.top() == '+'){ numStack.push(temp1 + temp2); }else if(operatorStack.top() == '-'){ numStack.push(temp1 - temp2); } operatorStack.pop(); } } int calculate(string s) { static const int BEGIN_STATE = 0; static const int NUM_STATE = 1; static const int OPERATOR_STATE = 2; int state = BEGIN_STATE; int num = 0; int computeFlag = 0; for(int i = 0; i &lt; s.length(); i++){ if(s[i] == ' ') continue; switch(state){ case BEGIN_STATE: if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9'){ state = NUM_STATE; }else{ state = OPERATOR_STATE; } i--; break; case NUM_STATE: if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9'){ num = num*10 +(s[i] - '0'); }else{ numStack.push(num); num = 0; if(computeFlag == 1){ compute(); } state = OPERATOR_STATE; i--; } break; case OPERATOR_STATE: if(s[i] == '('){ computeFlag = 0; state = NUM_STATE; }else if(s[i] == ')'){ if(computeFlag == 1){ compute(); } }else if(s[i] == '+' || s[i] == '-'){ operatorStack.push(s[i]); computeFlag = 1; }else{ state = NUM_STATE; i--; } break; } } if(num != 0){ numStack.push(num); num = 0; compute(); } if(numStack.empty()){ return 0; } return numStack.top(); }};int main(){ string s = &quot;-2+1&quot;; Solution solu; cout&lt;&lt;solu.calculate(s);} STL-堆，优先级队列priority_queue声明： priority_queue&lt;Type, Container, Functional&gt; 默认最大堆：priority_queue p; 最小堆的声明：priority_queue&lt;int, vector, greater &gt; p; 123456789和队列基本操作相同:top 访问队头元素empty 队列是否为空size 返回队列内元素个数push 插入元素到队尾 (并排序)emplace 原地构造一个元素并插入队列pop 弹出队头元素swap 交换内容 215.数组中的第k大个元素-堆1234567891011121314151617class Solution {public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; Q; for(int i = 0; i &lt; nums.size(); i++){ if(Q.size() &lt; k){ Q.push(nums[i]); }else{ if(nums[i] &gt; Q.top()){ Q.pop(); Q.push(nums[i]); } } } return Q.top(); }}; 295.数据流中的中位数-堆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MedianFinder {public: /** initialize your data structure here. */ MedianFinder() { } void addNum(int num) { if(big_queue.empty()){ big_queue.push(num); }else if(big_queue.size() == small_queue.size()){ if(num &lt; big_queue.top()){ big_queue.push(num); }else{ small_queue.push(num); } }else if(big_queue.size() &gt; small_queue.size()){ if(num &gt; big_queue.top()){ small_queue.push(num); }else{ small_queue.push(big_queue.top()); big_queue.pop(); big_queue.push(num); } }else{ if(num &lt; small_queue.top()){ big_queue.push(num); }else{ big_queue.push(small_queue.top()); small_queue.pop(); small_queue.push(num); } } } double findMedian() { if(small_queue.size() == big_queue.size()){ return ((double)small_queue.top() + (double)big_queue.top())/2; }else if(small_queue.size() &lt; big_queue.size()){ return big_queue.top(); }else{ return small_queue.top(); } }private: priority_queue&lt;int&gt; big_queue; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; small_queue;};","link":"/2021/01/10/%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E5%A0%86/"},{"title":"排序","text":"排序类总结 颜色分类 (medium 快排) 排序链表 (medium 归并 堆排序) 数组中的第K个最大元素 (medium 快速排序 堆) 前K个高频元素 (medium 桶排序 堆) 最大间距 (hard 桶排序) 排序总结颜色分类LeetCode中文 LeetCode英文 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 解答方法1：计数排序哈希表统计每个颜色代表的数字出现的次数，然后更新原数组，按照0,1,2各自的个数按照顺序赋值。 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if(len == 0) return; vector&lt;int&gt; hash(3,0); for(int i=0;i&lt;len;i++) { hash[nums[i]]++; } int j = 0; for(int i=0;i&lt;3;i++) { while(hash[i] &gt; 0) { nums[j++] = i; hash[i]--; } } }};class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int length = nums.size(); if(length == 0) return; vector&lt;int&gt; hash(3,0); for(int i = 0; i &lt; length; i++){ hash[nums[i]]++; } int j = 0; for(int i = 0; i &lt; 3; i++){ while(hash[i] &gt; 0){ nums[j] = i; j++; hash[i]--; } } return; }}; 方法2：荷兰国旗问题定义两个指针，指针r指向数组开头前一个位置(代表红色)，指针b指向数组末尾后一个位置(代表蓝色)，然后从前向后遍历数组，对于遍历的每一个元素nums[w](w起始位置为0)，处理情况如下： 如果nums[w] == 0，则r后移一个位置，然后交换nums[r]和nums[w]的值，w后移一个位置； 如果nums[w] == 2，则b前移一个位置，然后交换nums[b]和nums[w]的值，w位置不变； 如果nums[w] == 1，则w后移一个位置。 直到w == b时，结束遍历。 时间复杂度：O(n) 空间复杂度：O(1) 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int r = -1,w = 0,b = nums.size(); while(w &lt; b) { if(nums[w] == 0) { swap(nums[++r],nums[w++]); } else if(nums[w] == 2) { swap(nums[--b],nums[w]); } else { ++w; } } }}; int front = -1, rear = nums.size(); for(int i = 0; i &lt; rear;){//i&lt;=rear不行 if(nums[i] == 0){ front++; int temp = nums[front]; nums[front] = nums[i]; nums[i] = temp; i++; }else if(nums[i] == 1){ i++; }else{ rear--; int temp = nums[rear]; nums[rear] = nums[i]; nums[i] = temp; } } 排序链表LeetCode中文 LeetCode英文 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解答方法1归并排序 + 链表 时间复杂度：O(n log n) 空间复杂度：O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* sortList(ListNode* head) { if(!head || !head-&gt;next) return head; ListNode *slow = head,*fast = head; while(fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } ListNode *p1 = head,*p2 = slow-&gt;next; slow-&gt;next = nullptr; p1 = sortList(p1); p2 = sortList(p2); ListNode node(0),*head1 = &amp;node; while(p1 &amp;&amp; p2) { if(p1-&gt;val &lt; p2-&gt;val) { head1-&gt;next = p1; head1 = p1; p1 = p1-&gt;next; } else{ head1-&gt;next = p2; head1 = p2; p2 = p2-&gt;next; } } if(p1) head1-&gt;next = p1; if(p2) head1-&gt;next = p2; return node.next; }}; 方法2堆排序（优先级队列） + 链表 时间复杂度：O(n log n) 空间复杂度：O(n) 使用优先级队列priority_queue（底层用堆实现） 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */inline bool comp(const ListNode* p1,const ListNode* p2){ return p1-&gt;val &gt; p2-&gt;val;}class Solution {public: ListNode* sortList(ListNode* head) { priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,decltype(comp)*&gt; que(comp); ListNode* p = head; while(p) { que.push(p); p = p-&gt;next; } ListNode node(0),*head1 = &amp;node; while(!que.empty()) { auto tmp = que.top(); que.pop(); head1-&gt;next = tmp; head1 = head1-&gt;next; } head1-&gt;next = nullptr; return node.next; }}; 直接用STL中heap的接口：make_heap, push_heap ,pop_heap。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */inline bool comp(const ListNode* p1,const ListNode* p2){ return p1-&gt;val &gt; p2-&gt;val;}class Solution {public: ListNode* sortList(ListNode* head) { vector&lt;ListNode*&gt; vec; ListNode* p = head; while(p) { vec.push_back(p); p = p-&gt;next; } make_heap(vec.begin(),vec.end(),comp); ListNode node(0),*head1 = &amp;node; while(!vec.empty()) { auto tmp = vec.front(); pop_heap(vec.begin(),vec.end(),comp); vec.pop_back(); head1-&gt;next = tmp; head1 = head1-&gt;next; } head1-&gt;next = nullptr; return node.next; }}; 数组中的第K个最大元素LeetCode中文 LeetCode英文 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解答方法1:堆维护一个最小堆min，将nums前k个元素nums[i](0 &lt;= i &lt; k )放入min中，然后遍历第k个元素之后的元素nums[i](k &lt;= i &lt;= len)，比较nums[i]和堆顶元素tmp： 如果nums[i] &gt; tmp，则从堆中弹出堆顶元素tmp，同时将num[i]放入堆中； 否则，跳过 最终，遍历完nums所有元素之后，堆顶元素即为数组nums的第k个最大元素。 时间复杂度：O(n log k) 空间复杂度：O(k) 1234567891011121314151617181920212223242526class Solution {public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); if(k &lt;= 0 || len == 0 || len &lt; k) return 0; vector&lt;int&gt; min(nums.begin(),nums.begin()+k); make_heap(min.begin(),min.end(),greater&lt;int&gt;()); for(int i=k;i&lt;len;i++) { int tmp = min.front(); if(nums[i] &gt; tmp) { pop_heap(min.begin(),min.end(),greater&lt;int&gt;()); min.pop_back(); min.push_back(nums[i]); push_heap(min.begin(),min.end(),greater&lt;int&gt;()); } } return min[0]; }}; 方法2：红黑树利用红黑树自动排序的功能，思路和堆的解法类似，利用STL的multiset结构(底层红黑树实现),排序方式定义为less&lt;int&gt;(从小到大)，最终遍历完nums元素之后，红黑树的第一个元素即为数组第k个最大元素。 时间复杂度：O(n log k) 空间复杂度：O(k) 1234567891011121314151617181920212223class Solution {public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); if(k &lt;= 0 || len == 0 || len &lt; k) return 0; //红黑树实现 multiset&lt;int,less&lt;int&gt;&gt; st(nums.begin(),nums.begin()+k,less&lt;int&gt;()); for(auto it = nums.begin() + k;it != nums.end();it++) { auto iter = st.begin(); if(*iter &lt; *it) { st.erase(iter); st.insert(*it); } } return *(st.begin()); }}; 方法3：快排利用快速排序中的partition功能,partition根据所选的主元pivot，将数组分为三段：左半段 &lt; pivot,中间段 = pivot,右半段 &gt; pivot，设= pivot段的左边缘为l，右边缘为r，维护两个指针start和end确定第k大元素所在区间，同时初始化start = 0，end = len-1，然后partition每处理一次，就比较k-1和l大小以及k-1和r大小，处理情况如下： 如果l &gt; k-1，则第k个最大元素位于&lt; pivot段，令end = l； 如果r &lt; k-1，则第k个最大元素位于&gt; pivot段，令start = r； 如果l &lt;= k-1 &lt;= r，则找到了第k个最大元素，返回nums[k-1]。 假设每次partition处理后，左半段和右半段都被分为对等的两段，此时时间复杂度最优为O(n)，而最坏时间复杂度为O(n2) 时间复杂度：O(n)~O(n2) 空间复杂度：O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution {public: pair&lt;int,int&gt; partition(vector&lt;int&gt;&amp; vec,int l,int r) { int m = l + (r -l)/2; if(vec[l] &gt; vec[r]) swap(vec[l],vec[r]); if(vec[l] &gt; vec[m]) swap(vec[l],vec[m]); if(vec[m] &gt; vec[r]) swap(vec[m],vec[r]); swap(vec[l],vec[m]); int pivot = vec[l]; int len = vec.size(); int more = l; int cur = l+1; int less = r+1; while(cur &lt; less) { if(vec[cur] &gt; pivot) { swap(vec[++more],vec[cur++]); } else if(vec[cur] &lt; pivot) { swap(vec[--less],vec[cur]); } else cur++; } swap(vec[l],vec[more]); more--; return make_pair(more+1,less-1); } int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { //快排partition实现 int len=nums.size(); if(k &lt;= 0 || len == 0 || len &lt; k) return 0; pair&lt;int,int&gt; pr = partition(nums,0,len-1); int start = 0; int end = len - 1; while(k-1 &lt; pr.first || k-1 &gt; pr.second) { if(k-1 &lt; pr.first) { end = pr.first - 1; pr = partition(nums,start,end); } else if(k-1 &gt; pr.second) { start = pr.second + 1; pr = partition(nums,start,end); } } return nums[k-1]; }}; 前K个高频元素LeetCode中文 LeetCode英文 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 12输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 解答方法1：哈希表 + 堆/红黑树首先利用哈希表统计数组每个元素出现的次数，然后问题转化为 数组中的第K个最大元素 的 方法1 和 方法2。 时间复杂度：O(n log k) 空间复杂度：O(k) 方法2：哈希表 + 快排首先利用哈希表统计数组每个元素出现的次数，然后问题转化为 数组中的第K个最大元素 的 方法3。 时间复杂度：O(n)~O(n2) 空间复杂度：O(1) 方法3：桶排序利用桶排序中的计数排序。首先用哈希表统计每个元素的频率，然后创建桶数组bucket，bucket长度为nums.size() + 1，数组下标表示元素的频率，每个桶也是一个数组，内含出现频率等于相应下标i的元素。例如bucket[i]表示出现频率为i的桶，内含所有出现i次的元素。最后，按频率从高到低输出k个数字到结果中。 时间复杂度：O(n) 空间复杂度：O(n) 12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int,int&gt; mp; for(auto a : nums) mp[a]++; vector&lt;int&gt; res; int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; buckets(len+1,vector&lt;int&gt;()); for(auto a : mp) { buckets[a.second].push_back(a.first); } for(int i=len;i&gt;=0;i--) { for(auto b : buckets[i]) { res.push_back(b); k--; if(k == 0) return res; } } return vector&lt;int&gt;(); }}; 最大间距LeetCode中文 LeetCode英文 给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。 如果数组元素个数小于 2，则返回 0。 示例 1: 123输入: [3,6,9,1]输出: 3解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。 示例 2: 123输入: [10]输出: 0解释: 数组元素个数小于 2，因此返回 0。 说明: 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。 解答利用基数排序。首先取桶的个数为nums.size()+1，然后遍历一遍数组找出元素最大值Max和最小值Min，将Min放入第一个桶，Max放入最后一个桶，整个大范围 Max~Min 被平分成多个局部范围，每个桶对应一个局部范围，数组的每个元素都一定位于某一个桶当中，而且由于桶的个数比数组长度大1，那么就一定存在一个空桶，由于第一个桶和最后一个桶都装有元素，所以在这个空桶前面和后面一定都能找到一个最近的非空桶，又因为每个桶的范围大小一样，那么数组排序后最大间距的相邻元素一定不位于同一个桶中，而是一个非空桶的局部最小值和它前一个非空桶的局部最大值之间的差值。因此，找到每个非空桶的局部最小值和局部最大值，找出相邻非空桶局部最小值和局部最大值的最大差值即可。 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution {public: unsigned int getpos(int max,int min,int len,int num) { double a = num - min; double b = max - min; return (unsigned int)(a * len / b); } int maximumGap(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if(len &lt;= 1) return 0; vector&lt;bool&gt; flag(len + 1,false); vector&lt;int&gt; maxs(len + 1,INT_MIN); vector&lt;int&gt; mins(len + 1,INT_MAX); int Max = INT_MIN; int Min = INT_MAX; for(int i=0;i&lt;len;i++) { Min = min(nums[i],Min); Max = max(nums[i],Max); } if(Min == Max) return 0; flag[0] = true; flag[len] = true; for(int i=0;i&lt;len;i++) { unsigned int pos = getpos(Max,Min,len,nums[i]); mins[pos] = min(mins[pos],nums[i]); maxs[pos] = max(maxs[pos],nums[i]); flag[pos] = true; } int res = INT_MIN; bool flag1 = false; int lastMax = maxs[0]; for(int i=1;i&lt;=len;i++) { if(flag[i]) { res = max(res,mins[i] - lastMax); lastMax = maxs[i]; } } return res; }};","link":"/2020/12/31/%E6%8E%92%E5%BA%8F/"},{"title":"github clone速度慢解决办法","text":"https://www.bilibili.com/read/cv7089114/ 看了半天让人眼花缭乱，后来在网上发现了一种最简单有效的方法：就是修改一下url链接，在github.com后面加上.cnpmjs.org即可 比如原始命令是：git clone https://github.com/ultranity/Pix-EzViewer.git，修改后命令为： git clone https://github.com.cnpmjs.org/ultranity/Pix-EzViewer.git https://www.runoob.com/w3cnote/git-guide.html","link":"/2021/02/18/github-clone%E9%80%9F%E5%BA%A6%E6%85%A2%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"ftp配置和使用","text":"1 用flashfxp连接ftp服务器与传输文件破解版下载地址： 链接：https://pan.baidu.com/s/1zY8vnCJvPBFycvZwV1L-pA提取码：kvhn 关于首次打开显示试用界面，点击输入代码按钮即可永久使用 解压缩后打开flashfxp.exe如下图所示： 左边是本地文件夹，右边是服务器文件夹，点击箭头那里输入相应信息进行连接。 然后就可以进入服务器的文件夹。就可以传输文件了。 2 服务器收作业时文件夹权限分配 在根文件夹普通权限只给用户列出文件的权限 每个作业的文件夹给以下三个权限 这样该用户就只能上传文件而不能执行其他操作，保证作业不会被抄袭。 filezilla错误：无法找到服务器https://www.cnblogs.com/mytt/p/6684199.html","link":"/2020/05/01/ftp%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"title":"腾讯云centos服务器配置vnc可视化界面","text":"https://www.bilibili.com/video/BV1zp4y1v7VB?t=679 配完后会出现蓝屏 https://cloud.tencent.com/developer/article/1722179 用户一定不要写root，root用户打不开浏览器","link":"/2021/02/25/%E8%85%BE%E8%AE%AF%E4%BA%91centos%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEvnc%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2/"},{"title":"vscode远程连接","text":"清除.ssh下面的host文件如果连接失败 下载Remote Developmenthttps://blog.csdn.net/irober/article/details/112724986?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242 显示连接中服务器 rm -rf .vscode-server https://blog.csdn.net/weixin_40313940/article/details/107410778","link":"/2021/02/20/vscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"},{"title":"基于区块链的投票系统","text":"知识背景truffle快速开始： https://learnblockchain.cn/docs/truffle/quickstart.html web3js https://learnblockchain.cn/docs/web3.js/web3-eth-contract.html#methods-mymethod-send solidity https://learnblockchain.cn/docs/solidity/ 基于truffle框架的投票DAPP安装trufflesudo npm install -g truffle 安装过程中可能会报错，如果报错则执行如下命令升级nodejs: 12sudo npm install -g nsudo n stable truffle安装完成后用如下命令检查： 1truffle -v 创建项目工程1truffle unbox webpack 配置truffle_config.js文件 1234567networks下： development: { host: &quot;127.0.0.1&quot;, // Localhost (default: none) port: 8545, // Standard Ethereum port (default: none) network_id: &quot;*&quot;, // Any network (default: none) gas: 470000 }, 将 2_deploy_contracts.js 的内容更新为以下信息12345const Voting = artifacts.require(&quot;./Voting.sol&quot;);module.exports = function(deployer) { deployer.deploy(Voting, [web3.utils.toHex('Alice'),web3.utils.toHex('Trump')]); //转十六进制}; 启动测试链ganachehttps://www.trufflesuite.com/docs/ganache/workspaces/ethereum-workspace-overview https://blog.csdn.net/qq_20513027/article/details/850413531）输入 sudo npm install -g ganache-cli2）启动 ganache-cli 编译部署12truffle compiletruffle migrate 控制台交互Voting.deployed().then(function(contractInstance){contractInstance.voteForCandidate(web3.utils.toHex(‘Bob’)).then(function(v) {console.log(v)})}) Voting.deployed().then(function(contractInstance) {contractInstance.totalVotesFor.call(web3.utils.toHex(‘Alice’)).then(function(v) {console.log(v.toString())})}) 网页交互https://www.jianshu.com/p/f8d41a5d909d https://myblog.gumptlu.work/2020/08/23/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/truffle%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AD%A6%E4%B9%A0/ https://github.com/truffle-box/webpack-box npm run dev报错很有可能启动需要的依赖包没有安装，安装的方式是在项目文件夹下： npm install geth命令eth.getBalance(eth.accounts[1]) 导入账户 personal.importRawKey(“3b2e3e081c5450a25e4a859b5a5db70f6e0291cb87b2596b4739485132825883”,”jkslks5965”) 解锁：* personal.unlockAccount(eth.accounts[0],”123456”, 600000) eth.sendTransaction({from: eth.accounts[1],gasPrice: “20000000000”,gas: “21000”,to: eth.accounts[0],value: “1000000000000000000”,data: “”}, ‘jkslks5965’) eth.sendTransaction({from: “0x1544b84b06ace59dcac798f2eca6b9577bafd612”,to: “0x52e04f1b40891060beb72ea09d2b873bdb7ea7cb”,value: ‘1000000000000000000’}) eth.sendTransaction({from: eth.accounts[0],to: eth.accounts[2],amount}) 设置以太 amount = web3.toWei(2,’ether’) eth.sendTransaction({from: eth.accounts[0], to: eth.accounts[1], value: amount}) eth.sendTransaction({from: eth.accounts[0], to: eth.accounts[1], value: web3.toWei(10,’ether’)}) 交易完成后，要挖矿才可以交易成功 解锁账户 web3.eth.personal.unlockAccount(‘0x1544b84B06ace59DcAc798f2Eca6B9577BAfD612’,’123456’,300000) 使用fabric-samples测试网络环境配置 由于网络问题，自行下载三个包 https://pan.baidu.com/s/1-zq-MJlIb0Etn_8O0nT10w#list/path=%2F 提取码：zn0v https://zhuanlan.zhihu.com/p/158381955 遇到错误 ERROR! Peer binary and configuration files not found.. https://www.codenong.com/cs106355725/ 官方地址 https://hyperledger-fabric.readthedocs.io/zh_CN/release-2.2/install.html 使用Fabric的测试网络官方地址： https://hyperledger-fabric.readthedocs.io/zh_CN/release-2.2/test_network.html# 相关博客： https://my.oschina.net/zfjian/blog/4943514 https://blog.csdn.net/ngums/article/details/109170721 将智能合约部署到渠道https://hyperledger-fabric.readthedocs.io/zh_CN/release-2.2/deploy_chaincode.html#install-the-chaincode-package go mod有错误，改成go mod download，再go mod vendor org1和org2的环境变量需分开配置 安装nodehttps://cloud.tencent.com/document/product/213/38237 方法二：使用代理registry 在网上查阅了一些资料后，决定使用代理的方式，方法也很简单，就是 1npm config set registry https://registry.npm.taobao.org 编译在项目目录中创建如下目录 mkdir contractsmkdir scriptsmkdir compiledmkdir tests 安装依赖 npm install solc @0.4.25 npm list fs-extra //查看版本信息 合约 12345678910111213141516171819202122pragma solidity ^0.4.22; contract Voting { mapping (bytes32 =&gt; uint8) public votesReceived; bytes32[] public candidateList; constructor(bytes32[] candidateNames) public { candidateList = candidateNames; } function totalVotesFor(bytes32 candidate) view public returns (uint8) { require(validCandidate(candidate)); return votesReceived[candidate]; } function voteForCandidate(bytes32 candidate) public { require(validCandidate(candidate)); votesReceived[candidate] += 1; } function validCandidate(bytes32 candidate) view public returns (bool) { for(uint i = 0; i &lt; candidateList.length; i++) { if (candidateList[i] == candidate) { return true; } } return false; } } 编译脚本 123456789101112131415161718192021222324252627const fs = require('fs-extra'); const path = require('path'); const solc = require('solc'); // cleanup const compiledDir = path.resolve(__dirname, '../compiled'); fs.removeSync(compiledDir); fs.ensureDirSync(compiledDir); // compile const contractPath = path.resolve(__dirname, '../contracts', 'Voting.sol'); const contractSource = fs.readFileSync(contractPath, 'utf8'); const result = solc.compile(contractSource, 1); // check errors if (Array.isArray(result.errors) &amp;&amp; result.errors.length) { throw new Error(result.errors[0]); } // save to disk Object.keys(result.contracts).forEach(name =&gt; { const contractName = name.replace(/^:/, ''); const filePath = path.resolve(compiledDir, `${contractName}.json`); fs.outputJsonSync(filePath, result.contracts[name]); console.log(`save compiled contract ${contractName} to ${filePath}`); }); 编译命令 node ./scripts/compile.js 用truffle构建简单dapp连接到私链的控制台GethVersion: 1.8.0-stable 搭建私链文件genesis.json{&quot;config&quot;: { &quot;chainId&quot;: 15 }, &quot;difficulty&quot;: &quot;1800&quot;, &quot;gasLimit&quot;: &quot;2100000&quot;, &quot;alloc&quot;: { &quot;0x52e04F1b40891060bEB72ea09d2B873bdb7ea7CB&quot;: { &quot;balance&quot;: &quot;30000000000000000000000&quot; } }} geth attach http://127.0.0.1:8545 查看日志 tail -f output.log 查看geth ps -ef | grep geth 初始化私链 geth –datadir . init genesis.json 启动私链 nohup geth –datadir . –networkid 15 –rpc –rpcapi db,eth,net,web3,personal,miner –rpcport 8545 –rpcaddr 127.0.0.1 –rpccorsdomain “*” 2&gt;output.log &amp; nohup geth –datadir . –networkid 16 –rpc –rpcapi db,eth,net,web3,personal,miner –rpcport 8545 –rpcaddr 127.0.0.1 –rpccorsdomain “*” 2&gt;output.log &amp; nohup geth –datadir . –dev.period=1 –networkid 15 –rpc –rpcapi db,eth,net,web3,personal,miner –rpcport 8545 –rpcaddr 127.0.0.1 –allow-insecure-unlock –rpccorsdomain “*” 2&gt;output.log &amp; nohup geth –datadir . –dev.period=1 –networkid 16 –rpc –rpcapi db,eth,net,web3,personal,miner –rpcport 8545 –rpcaddr 127.0.0.1 –allow-insecure-unlock –rpccorsdomain “*” 2&gt;output.log &amp; // –dev.period 1允许挖矿 https://www.cnblogs.com/lvdongjie/p/11205885.html //–allow-insecure-unlock允许解锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Voting DApp&lt;/title&gt; &lt;!-- &lt;link href='https://fonts.googleapis.com/css?family=Open Sans:400,700' rel='stylesheet' type='text/css'&gt; --&gt; &lt;link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css' rel='stylesheet' type='text/css'&gt; &lt;/head&gt; &lt;body class=&quot;container&quot;&gt; &lt;h1&gt;A Simple Voting Application&lt;/h1&gt; &lt;div id=&quot;address&quot;&gt;&lt;/div&gt; &lt;div class=&quot;table-responsive&quot;&gt; &lt;table class=&quot;table table-bordered&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Candidate&lt;/th&gt; &lt;th&gt;Votes&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Alice&lt;/td&gt; &lt;td id=&quot;candidate-1&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;/td&gt; &lt;td id=&quot;candidate-2&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Cary&lt;/td&gt; &lt;td id=&quot;candidate-3&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div id=&quot;msg&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;candidate&quot; /&gt; &lt;a href=&quot;#&quot; onclick=&quot;App.voteForCandidate()&quot; class=&quot;btn btn-primary&quot;&gt;Vote&lt;/a&gt; &lt;/body&gt; &lt;!-- &lt;script src=&quot;https://cdn.rawgit.com/ethereum/web3.js/develop/dist/web3.js&quot;&gt;&lt;/script&gt; --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/ethereum/web3.js/dist/web3.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.slim.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import Web3 from &quot;web3&quot;;import Voting from &quot;../../build/contracts/Voting.json&quot;;let candidates = {&quot;Alice&quot;: &quot;candidate-1&quot;, &quot;Bob&quot;: &quot;candidate-2&quot;, &quot;Cary&quot;: &quot;candidate-3&quot;}const App = { web3: null, account: null, vote: null, start: async function() { const { web3 } = this; try { // get contract instance const networkId = await web3.eth.net.getId(); const deployedNetwork = Voting.networks[networkId]; //console.log(Voting.networks[networkId]); this.vote = new web3.eth.Contract( Voting.abi, deployedNetwork.address, ); // console.log(Voting.abi); // console.log(deployedNetwork.address); // console.log(this.vote); this.refreshVotes(); // get accounts const accounts = await web3.eth.getAccounts(); this.account = accounts[0]; //this.refreshBalance(); } catch (error) { console.error(&quot;Could not connect to contract or chain.&quot;); } }, refreshVotes: async function() { const { web3 } = this; try{ let candidateNames = Object.keys(candidates); for (var i = 0; i &lt; candidateNames.length; i++) { let name = candidateNames[i]; const { totalVotesFor } = this.vote.methods; //console.log(name); const value = await totalVotesFor(web3.utils.toHex(name)).call(); //console.log(value); $(&quot;#&quot; + candidates[name]).html(value.toString()); } }catch(e){ console.error(e); } }, voteForCandidate: async function() { const { web3 } = this; try{ $(&quot;#msg&quot;).val(&quot;vote submited&quot;); let canName = $(&quot;#candidate&quot;).val(); $(&quot;#candidate&quot;).val(''); console.log(canName); const { voteForCandidate } = this.vote.methods; console.log(this.vote.methods); console.log(voteForCandidate); await voteForCandidate(web3.utils.toHex(canName)).send({ from: this.account }); this.refreshVotes(); }catch(err){ console.error(err); } },};window.App = App;window.addEventListener(&quot;load&quot;, function() { if (null) { $(&quot;#msg&quot;).html('helo'); // use MetaMask's provider App.web3 = new Web3(window.ethereum); window.ethereum.enable(); // get permission to access accounts } else { // fallback - use your fallback strategy (local node / hosted node + in-dapp id mgmt / fail) App.web3 = new Web3( new Web3.providers.HttpProvider(&quot;http://127.0.0.1:8545&quot;), ); } App.start();}); 12345development: { host: &quot;127.0.0.1&quot;, // Localhost (default: none) port: 8545, // Standard Ethereum port (default: none) network_id: &quot;*&quot;, // Any network (default: none)}, 12345const Voting = artifacts.require(&quot;./Voting.sol&quot;);module.exports = function(deployer) { deployer.deploy(Voting, [web3.utils.toHex('Alice'),web3.utils.toHex('Bob'),web3.utils.toHex('Cary')]); }; (0) 0x1084DF50306Ce706e10eb950C571F833Bc8480b6 (100 ETH)(1) 0xc43eF32Db84cF8EcE3c3ec59610C8c5767219d87 (100 ETH)(2) 0x7fcC051B830F1C781986E8B8225240dF86C9d4AA (100 ETH)(3) 0x892E3b2fc8e0Afa618f9931142f88fA5fff5b4b9 (100 ETH)(4) 0xd8b9375a2640fea9a3262AA21e095dAb6a1ad1eb (100 ETH)(5) 0xd4eAc56BAd7C1f5a01026B98a5fB2393211D2Fe0 (100 ETH)(6) 0x4C3e9e2b9Bca092d7569C005Bd542dB8e281bD44 (100 ETH)(7) 0x94A4dC26Ed361D9b65d81A782b378770Ae825737 (100 ETH)(8) 0xB742F4391435E5B97075cBe073B1B8D51C641298 (100 ETH)(9) 0xA5D19e3eab28a5bD402fc8DBFC6F813afebbab0D (100 ETH) 遇到的错误‘webpack-dev-server’ 不是内部或外部命令，也不是可运行的程序命令：npm install webpack-dev-server –save https://blog.csdn.net/hzxOnlineOk/article/details/78284101 solc的版本问题Error: Truffle is currently using solc 0.5.16, but one or more of your contracts specify “pragma solidity ^0.4.18”.Please update your truffle config or pragma statement(s).(See https://trufflesuite.com/docs/truffle/reference/configuration#compiler-configuration for information onconfiguring Truffle to use a specific solc compiler version.) 把truffle-config 改成 compilers: { solc: { version: “0.4.22”, // Fetch exact version from solc-bin (default: truffle’s version) // docker: true, // Use “0.5.1” you’ve installed locally with docker (default: false) // settings: { // See the solidity docs for advice about optimization and evmVersion // optimizer: { // enabled: false, // runs: 200 // }, // evmVersion: “byzantium” // } } npm错误npm install gaslimithttps://blog.csdn.net/wo541075754/article/details/79042558 gas limit区块gas limit是单个区块允许的最多gas总量，以此可以用来决定单个区块中能打包多少笔交易。 例如，我们有5笔交易的gas limit分别是10、20、30、40和50.如果区块gas limit是100，那么前4笔交易就能被成功打包进入这个区块。矿工有权决定将哪些交易打包入区块。所以，另一个矿工可以选择打包最后两笔交易进入这个区块（50+40），然后再将第一笔交易打包（10）。如果你尝试将一个会使用超过当前区块gas limit的交易打包，这个交易会被网络拒绝，你的以太坊客户端会反馈错误”交易超过区块gas limit”。 目前使用的gas limit为21000。 区块的gas limit是由在网络上的矿工决定的。与可调整的区块gas limit协议不同的是一个默认的挖矿策略，即大多数客户端默认最小区块gas limit为4,712,388。 ChainId与NetworkIdChainId 是用来防止交易在不同的以太坊同构网络进行交易重放的。主要在交易签名和验证的时候使用。 NetworkId 是用来标识区块链网络的。主要在节点之间握手并相互检验的时候使用。 ChainId 需要在 genesis 文件中指定，NetworkId 需要在启动参数中指定。 ChainId 和 NetworkId 的值不需要相同。 链接：https://www.jianshu.com/p/b8730a05eb36 htmlhttps://www.runoob.com/highcharts/highcharts-column-basic.html 在线投票系统phphttps://blog.csdn.net/tianyao9hen/article/details/50495693","link":"/2021/01/20/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%8A%95%E7%A5%A8%E7%B3%BB%E7%BB%9F-md/"},{"title":"链表","text":"206.反转链表 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { ListNode* newHead = NULL; while(head){ ListNode* temp = head-&gt;next; head-&gt;next = newHead; newHead = head; head = temp; } return newHead; }}; 95.reverse list 2123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseBetween(ListNode* head, int m, int n) { int change_length = n - m + 1; //逆转段的长度 ListNode* pre_head = NULL;//逆转段的前驱 ListNode* result = head; //链表头节点，m &gt; 1时，m &lt; 1时，result = new_head while(--m){//head point to m position, pre_head point to the prior of head pre_head = head; head = head-&gt;next; } ListNode* list_tail = head;// the tail of the reverse section after reverse //begin to reverse the reverse section ListNode* new_head = NULL; while(change_length--){ ListNode* temp = head-&gt;next; head-&gt;next = new_head; new_head = head; head = temp; } list_tail-&gt;next = head;//connect the reverse section and the back of the reverse section if(pre_head){//if m = 1,connect the list pre_head-&gt;next = new_head; }else{//if m &gt; 1 result = new_head; } return result; }};","link":"/2021/01/18/%E9%93%BE%E8%A1%A8/"},{"title":"第七章 类","text":"第7章 类类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程及设计技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及其他私有函数。 定义抽象数据类型（Defining Abstract Data Types）设计Sales_data类（Designing the Sales_data Class）类的用户是程序员，而非应用程序的最终使用者。 定义改进的Sales_data类（Defining the Revised Sales_data Class）成员函数（member function）的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的内联函数。 123456789101112struct Sales_data{ // new members: operations on Sales_data objects std::string isbn() const { return bookNo; } Sales_data&amp; combine(const Sales_data&amp;); double avg_price() const; // data members std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;}; 成员函数通过一个名为this的隐式额外参数来访问调用它的对象。this参数是一个常量指针，被初始化为调用该函数的对象地址。在函数体内可以显式使用this指针。 123456total.isbn()// pseudo-code illustration of how a call to a member function is translatedSales_data::isbn(&amp;total)std::string isbn() const { return this-&gt;bookNo; }std::string isbn() const { return bookNo; } 默认情况下，this的类型是指向类类型非常量版本的常量指针。this也遵循初始化规则，所以默认不能把this绑定到一个常量对象上，即不能在常量对象上调用普通的成员函数。 C++允许在成员函数的参数列表后面添加关键字const，表示this是一个指向常量的指针。使用关键字const的成员函数被称作常量成员函数（const member function）。 1234567// pseudo-code illustration of how the implicit this pointer is used// this code is illegal: we may not explicitly define the this pointer ourselves// note that this is a pointer to const because isbn is a const memberstd::string Sales_data::isbn(const Sales_data *const this){ return this-&gt;isbn;} 常量对象和指向常量对象的引用或指针都只能调用常量成员函数。 类本身就是一个作用域，成员函数的定义嵌套在类的作用域之内。编译器处理类时，会先编译成员声明，再编译成员函数体（如果有的话），因此成员函数可以随意使用类的其他成员而无须在意这些成员的出现顺序。 在类的外部定义成员函数时，成员函数的定义必须与它的声明相匹配。如果成员函数被声明为常量成员函数，那么它的定义也必须在参数列表后面指定const属性。同时，类外部定义的成员名字必须包含它所属的类名。 1234567double Sales_data::avg_price() const { if (units_sold) return revenue / units_sold; else return 0;} 可以定义返回this对象的成员函数。 123456Sales_data&amp; Sales_data::combine(const Sales_data &amp;rhs){ units_sold += rhs.units_sold; // add the members of rhs into revenue += rhs.revenue; // the members of 'this' object return *this; // return the object on which the function was called} 定义类相关的非成员函数（Defining Nonmember Class-Related Functions）类的作者通常会定义一些辅助函数，尽管这些函数从概念上来说属于类接口的组成部分，但实际上它们并不属于类本身。 123456789101112131415// input transactions contain ISBN, number of copies sold, and sales priceistream &amp;read(istream &amp;is, Sales_data &amp;item){ double price = 0; is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price; item.revenue = price * item.units_sold; return is;}ostream &amp;print(ostream &amp;os, const Sales_data &amp;item){ os &lt;&lt; item.isbn() &lt;&lt; \" \" &lt;&lt; item.units_sold &lt;&lt; \" \" &lt;&lt; item.revenue &lt;&lt; \" \" &lt;&lt; item.avg_price(); return os;} 如果非成员函数是类接口的组成部分，则这些函数的声明应该与类放在同一个头文件中。 一般来说，执行输出任务的函数应该尽量减少对格式的控制。 构造函数（Constructors）类通过一个或几个特殊的成员函数来控制其对象的初始化操作，这些函数被称作构造函数。只要类的对象被创建，就会执行构造函数。 构造函数的名字和类名相同，没有返回类型，且不能被声明为const函数。构造函数在const对象的构造过程中可以向其写值。 12345678910struct Sales_data { // constructors added Sales_data() = default; Sales_data(const std::string &amp;s): bookNo(s) { } Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) { } Sales_data(std::istream &amp;); // other members as before}; 类通过默认构造函数（default constructor）来控制默认初始化过程，默认构造函数无须任何实参。 如果类没有显式地定义构造函数，则编译器会为类隐式地定义一个默认构造函数，该构造函数也被称为合成的默认构造函数（synthesized default constructor）。对于大多数类来说，合成的默认构造函数初始化数据成员的规则如下： 如果存在类内初始值，则用它来初始化成员。 否则默认初始化该成员。 某些类不能依赖于合成的默认构造函数。 只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。一旦类定义了其他构造函数，那么除非再显式地定义一个默认的构造函数，否则类将没有默认构造函数。 如果类包含内置类型或者复合类型的成员，则只有当这些成员全部存在类内初始值时，这个类才适合使用合成的默认构造函数。否则用户在创建类的对象时就可能得到未定义的值。 编译器不能为某些类合成默认构造函数。例如类中包含一个其他类类型的成员，且该类型没有默认构造函数，那么编译器将无法初始化该成员。 在C++11中，如果类需要默认的函数行为，可以通过在参数列表后面添加=default来要求编译器生成构造函数。其中=default既可以和函数声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果=default在类的内部，则默认构造函数是内联的。 1Sales_data() = default; 构造函数初始值列表（constructor initializer list）负责为新创建对象的一个或几个数据成员赋初始值。形式是每个成员名字后面紧跟括号括起来的（或者在花括号内的）成员初始值，不同成员的初始值通过逗号分隔。 123Sales_data(const std::string &amp;s): bookNo(s) { }Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) { } 当某个数据成员被构造函数初始值列表忽略时，它会以与合成默认构造函数相同的方式隐式初始化。 123// has the same behavior as the original constructor defined aboveSales_data(const std::string &amp;s): bookNo(s), units_sold(0), revenue(0) { } 构造函数不应该轻易覆盖掉类内初始值，除非新值与原值不同。如果编译器不支持类内初始值，则所有构造函数都应该显式初始化每个内置类型的成员。 拷贝、赋值和析构（Copy、Assignment，and Destruction）编译器能合成拷贝、赋值和析构函数，但是对于某些类来说合成的版本无法正常工作。特别是当类需要分配类对象之外的资源时，合成的版本通常会失效。 访问控制与封装（Access Control and Encapsulation）使用访问说明符（access specifier）可以加强类的封装性： 定义在public说明符之后的成员在整个程序内都可以被访问。public成员定义类的接口。 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。private部分封装了类的实现细节。 1234567891011121314151617class Sales_data {public: // access specifier added Sales_data() = default; Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) { } Sales_data(const std::string &amp;s): bookNo(s) { } Sales_data(std::istream&amp;); std::string isbn() const { return bookNo; } Sales_data &amp;combine(const Sales_data&amp;); private: // access specifier added double avg_price() const { return units_sold ? revenue/units_sold : 0; } std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;}; 一个类可以包含零或多个访问说明符，每个访问说明符指定了接下来的成员的访问级别，其有效范围到出现下一个访问说明符或类的结尾处为止。 使用关键字struct定义类时，定义在第一个访问说明符之前的成员是public的；而使用关键字class时，这些成员是private的。二者唯一的区别就是默认访问权限不同。 友元（Friends）类可以允许其他类或函数访问它的非公有成员，方法是使用关键字friend将其他类或函数声明为它的友元。 123456789101112131415161718192021222324252627class Sales_data { // friend declarations for nonmember Sales_data operations added friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;); friend std::istream &amp;read(std::istream&amp;, Sales_data&amp;); friend std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;); // other members and access specifiers as beforepublic: Sales_data() = default; Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) { } Sales_data(const std::string &amp;s): bookNo(s) { } Sales_data(std::istream&amp;); std::string isbn() const { return bookNo; } Sales_data &amp;combine(const Sales_data&amp;); private: std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;};// declarations for nonmember parts of the Sales_data interfaceSales_data add(const Sales_data&amp;, const Sales_data&amp;);std::istream &amp;read(std::istream&amp;, Sales_data&amp;);std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;); 友元声明只能出现在类定义的内部，具体位置不限。友元不是类的成员，也不受它所在区域访问级别的约束。 通常情况下，最好在类定义开始或结束前的位置集中声明友元。 封装的好处： 确保用户代码不会无意间破坏封装对象的状态。 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。 友元声明仅仅指定了访问权限，而并非一个通常意义上的函数声明。如果希望类的用户能调用某个友元函数，就必须在友元声明之外再专门对函数进行一次声明（部分编译器没有该限制）。 为了使友元对类的用户可见，通常会把友元的声明（类的外部）与类本身放在同一个头文件中。 类的其他特性（Additional Class Features）类成员再探（Class Members Revisited）由类定义的类型名字和其他成员一样存在访问限制，可以是public或private中的一种。 1234567class Screen {public: // alternative way to declare a type member using a type alias using pos = std::string::size_type; // other members as before}; 与普通成员不同，用来定义类型的成员必须先定义后使用。类型成员通常位于类起始处。 定义在类内部的成员函数是自动内联的。 如果需要显式声明内联成员函数，建议只在类外部定义的位置说明inline。 inline成员函数该与类定义在同一个头文件中。 使用关键字mutable可以声明可变数据成员（mutable data member）。可变数据成员永远不会是const的，即使它在const对象内。因此const成员函数可以修改可变成员的值。 1234567891011121314class Screen {public: void some_member() const;private: mutable size_t access_ctr; // may change even in a const object // other members as before};void Screen::some_member() const{ ++access_ctr; // keep a count of the calls to any member function // whatever other work this member needs to do} 提供类内初始值时，必须使用=或花括号形式。 返回*this的成员函数（Functions That Return *this）const成员函数如果以引用形式返回*this，则返回类型是常量引用。 通过区分成员函数是否为const的，可以对其进行重载。在常量对象上只能调用const版本的函数；在非常量对象上，尽管两个版本都能调用，但会选择非常量版本。 1234567891011121314151617181920class Screen {public: // display overloaded on whether the object is const or not Screen &amp;display(std::ostream &amp;os) { do_display(os); return *this; } const Screen &amp;display(std::ostream &amp;os) const { do_display(os); return *this; } private: // function to do the work of displaying a Screen void do_display(std::ostream &amp;os) const { os &lt;&lt; contents; } // other members as before};Screen myScreen(5,3);const Screen blank(5, 3);myScreen.set('#').display(cout); // calls non const versionblank.display(cout); // calls const version 类类型（Class Types）每个类定义了唯一的类型。即使两个类的成员列表完全一致，它们也是不同的类型。 可以仅仅声明一个类而暂时不定义它。这种声明被称作前向声明（forward declaration），用于引入类的名字。在类声明之后定义之前都是一个不完全类型（incomplete type）。 1class Screen; // declaration of the Screen class 可以定义指向不完全类型的指针或引用，也可以声明（不能定义）以不完全类型作为参数或返回类型的函数。 只有当类全部完成后才算被定义，所以一个类的成员类型不能是该类本身。但是一旦类的名字出现，就可以被认为是声明过了，因此类可以包含指向它自身类型的引用或指针。 123456class Link_screen{ Screen window; Link_screen *next; Link_screen *prev;}; 友元再探（Friendship Revisited）除了普通函数，类还可以把其他类或其他类的成员函数声明为友元。友元类的成员函数可以访问此类包括非公有成员在内的所有成员。 123456class Screen { // Window_mgr members can access the private parts of class Screen friend class Window_mgr; // ... rest of the Screen class}; 友元函数可以直接定义在类的内部，这种函数是隐式内联的。但是必须在类外部提供相应声明令函数可见。 1234567891011struct X{ friend void f() { /* friend function can be defined in the class body */ } X() { f(); } // error: no declaration for f void g(); void h();};void X::g() { return f(); } // error: f hasn't been declaredvoid f(); // declares the function defined inside Xvoid X::h() { return f(); } // ok: declaration for f is now in scope 友元关系不存在传递性。 把其他类的成员函数声明为友元时，必须明确指定该函数所属的类名。 123456class Screen{ // Window_mgr::clear must have been declared before class Screen friend void Window_mgr::clear(ScreenIndex); // ... rest of the Screen class}; 如果类想把一组重载函数声明为友元，需要对这组函数中的每一个分别声明。 类的作用域（Class Scope）当成员函数定义在类外时，返回类型中使用的名字位于类的作用域之外，此时返回类型必须指明它是哪个类的成员。 1234567891011121314class Window_mgr{public: // add a Screen to the window and returns its index ScreenIndex addScreen(const Screen&amp;); // other members as before};// return type is seen before we're in the scope of Window_mgrWindow_mgr::ScreenIndex Window_mgr::addScreen(const Screen &amp;s){ screens.push_back(s); return screens.size() - 1;} 名字查找与作用域（Name Lookup and Class Scope）成员函数体直到整个类可见后才会被处理，因此它能使用类中定义的任何名字。 声明中使用的名字，包括返回类型或参数列表，都必须确保使用前可见。 如果类的成员使用了外层作用域的某个名字，而该名字表示一种类型，则类不能在之后重新定义该名字。 12345678910typedef double Money;class Account{public: Money balance() { return bal; } // uses Money from the outer scopprivate: typedef double Money; // error: cannot redefine Money Money bal; // ...}; 类型名定义通常出现在类起始处，这样能确保所有使用该类型的成员都位于类型名定义之后。 成员函数中名字的解析顺序： 在成员函数内查找该名字的声明，只有在函数使用之前出现的声明才会被考虑。 如果在成员函数内没有找到，则会在类内继续查找，这时会考虑类的所有成员。 如果类内也没有找到，会在成员函数定义之前的作用域查找。 123456789101112131415// it is generally a bad idea to use the same name for a parameter and a memberint height; // defines a name subsequently used inside Screenclass Screen{public: typedef std::string::size_type pos; void dummy_fcn(pos height) { cursor = width * height; // which height? the parameter }private: pos cursor = 0; pos height = 0, width = 0;}; 可以通过作用域运算符::或显式this指针来强制访问被隐藏的类成员。 12345678910111213// bad practice: names local to member functions shouldn't hide member namesvoid Screen::dummy_fcn(pos height){ cursor = width * this-&gt;height; // member height // alternative way to indicate the member cursor = width * Screen::height; // member height}// good practice: don't use a member name for a parameter or other local variablevoid Screen::dummy_fcn(pos ht){ cursor = width * height; // member height} 构造函数再探（Constructors Revisited）构造函数初始值列表（Constructor Initializer List）如果没有在构造函数初始值列表中显式初始化成员，该成员会在构造函数体之前执行默认初始化。 如果成员是const、引用，或者是某种未定义默认构造函数的类类型，必须在初始值列表中将其初始化。 123456789101112class ConstRef{public: ConstRef(int ii);private: int i; const int ci; int &amp;ri;};// ok: explicitly initialize reference and const membersConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) { } 最好令构造函数初始值的顺序与成员声明的顺序一致，并且尽量避免使用某些成员初始化其他成员。 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。 委托构造函数（Delegating Constructors）C++11扩展了构造函数初始值功能，可以定义委托构造函数。委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程。 1234567891011class Sales_data{public: // defines the default constructor as well as one that takes a string argument Sales_data(std::string s = \"\"): bookNo(s) { } // remaining constructors unchanged Sales_data(std::string s, unsigned cnt, double rev): bookNo(s), units_sold(cnt), revenue(rev*cnt) { } Sales_data(std::istream &amp;is) { read(is, *this); } // remaining members as before} 默认构造函数的作用（The Role of the Default Constructor）当对象被默认初始化或值初始化时会自动执行默认构造函数。 默认初始化的发生情况： 在块作用域内不使用初始值定义非静态变量或数组。 类本身含有类类型的成员且使用合成默认构造函数。 类类型的成员没有在构造函数初始值列表中显式初始化。 值初始化的发生情况： 数组初始化时提供的初始值数量少于数组大小。 不使用初始值定义局部静态变量。 通过T()形式（T为类型）的表达式显式地请求值初始化。 类必须包含一个默认构造函数。 如果想定义一个使用默认构造函数进行初始化的对象，应该去掉对象名后的空括号对。 12Sales_data obj(); // oops! declares a function, not an objectSales_data obj2; // ok: obj2 is an object, not a function 隐式的类类型转换（Implicit Class-Type Conversions）如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制。这种构造函数被称为转换构造函数（converting constructor）。 1234string null_book = \"9-999-99999-9\";// constructs a temporary Sales_data object// with units_sold and revenue equal to 0 and bookNo equal to null_bookitem.combine(null_book); 编译器只会自动执行一步类型转换。 12345678// error: requires two user-defined conversions:// (1) convert \"9-999-99999-9\" to string// (2) convert that (temporary) string to Sales_dataitem.combine(\"9-999-99999-9\");// ok: explicit conversion to string, implicit conversion to Sales_dataitem.combine(string(\"9-999-99999-9\"));// ok: implicit conversion to string, explicit conversion to Sales_dataitem.combine(Sales_data(\"9-999-99999-9\")); 在要求隐式转换的程序上下文中，可以通过将构造函数声明为explicit的加以阻止。 12345678910class Sales_data{public: Sales_data() = default; Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) { } explicit Sales_data(const std::string &amp;s): bookNo(s) { } explicit Sales_data(std::istream&amp;); // remaining members as before}; explicit关键字只对接受一个实参的构造函数有效。 只能在类内声明构造函数时使用explicit关键字，在类外定义时不能重复。 执行拷贝初始化时（使用=）会发生隐式转换，所以explicit构造函数只能用于直接初始化。 123Sales_data item1 (null_book); // ok: direct initialization// error: cannot use the copy form of initialization with an explicit constructorSales_data item2 = null_book; 可以使用explicit构造函数显式地强制转换类型。 1234// ok: the argument is an explicitly constructed Sales_data objectitem.combine(Sales_data(null_book));// ok: static_cast can use an explicit constructoritem.combine(static_cast&lt;Sales_data&gt;(cin)); 聚合类（Aggregate Classes）聚合类满足如下条件： 所有成员都是public的。 没有定义任何构造函数。 没有类内初始值。 没有基类。 没有虚函数。 12345struct Data{ int ival; string s;}; 可以使用一个用花括号包围的成员初始值列表初始化聚合类的数据成员。初始值顺序必须与声明顺序一致。如果初始值列表中的元素个数少于类的成员个数，则靠后的成员被值初始化。 12// val1.ival = 0; val1.s = string(\"Anna\")Data val1 = { 0, \"Anna\" }; 字面值常量类（Literal Classes）数据成员都是字面值类型的聚合类是字面值常量类。或者一个类不是聚合类，但符合下列条件，则也是字面值常量类： 数据成员都是字面值类型。 类至少含有一个constexpr构造函数。 如果数据成员含有类内初始值，则内置类型成员的初始值必须是常量表达式。如果成员属于类类型，则初始值必须使用成员自己的constexpr构造函数。 类必须使用析构函数的默认定义。 constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型。 constexpr构造函数必须初始化所有数据成员，初始值使用constexpr构造函数或常量表达式。 类的静态成员（static Class Members）使用关键字static可以声明类的静态成员。静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。 12345678910111213class Account{public: void calculate() { amount += amount * interestRate; } static double rate() { return interestRate; } static void rate(double);private: std::string owner; double amount; static double interestRate; static double initRate();}; 由于静态成员不与任何对象绑定，因此静态成员函数不能声明为const的，也不能在静态成员函数内使用this指针。 用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。 1234567891011121314151617double r;r = Account::rate(); // access a static member using the scope operatorAccount ac1;Account *ac2 = &amp;ac1;// equivalent ways to call the static member rate functionr = ac1.rate(); // through an Account object or referencer = ac2-&gt;rate(); // through a pointer to an Account objectclass Account{public: void calculate() { amount += amount * interestRate; }private: static double interestRate; // remaining members as before}; 在类外部定义静态成员时，不能重复static关键字，其只能用于类内部的声明语句。 由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。而必须在类外部定义并初始化每个静态成员。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。 12// define and initialize a static class memberdouble Account::interestRate = initRate(); 建议把静态数据成员的定义与其他非内联函数的定义放在同一个源文件中，这样可以确保对象只被定义一次。 尽管在通常情况下，不应该在类内部初始化静态成员。但是可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式。 123456789class Account{public: static double rate() { return interestRate; } static void rate(double);private: static constexpr int period = 30; // period is a constant double daily_tbl[period];}; 静态数据成员的类型可以是它所属的类类型。 123456class Bar{ static Bar mem1; // ok: static member can have incomplete type Bar *mem2; // ok: pointer member can have incomplete type Bar mem3; // error: data members must have complete type} 可以使用静态成员作为函数的默认实参。 123456789class Screen{public: // bkground refers to the static member // declared later in the class definition Screen&amp; clear(char = bkground);private: static const char bkground;};","link":"/2021/02/27/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/"},{"title":"剑指offer","text":"05空格替换1234567891011121314151617181920212223242526272829class Solution {public: string replaceSpace(string s) { int len = s.size(); int count = 0; for (int i = 0; i &lt; len; i++) { if (s[i] == ' ') { count++; } } int length = len + 2 * count; s.resize(length); //用s.reserve不行会报错 int i = len - 1, j = length - 1; while (i != j) { if (s[i] == ' ') { s[j] = '0'; s[j - 1] = '2'; s[j - 2] = '%'; j = j - 2;//漏了 } else { s[j] = s[i]; } i--; j--; } return s; }}; 06从尾到头打印链表1234567891011121314151617class Solution {//看准题意public: vector&lt;int&gt; reversePrint(ListNode* head) { stack&lt;int&gt; stk; vector&lt;int&gt; res; ListNode* cur;//指向头节点啊 while(cur != nullptr){ stk.push(cur-&gt;val);//用了. cur = cur-&gt;next; } while(!stk.empty()){ res.push_back(stk.top()); stk.pop(); } return res; }}; 用两个链表实现栈123456789101112131415161718192021222324252627282930class CQueue {public: CQueue() { } stack&lt;int&gt; stackA; stack&lt;int&gt; stackB; void appendTail(int value) { stackA.push(value); } int deleteHead() { int temp = 0; if(stackA.empty() &amp;&amp; stackB.empty()){ return -1; } if(stackB.empty()){ while(!stackA.empty()){ stackB.push(stackA.top()); stackA.pop(); } temp = stackB.top(); stackB.pop(); return temp; } temp = stackB.top(); stackB.pop(); return temp; }}; 反转链表123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { ListNode *cur = head, *pre = nullptr; while(cur != nullptr){ ListNode *temp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = temp; } return pre; }}; 有min的栈12345678910111213141516171819202122232425262728293031class MinStack {public: /** initialize your data structure here. */ MinStack() { } void push(int x) { stk.push(x); if(minStk.empty() || minStk.top() &gt;= x){ minStk.push(x); } } void pop() { if(minStk.top() == stk.top()){ minStk.pop(); } stk.pop(); } int top() { return stk.top(); } int min() { return minStk.top(); }private: stack&lt;int&gt; stk, minStk;}; 58左旋转字符串123456class Solution {public: string reverseLeftWords(string s, int n) { return (s.substr(n,s.size()) + s.substr(0,n)); }}; 最小k个数1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) { quickSort(arr, 0, arr.size() - 1); vector&lt;int&gt; res; for (int i = 0; i &lt; k; i++) { res.push_back(arr[i]); } return res; } void quickSort(vector&lt;int&gt;&amp; arr, int l, int r) { if (l &gt;= r) return; int i = l, j = r; while (i &lt; j) { while ((i &lt; j) &amp;&amp; arr[j] &gt;= arr[l]) j--; //不能用i &lt;= j，会出错 while ((i &lt; j) &amp;&amp; arr[i] &lt;= arr[l]) i++; swap(arr[i], arr[j]); } swap(arr[i], arr[l]); quickSort(arr, l, i - 1); quickSort(arr, i + 1, r); }}; 数据流中的中位数123456789101112131415161718192021222324252627282930class MedianFinder {public: /** initialize your data structure here. */ MedianFinder() { } void addNum(int num) { if(minHeap.size() == maxHeap.size()){ maxHeap.push(num); minHeap.push(maxHeap.top()); maxHeap.pop(); }else{ minHeap.push(num); maxHeap.push(minHeap.top()); minHeap.pop(); } } double findMedian() { if(minHeap.size() == maxHeap.size()){ return (minHeap.top() + maxHeap.top())/2.0;//得是2.0 }else{ return minHeap.top(); } }private: priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap; priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap;}; 把数组排成最小数123456789101112131415161718192021222324252627class Solution {public: string minNumber(vector&lt;int&gt;&amp; nums) { vector&lt;string&gt; arr; for(int num : nums){ arr.push_back(to_string(num));//string里面的数值转换 } quickSort(arr, 0, arr.size() - 1); string str; for(string s : arr){ str += s; } return str; } void quickSort(vector&lt;string&gt;&amp; arr, int l, int r){ if(l &gt;= r) return; int i = l, j = r; while(i &lt; j){ while((i &lt; j) &amp;&amp; (arr[j] + arr[l] &gt;= arr[l] + arr[j])) j--; while((i &lt; j) &amp;&amp; (arr[i] + arr[l] &lt;= arr[l] + arr[i])) i++; swap(arr[i], arr[j]); } swap(arr[l], arr[i]); quickSort(arr, l, i - 1); quickSort(arr, i + 1, r); }}; 扑克牌中的顺子12345678910111213141516171819202122232425262728class Solution {public: bool isStraight(vector&lt;int&gt;&amp; nums) { int max = 0, min = 14; set&lt;int&gt; repeat; for(int i : nums){ if(i == 0){ continue; } if(i &gt; max){//不能用if else if else if max = i; } if(i &lt; min){ min = i; } auto isFound = repeat.find(i); if(isFound != repeat.end()){ return false; } repeat.insert(i); } if(max - min &lt; 5){ return true; }else{ return false; } }}; 数组中重复的数字12345678910111213class Solution {public: int findRepeatNumber(vector&lt;int&gt;&amp; nums) { set&lt;int&gt; repeat; for(int num : nums){ if(repeat.find(num) != repeat.end()){ return num; } repeat.insert(num); } return -1;//一定要返回-1，即要有覆盖全部可能的返回 }}; 二维数组的查找12345678910111213141516171819class Solution {public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { if(matrix.size() == 0){//matrix[0].size()会出错，当matrix为空时 return false; } int row = matrix.size(), colum = matrix[0].size(); for(int i = row - 1, j = 0; i &gt;= 0 &amp;&amp; j &lt; colum;){ if(matrix[i][j] == target) return true; if(matrix[i][j] &gt; target){//注意比较大小的逻辑 i--; }else{ j++; } } return false; }}; 旋转数组的最小数字1234567891011121314151617class Solution {public: int minArray(vector&lt;int&gt;&amp; numbers) { int l = 0, r = numbers.size() - 1, min; while(l &lt; r){ min = (l + r)/2; if(numbers[min] &gt; numbers[r]){ l = min + 1; }else if(numbers[min] &lt; numbers[r]){ r = min; }else{ r = r - 1;//不是r = min - 1; } } return numbers[l]; }}; 合并两个链表12345678910111213141516171819class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* cur = new ListNode();//要新建一个节点使链表连接起来，cur指向最后一个节点 ListNode* head = cur; while(l1 != nullptr &amp;&amp; l2 != nullptr){ if(l1-&gt;val &lt;= l2-&gt;val){ cur-&gt;next = l1; l1 = l1-&gt;next;//漏了 }else{ cur-&gt;next = l2; l2 = l2-&gt;next;//漏了 } cur = cur-&gt;next; } l1 == nullptr ? cur-&gt;next = l2 : cur-&gt;next = l1; return head-&gt;next; }}; 剑指 Offer 20. 表示数值的字符串请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。 方法一：确定有限状态自动机预备知识 确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中： 有一个特殊的状态，被称作「初始状态」。还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。 注意：如果输入的过程中某一步转移失败了，即不存在对应的「转移规则」，此时计算将提前中止。在这种情况下我们也判定该字符串「被拒绝」。 一个自动机，总能够回答某种形式的「对于给定的输入字符串 S，判断其是否满足条件 P」的问题。在本题中，条件 P 即为「构成合法的表示数值的字符串」。 自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。 自动机在计算机科学领域有着广泛的应用。在算法领域，它与大名鼎鼎的字符串查找算法「KMP」算法有着密切的关联；在工程领域，它是实现「正则表达式」的基础。 问题描述 在 C++ 文档 中，描述了一个合法的数值字符串应当具有的格式。具体而言，它包含以下部分： 符号位，即 +++、−-− 两种符号整数部分，即由若干字符 0−90-90−9 组成的字符串小数点小数部分，其构成与整数部分相同指数部分，其中包含开头的字符 e\\text{e}e（大写小写均可）、可选的符号位，和整数部分相比于 C++ 文档而言，本题还有一点额外的不同，即允许字符串首末两端有一些额外的空格。 在上面描述的五个部分中，每个部分都不是必需的，但也受一些额外规则的制约，如： 如果符号位存在，其后面必须跟着数字或小数点。小数点的前后两侧，至少有一侧是数字。思路与算法 根据上面的描述，现在可以定义自动机的「状态集合」了。那么怎么挖掘出所有可能的状态呢？一个常用的技巧是，用「当前处理到字符串的哪个部分」当作状态的表述。根据这一技巧，不难挖掘出所有状态： 起始的空格符号位整数部分左侧有整数的小数点左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）小数部分字符 e\\text{e}e指数部分的符号位指数部分的整数部分末尾的空格下一步是找出「初始状态」和「接受状态」的集合。根据题意，「初始状态」应当为状态 1，而「接受状态」的集合则为状态 3、状态 4、状态 6、状态 9 以及状态 10。换言之，字符串的末尾要么是空格，要么是数字，要么是小数点，但前提是小数点的前面有数字。 最后，需要定义「转移规则」。结合数值字符串应当具备的格式，将自动机转移的过程以图解的方式表示出来： 比较上图与「预备知识」一节中对自动机的描述，可以看出有一点不同： 我们没有单独地考虑每种字符，而是划分为若干类。由于全部 101010 个数字字符彼此之间都等价，因此只需定义一种统一的「数字」类型即可。对于正负号也是同理。在实际代码中，我们需要处理转移失败的情况。例如当位于状态 1（起始空格）时，没有对应字符 e\\text{e}e 的状态。为了处理这种情况，我们可以创建一个特殊的拒绝状态。如果当前状态下没有对应读入字符的「转移规则」，我们就转移到这个特殊的拒绝状态。一旦自动机转移到这个特殊状态，我们就可以立即判定该字符串不「被接受」。 链接：https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/biao-shi-shu-zhi-de-zi-fu-chuan-by-leetcode-soluti/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114class Solution {public: enum State { STATE_INITIAL, STATE_INT_SIGN, STATE_INTEGER, STATE_POINT, STATE_POINT_WITHOUT_INT, STATE_FRACTION, STATE_EXP, STATE_EXP_SIGN, STATE_EXP_NUMBER, STATE_END, }; enum CharType { CHAR_NUMBER, CHAR_EXP, CHAR_POINT, CHAR_SIGN, CHAR_SPACE, CHAR_ILLEGAL, }; CharType toCharType(char ch) { if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { return CHAR_NUMBER; } else if (ch == 'e' || ch == 'E') { return CHAR_EXP; } else if (ch == '.') { return CHAR_POINT; } else if (ch == '+' || ch == '-') { return CHAR_SIGN; } else if (ch == ' ') { return CHAR_SPACE; } else { return CHAR_ILLEGAL; } } bool isNumber(string s) { unordered_map&lt;State, unordered_map&lt;CharType, State&gt;&gt; transfer{ { STATE_INITIAL, { {CHAR_SPACE, STATE_INITIAL}, {CHAR_NUMBER, STATE_INTEGER}, {CHAR_POINT, STATE_POINT_WITHOUT_INT}, {CHAR_SIGN, STATE_INT_SIGN}, } }, { STATE_INT_SIGN, { {CHAR_NUMBER, STATE_INTEGER}, {CHAR_POINT, STATE_POINT_WITHOUT_INT}, } }, { STATE_INTEGER, { {CHAR_NUMBER, STATE_INTEGER}, {CHAR_EXP, STATE_EXP}, {CHAR_POINT, STATE_POINT}, {CHAR_SPACE, STATE_END}, } }, { STATE_POINT, { {CHAR_NUMBER, STATE_FRACTION}, {CHAR_EXP, STATE_EXP}, {CHAR_SPACE, STATE_END}, } }, { STATE_POINT_WITHOUT_INT, { {CHAR_NUMBER, STATE_FRACTION}, } }, { STATE_FRACTION, { {CHAR_NUMBER, STATE_FRACTION}, {CHAR_EXP, STATE_EXP}, {CHAR_SPACE, STATE_END}, } }, { STATE_EXP, { {CHAR_NUMBER, STATE_EXP_NUMBER}, {CHAR_SIGN, STATE_EXP_SIGN}, } }, { STATE_EXP_SIGN, { {CHAR_NUMBER, STATE_EXP_NUMBER}, } }, { STATE_EXP_NUMBER, { {CHAR_NUMBER, STATE_EXP_NUMBER}, {CHAR_SPACE, STATE_END}, } }, { STATE_END, { {CHAR_SPACE, STATE_END}, } } }; int len = s.length(); State st = STATE_INITIAL; for (int i = 0; i &lt; len; i++) { CharType typ = toCharType(s[i]); if (transfer[st].find(typ) == transfer[st].end()) { return false; } else { st = transfer[st][typ]; } } return st == STATE_INTEGER || st == STATE_POINT || st == STATE_FRACTION || st == STATE_EXP_NUMBER || st == STATE_END; }};","link":"/2021/03/10/%E5%89%91%E6%8C%87offer/"},{"title":"linux操作集合","text":"卸载、安装、更新命令https://xiaohost.com/1860.html 安装火狐 yum -y install firefox 查看当前目录大小du -sh https://blog.csdn.net/duan19920101/article/details/104823301","link":"/2021/03/17/linux%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88/"},{"title":"js学习","text":"const let varhttps://www.jianshu.com/p/7be962a355f8","link":"/2021/04/03/js%E5%AD%A6%E4%B9%A0/"},{"title":"mysql学习笔记","text":"MySQL学习笔记 https://www.bilibili.com/video/BV1Vt411z7wy?p=18&amp;spm_id_from=pageDriver https://github.com/hjzCy/sql_node/edit/master/mysql/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md 登录和退出MySQL服务器12345# 登录MySQL$ mysql -u root -p12345612# 退出MySQL数据库服务器exit; 基本语法12345678910111213141516171819202122232425262728293031323334353637383940-- 显示所有数据库show databases;-- 创建数据库CREATE DATABASE test;-- 切换数据库use test;-- 显示数据库中的所有表show tables;-- 创建数据表CREATE TABLE pet ( name VARCHAR(20), owner VARCHAR(20), species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);-- 查看数据表结构-- describe pet;desc pet;-- 查询表SELECT * from pet;-- 插入数据INSERT INTO pet VALUES ('puffball', 'Diane', 'hamster', 'f', '1990-03-30', NULL);-- 修改数据UPDATE pet SET name = 'squirrel' where owner = 'Diane';-- 删除数据DELETE FROM pet where name = 'squirrel';-- 删除表DROP TABLE myorder; 建表约束主键约束123456789101112131415161718192021222324252627282930-- 主键约束-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。CREATE TABLE user ( id INT PRIMARY KEY, name VARCHAR(20));-- 联合主键-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。CREATE TABLE user ( id INT, name VARCHAR(20), password VARCHAR(20), PRIMARY KEY(id, name));-- 自增约束-- 自增约束的主键由系统自动递增分配。CREATE TABLE user ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20));-- 添加主键约束-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD PRIMARY KEY(id);ALTER TABLE user MODIFY id INT PRIMARY KEY;-- 删除主键ALTER TABLE user drop PRIMARY KEY; 唯一主键1234567891011121314-- 建表时创建唯一主键CREATE TABLE user ( id INT, name VARCHAR(20), UNIQUE(name));-- 添加唯一主键-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD UNIQUE(name);ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;-- 删除唯一主键ALTER TABLE user DROP INDEX name; 非空约束123456789-- 建表时添加非空约束-- 约束某个字段不能为空CREATE TABLE user ( id INT, name VARCHAR(20) NOT NULL);-- 移除非空约束ALTER TABLE user MODIFY name VARCHAR(20); 默认约束12345678910-- 建表时添加默认约束-- 约束某个字段的默认值CREATE TABLE user2 ( id INT, name VARCHAR(20), age INT DEFAULT 10);-- 移除非空约束ALTER TABLE user MODIFY age INT; 外键约束123456789101112131415161718-- 班级CREATE TABLE classes ( id INT PRIMARY KEY, name VARCHAR(20));-- 学生表CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(20), -- 这里的 class_id 要和 classes 中的 id 字段相关联 class_id INT, -- 表示 class_id 的值必须来自于 classes 中的 id 字段值 FOREIGN KEY(class_id) REFERENCES classes(id));-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；-- 2. 主表中的记录被副表引用时，主表不可以被删除。 数据库的三大设计范式1NF只要字段值还可以继续拆分，就不满足第一范式。 范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。 2NF在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下： 12345678-- 订单表CREATE TABLE myorder ( product_id INT, customer_id INT, product_name VARCHAR(20), customer_name VARCHAR(20), PRIMARY KEY (product_id, customer_id)); 实际上，在这张订单表中，product_name 只依赖于 product_id ，customer_name 只依赖于 customer_id 。也就是说，product_name 和 customer_id 是没用关系的，customer_name 和 product_id 也是没有关系的。 这就不满足第二范式：其他列都必须完全依赖于主键列！ 123456789101112131415CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT);CREATE TABLE product ( id INT PRIMARY KEY, name VARCHAR(20));CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(20)); 拆分之后，myorder 表中的 product_id 和 customer_id 完全依赖于 order_id 主键，而 product 和 customer 表中的其他字段又完全依赖于主键。满足了第二范式的设计！ 3NF在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。 123456CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT, customer_phone VARCHAR(15)); 表中的 customer_phone 有可能依赖于 order_id 、 customer_id 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。 1234567891011CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT);CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(20), phone VARCHAR(15)); 修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！ 查询练习准备数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687-- 创建数据库CREATE DATABASE select_test;-- 切换数据库USE select_test;-- 创建学生表CREATE TABLE student ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, sex VARCHAR(10) NOT NULL, birthday DATE, -- 生日 class VARCHAR(20) -- 所在班级);-- 创建教师表CREATE TABLE teacher ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, sex VARCHAR(10) NOT NULL, birthday DATE, profession VARCHAR(20) NOT NULL, -- 职称 department VARCHAR(20) NOT NULL -- 部门);-- 创建课程表CREATE TABLE course ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, t_no VARCHAR(20) NOT NULL, -- 教师编号 -- 表示该 tno 来自于 teacher 表中的 no 字段值 FOREIGN KEY(t_no) REFERENCES teacher(no) );-- 成绩表CREATE TABLE score ( s_no VARCHAR(20) NOT NULL, -- 学生编号 c_no VARCHAR(20) NOT NULL, -- 课程号 degree DECIMAL, -- 成绩 -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值 FOREIGN KEY(s_no) REFERENCES student(no), FOREIGN KEY(c_no) REFERENCES course(no), -- 设置 s_no, c_no 为联合主键 PRIMARY KEY(s_no, c_no));-- 查看所有表SHOW TABLES;-- 添加学生表数据INSERT INTO student VALUES('101', '曾华', '男', '1977-09-01', '95033');INSERT INTO student VALUES('102', '匡明', '男', '1975-10-02', '95031');INSERT INTO student VALUES('103', '王丽', '女', '1976-01-23', '95033');INSERT INTO student VALUES('104', '李军', '男', '1976-02-20', '95033');INSERT INTO student VALUES('105', '王芳', '女', '1975-02-10', '95031');INSERT INTO student VALUES('106', '陆军', '男', '1974-06-03', '95031');INSERT INTO student VALUES('107', '王尼玛', '男', '1976-02-20', '95033');INSERT INTO student VALUES('108', '张全蛋', '男', '1975-02-10', '95031');INSERT INTO student VALUES('109', '赵铁柱', '男', '1974-06-03', '95031');-- 添加教师表数据INSERT INTO teacher VALUES('804', '李诚', '男', '1958-12-02', '副教授', '计算机系');INSERT INTO teacher VALUES('856', '张旭', '男', '1969-03-12', '讲师', '电子工程系');INSERT INTO teacher VALUES('825', '王萍', '女', '1972-05-05', '助教', '计算机系');INSERT INTO teacher VALUES('831', '刘冰', '女', '1977-08-14', '助教', '电子工程系');-- 添加课程表数据INSERT INTO course VALUES('3-105', '计算机导论', '825');INSERT INTO course VALUES('3-245', '操作系统', '804');INSERT INTO course VALUES('6-166', '数字电路', '856');INSERT INTO course VALUES('9-888', '高等数学', '831');-- 添加添加成绩表数据INSERT INTO score VALUES('103', '3-105', '92');INSERT INTO score VALUES('103', '3-245', '86');INSERT INTO score VALUES('103', '6-166', '85');INSERT INTO score VALUES('105', '3-105', '88');INSERT INTO score VALUES('105', '3-245', '75');INSERT INTO score VALUES('105', '6-166', '79');INSERT INTO score VALUES('109', '3-105', '76');INSERT INTO score VALUES('109', '3-245', '68');INSERT INTO score VALUES('109', '6-166', '81');-- 查看表结构SELECT * FROM course;SELECT * FROM score;SELECT * FROM student;SELECT * FROM teacher; 1 到 1012345678910111213141516171819202122232425262728293031323334353637383940414243-- 查询 student 表的所有行SELECT * FROM student;-- 查询 student 表中的 name、sex 和 class 字段的所有行SELECT name, sex, class FROM student;-- 查询 teacher 表中不重复的 department 列-- department: 去重查询SELECT DISTINCT department FROM teacher;-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）-- BETWEEN xx AND xx: 查询区间, AND 表示 &quot;并且&quot;SELECT * FROM score WHERE degree BETWEEN 60 AND 80;SELECT * FROM score WHERE degree &gt; 60 AND degree &lt; 80;-- 查询 score 表中成绩为 85, 86 或 88 的行-- IN: 查询规定中的多个值SELECT * FROM score WHERE degree IN (85, 86, 88);-- 查询 student 表中 '95031' 班或性别为 '女' 的所有行-- or: 表示或者关系SELECT * FROM student WHERE class = '95031' or sex = '女';-- 以 class 降序的方式查询 student 表的所有行-- DESC: 降序，从高到低-- ASC（默认）: 升序，从低到高SELECT * FROM student ORDER BY class DESC;SELECT * FROM student ORDER BY class ASC;-- 以 c_no 升序、degree 降序查询 score 表的所有行SELECT * FROM score ORDER BY c_no ASC, degree DESC;-- 查询 &quot;95031&quot; 班的学生人数-- COUNT: 统计SELECT COUNT(*) FROM student WHERE class = '95031';-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。-- (SELECT MAX(degree) FROM score): 子查询，算出最高分SELECT s_no, c_no FROM score WHERE degree = (SELECT MAX(degree) FROM score);-- 排序查询-- LIMIT r, n: 表示从第r行开始，查询n条数据SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1; 分组计算平均成绩查询每门课的平均成绩。 1234567-- AVG: 平均值SELECT AVG(degree) FROM score WHERE c_no = '3-105';SELECT AVG(degree) FROM score WHERE c_no = '3-245';SELECT AVG(degree) FROM score WHERE c_no = '6-166';-- GROUP BY: 分组查询SELECT c_no, AVG(degree) FROM score GROUP BY c_no; 分组条件与模糊查询查询 score 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。 123456789101112131415SELECT * FROM score;-- c_no 课程编号+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 分析表发现，至少有 2 名学生选修的课程是 3-105 、3-245 、6-166 ，以 3 开头的课程是 3-105 、3-245 。也就是说，我们要查询所有 3-105 和 3-245 的 degree 平均分。 12345678910111213141516171819202122232425262728-- 首先把 c_no, AVG(degree) 通过分组查询出来SELECT c_no, AVG(degree) FROM score GROUP BY c_no+-------+-------------+| c_no | AVG(degree) |+-------+-------------+| 3-105 | 85.3333 || 3-245 | 76.3333 || 6-166 | 81.6667 |+-------+-------------+-- 再查询出至少有 2 名学生选修的课程-- HAVING: 表示持有HAVING COUNT(c_no) &gt;= 2-- 并且是以 3 开头的课程-- LIKE 表示模糊查询，&quot;%&quot; 是一个通配符，匹配 &quot;3&quot; 后面的任意字符。AND c_no LIKE '3%';-- 把前面的SQL语句拼接起来，-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_noHAVING COUNT(c_no) &gt;= 2 AND c_no LIKE '3%';+-------+-------------+----------+| c_no | AVG(degree) | COUNT(*) |+-------+-------------+----------+| 3-105 | 85.3333 | 3 || 3-245 | 76.3333 | 3 |+-------+-------------+----------+ 多表查询 - 1查询所有学生的 name，以及该学生在 score 表中对应的 c_no 和 degree 。 1234567891011121314151617181920212223242526272829SELECT no, name FROM student;+-----+-----------+| no | name |+-----+-----------+| 101 | 曾华 || 102 | 匡明 || 103 | 王丽 || 104 | 李军 || 105 | 王芳 || 106 | 陆军 || 107 | 王尼玛 || 108 | 张全蛋 || 109 | 赵铁柱 |+-----+-----------+SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 通过分析可以发现，只要把 score 表中的 s_no 字段值替换成 student 表中对应的 name 字段值就可以了，如何做呢？ 1234567891011121314151617-- FROM...: 表示从 student, score 表中查询-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。SELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no;+-----------+-------+--------+| name | c_no | degree |+-----------+-------+--------+| 王丽 | 3-105 | 92 || 王丽 | 3-245 | 86 || 王丽 | 6-166 | 85 || 王芳 | 3-105 | 88 || 王芳 | 3-245 | 75 || 王芳 | 6-166 | 79 || 赵铁柱 | 3-105 | 76 || 赵铁柱 | 3-245 | 68 || 赵铁柱 | 6-166 | 81 |+-----------+-------+--------+ 多表查询 - 2查询所有学生的 no 、课程名称 ( course 表中的 name ) 和成绩 ( score 表中的 degree ) 列。 只有 score 关联学生的 no ，因此只要查询 score 表，就能找出所有和学生相关的 no 和 degree ： 1234567891011121314SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 然后查询 course 表： 12345678+-------+-----------------+| no | name |+-------+-----------------+| 3-105 | 计算机导论 || 3-245 | 操作系统 || 6-166 | 数字电路 || 9-888 | 高等数学 |+-------+-----------------+ 只要把 score 表中的 c_no 替换成 course 表中对应的 name 字段值就可以了。 1234567891011121314151617-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。-- as 表示取一个该字段的别名。SELECT s_no, name as c_name, degree FROM score, courseWHERE score.c_no = course.no;+------+-----------------+--------+| s_no | c_name | degree |+------+-----------------+--------+| 103 | 计算机导论 | 92 || 105 | 计算机导论 | 88 || 109 | 计算机导论 | 76 || 103 | 操作系统 | 86 || 105 | 操作系统 | 75 || 109 | 操作系统 | 68 || 103 | 数字电路 | 85 || 105 | 数字电路 | 79 || 109 | 数字电路 | 81 |+------+-----------------+--------+ 三表关联查询查询所有学生的 name 、课程名 ( course 表中的 name ) 和 degree 。 只有 score 表中关联学生的学号和课堂号，我们只要围绕着 score 这张表查询就好了。 1234567891011121314SELECT * FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 只要把 s_no 和 c_no 替换成 student 和 srouse 表中对应的 name 字段值就好了。 首先把 s_no 替换成 student 表中的 name 字段： 1234567891011121314SELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no;+-----------+-------+--------+| name | c_no | degree |+-----------+-------+--------+| 王丽 | 3-105 | 92 || 王丽 | 3-245 | 86 || 王丽 | 6-166 | 85 || 王芳 | 3-105 | 88 || 王芳 | 3-245 | 75 || 王芳 | 6-166 | 79 || 赵铁柱 | 3-105 | 76 || 赵铁柱 | 3-245 | 68 || 赵铁柱 | 6-166 | 81 |+-----------+-------+--------+ 再把 c_no 替换成 course 表中的 name 字段： 12345678910111213141516-- 课程表SELECT no, name FROM course;+-------+-----------------+| no | name |+-------+-----------------+| 3-105 | 计算机导论 || 3-245 | 操作系统 || 6-166 | 数字电路 || 9-888 | 高等数学 |+-------+-----------------+-- 由于字段名存在重复，使用 &quot;表名.字段名 as 别名&quot; 代替。SELECT student.name as s_name, course.name as c_name, degree FROM student, score, courseWHERE student.NO = score.s_noAND score.c_no = course.no; 子查询加分组求平均分查询 95031 班学生每门课程的平均成绩。 在 score 表中根据 student 表的学生编号筛选出学生的课堂号和成绩： 12345678910111213-- IN (..): 将筛选出的学生号当做 s_no 的条件查询SELECT s_no, c_no, degree FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class = '95031');+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 这时只要将 c_no 分组一下就能得出 95031 班学生每门课的平均成绩： 12345678910SELECT c_no, AVG(degree) FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class = '95031')GROUP BY c_no;+-------+-------------+| c_no | AVG(degree) |+-------+-------------+| 3-105 | 82.0000 || 3-245 | 71.5000 || 6-166 | 80.0000 |+-------+-------------+ 子查询 - 1查询在 3-105 课程中，所有成绩高于 109 号同学的记录。 首先筛选出课堂号为 3-105 ，在找出所有成绩高于 109 号同学的的行。 123SELECT * FROM score WHERE c_no = '3-105'AND degree &gt; (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105'); 子查询 - 2查询所有成绩高于 109 号同学的 3-105 课程成绩记录。 123-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。SELECT * FROM scoreWHERE degree &gt; (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105'); YEAR 函数与带 IN 关键字查询查询所有和 101 、108 号学生同年出生的 no 、name 、birthday 列。 123-- YEAR(..): 取出日期中的年份SELECT no, name, birthday FROM studentWHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108)); 多层嵌套子查询查询 '张旭' 教师任课的学生成绩表。 首先找到教师编号： 1SELECT NO FROM teacher WHERE NAME = '张旭' 通过 sourse 表找到该教师课程号： 1SELECT NO FROM course WHERE t_no = ( SELECT NO FROM teacher WHERE NAME = '张旭' ); 通过筛选出的课程号查询成绩表： 12345SELECT * FROM score WHERE c_no = ( SELECT no FROM course WHERE t_no = ( SELECT no FROM teacher WHERE NAME = '张旭' )); 多表查询查询某选修课程多于5个同学的教师姓名。 首先在 teacher 表中，根据 no 字段来判断该教师的同一门课程是否有至少5名学员选修： 1234567891011121314-- 查询 teacher 表SELECT no, name FROM teacher;+-----+--------+| no | name |+-----+--------+| 804 | 李诚 || 825 | 王萍 || 831 | 刘冰 || 856 | 张旭 |+-----+--------+SELECT name FROM teacher WHERE no IN ( -- 在这里找到对应的条件); 查看和教师编号有有关的表的信息： 12345678910SELECT * FROM course;-- t_no: 教师编号+-------+-----------------+------+| no | name | t_no |+-------+-----------------+------+| 3-105 | 计算机导论 | 825 || 3-245 | 操作系统 | 804 || 6-166 | 数字电路 | 856 || 9-888 | 高等数学 | 831 |+-------+-----------------+------+ 我们已经找到和教师编号有关的字段就在 course 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 score 表来查询： 12345678910111213141516171819202122232425262728293031-- 在此之前向 score 插入一些数据，以便丰富查询条件。INSERT INTO score VALUES ('101', '3-105', '90');INSERT INTO score VALUES ('102', '3-105', '91');INSERT INTO score VALUES ('104', '3-105', '89');-- 查询 score 表SELECT * FROM score;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 103 | 3-245 | 86 || 103 | 6-166 | 85 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5;+-------+| c_no |+-------+| 3-105 |+-------+ 根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号： 12345678SELECT t_no FROM course WHERE no IN ( SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5);+------+| t_no |+------+| 825 |+------+ 在 teacher 表中，根据筛选出来的教师编号找到教师姓名： 123456SELECT name FROM teacher WHERE no IN ( -- 最终条件 SELECT t_no FROM course WHERE no IN ( SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5 )); 子查询 - 3查询 “计算机系” 课程的成绩表。 思路是，先找出 course 表中所有 计算机系 课程的编号，然后根据这个编号查询 score 表。 123456789101112131415161718192021222324252627282930313233343536373839-- 通过 teacher 表查询所有 `计算机系` 的教师编号SELECT no, name, department FROM teacher WHERE department = '计算机系'+-----+--------+--------------+| no | name | department |+-----+--------+--------------+| 804 | 李诚 | 计算机系 || 825 | 王萍 | 计算机系 |+-----+--------+--------------+-- 通过 course 表查询该教师的课程编号SELECT no FROM course WHERE t_no IN ( SELECT no FROM teacher WHERE department = '计算机系');+-------+| no |+-------+| 3-245 || 3-105 |+-------+-- 根据筛选出来的课程号查询成绩表SELECT * FROM score WHERE c_no IN ( SELECT no FROM course WHERE t_no IN ( SELECT no FROM teacher WHERE department = '计算机系' ));+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-245 | 86 || 105 | 3-245 | 75 || 109 | 3-245 | 68 || 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 109 | 3-105 | 76 |+------+-------+--------+ UNION 和 NOTIN 的使用查询 计算机系 与 电子工程系 中的不同职称的教师。 123456789-- NOT: 代表逻辑非SELECT * FROM teacher WHERE department = '计算机系' AND profession NOT IN ( SELECT profession FROM teacher WHERE department = '电子工程系')-- 合并两个集UNIONSELECT * FROM teacher WHERE department = '电子工程系' AND profession NOT IN ( SELECT profession FROM teacher WHERE department = '计算机系'); ANY 表示至少一个 - DESC ( 降序 )查询课程 3-105 且成绩 至少 高于 3-245 的 score 表。 12345678910111213141516171819202122232425262728293031323334353637SELECT * FROM score WHERE c_no = '3-105';+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 109 | 3-105 | 76 |+------+-------+--------+SELECT * FROM score WHERE c_no = '3-245';+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-245 | 86 || 105 | 3-245 | 75 || 109 | 3-245 | 68 |+------+-------+--------+-- ANY: 符合SQL语句中的任意条件。-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，-- 最后根据降序查询结果。SELECT * FROM score WHERE c_no = '3-105' AND degree &gt; ANY( SELECT degree FROM score WHERE c_no = '3-245') ORDER BY degree DESC;+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 || 102 | 3-105 | 91 || 101 | 3-105 | 90 || 104 | 3-105 | 89 || 105 | 3-105 | 88 || 109 | 3-105 | 76 |+------+-------+--------+ 表示所有的 ALL查询课程 3-105 且成绩高于 3-245 的 score 表。 123456789101112131415-- 只需对上一道题稍作修改。-- ALL: 符合SQL语句中的所有条件。-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。SELECT * FROM score WHERE c_no = '3-105' AND degree &gt; ALL( SELECT degree FROM score WHERE c_no = '3-245');+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 103 | 3-105 | 92 || 104 | 3-105 | 89 || 105 | 3-105 | 88 |+------+-------+--------+ 复制表的数据作为条件查询查询某课程成绩比该课程平均成绩低的 score 表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344-- 查询平均分SELECT c_no, AVG(degree) FROM score GROUP BY c_no;+-------+-------------+| c_no | AVG(degree) |+-------+-------------+| 3-105 | 87.6667 || 3-245 | 76.3333 || 6-166 | 81.6667 |+-------+-------------+-- 查询 score 表SELECT degree FROM score;+--------+| degree |+--------+| 90 || 91 || 92 || 86 || 85 || 89 || 88 || 75 || 79 || 76 || 68 || 81 |+--------+-- 将表 b 作用于表 a 中查询数据-- score a (b): 将表声明为 a (b)，-- 如此就能用 a.c_no = b.c_no 作为条件执行查询了。SELECT * FROM score a WHERE degree &lt; ( (SELECT AVG(degree) FROM score b WHERE a.c_no = b.c_no));+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 105 | 3-245 | 75 || 105 | 6-166 | 79 || 109 | 3-105 | 76 || 109 | 3-245 | 68 || 109 | 6-166 | 81 |+------+-------+--------+ 子查询 - 4查询所有任课 ( 在 course 表里有课程 ) 教师的 name 和 department 。 123456789SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);+--------+-----------------+| name | department |+--------+-----------------+| 李诚 | 计算机系 || 王萍 | 计算机系 || 刘冰 | 电子工程系 || 张旭 | 电子工程系 |+--------+-----------------+ 条件加组筛选查询 student 表中至少有 2 名男生的 class 。 12345678910111213141516171819202122232425-- 查看学生表信息SELECT * FROM student;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 101 | 曾华 | 男 | 1977-09-01 | 95033 || 102 | 匡明 | 男 | 1975-10-02 | 95031 || 103 | 王丽 | 女 | 1976-01-23 | 95033 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 105 | 王芳 | 女 | 1975-02-10 | 95031 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 107 | 王尼玛 | 男 | 1976-02-20 | 95033 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 110 | 张飞 | 男 | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。SELECT class FROM student WHERE sex = '男' GROUP BY class HAVING COUNT(*) &gt; 1;+-------+| class |+-------+| 95033 || 95031 |+-------+ NOTLIKE 模糊查询取反查询 student 表中不姓 “王” 的同学记录。 1234567891011121314-- NOT: 取反-- LIKE: 模糊查询mysql&gt; SELECT * FROM student WHERE name NOT LIKE '王%';+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 101 | 曾华 | 男 | 1977-09-01 | 95033 || 102 | 匡明 | 男 | 1975-10-02 | 95031 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 110 | 张飞 | 男 | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+ YEAR 与 NOW 函数查询 student 表中每个学生的姓名和年龄。 12345678910111213141516-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;+-----------+------+| name | age |+-----------+------+| 曾华 | 42 || 匡明 | 44 || 王丽 | 43 || 李军 | 43 || 王芳 | 44 || 陆军 | 45 || 王尼玛 | 43 || 张全蛋 | 44 || 赵铁柱 | 45 || 张飞 | 45 |+-----------+------+ MAX 与 MIN 函数查询 student 表中最大和最小的 birthday 值。 123456SELECT MAX(birthday), MIN(birthday) FROM student;+---------------+---------------+| MAX(birthday) | MIN(birthday) |+---------------+---------------+| 1977-09-01 | 1974-06-03 |+---------------+---------------+ 多段排序以 class 和 birthday 从大到小的顺序查询 student 表。 123456789101112131415SELECT * FROM student ORDER BY class DESC, birthday;+-----+-----------+-----+------------+-------+| no | name | sex | birthday | class |+-----+-----------+-----+------------+-------+| 110 | 张飞 | 男 | 1974-06-03 | 95038 || 103 | 王丽 | 女 | 1976-01-23 | 95033 || 104 | 李军 | 男 | 1976-02-20 | 95033 || 107 | 王尼玛 | 男 | 1976-02-20 | 95033 || 101 | 曾华 | 男 | 1977-09-01 | 95033 || 106 | 陆军 | 男 | 1974-06-03 | 95031 || 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 || 105 | 王芳 | 女 | 1975-02-10 | 95031 || 108 | 张全蛋 | 男 | 1975-02-10 | 95031 || 102 | 匡明 | 男 | 1975-10-02 | 95031 |+-----+-----------+-----+------------+-------+ 子查询 - 5查询 “男” 教师及其所上的课程。 1234567SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex = '男');+-------+--------------+------+| no | name | t_no |+-------+--------------+------+| 3-245 | 操作系统 | 804 || 6-166 | 数字电路 | 856 |+-------+--------------+------+ MAX 函数与子查询查询最高分同学的 score 表。 1234567891011-- 找出最高成绩（该查询只能有一个结果）SELECT MAX(degree) FROM score;-- 根据上面的条件筛选出所有最高成绩表，-- 该查询可能有多个结果，假设 degree 值多次符合条件。SELECT * FROM score WHERE degree = (SELECT MAX(degree) FROM score);+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 103 | 3-105 | 92 |+------+-------+--------+ 子查询 - 6查询和 “李军” 同性别的所有同学 name 。 123456789101112131415161718192021222324-- 首先将李军的性别作为条件取出来SELECT sex FROM student WHERE name = '李军';+-----+| sex |+-----+| 男 |+-----+-- 根据性别查询 name 和 sexSELECT name, sex FROM student WHERE sex = ( SELECT sex FROM student WHERE name = '李军');+-----------+-----+| name | sex |+-----------+-----+| 曾华 | 男 || 匡明 | 男 || 李军 | 男 || 陆军 | 男 || 王尼玛 | 男 || 张全蛋 | 男 || 赵铁柱 | 男 || 张飞 | 男 |+-----------+-----+ 子查询 - 7查询和 “李军” 同性别且同班的同学 name 。 123456789101112SELECT name, sex, class FROM student WHERE sex = ( SELECT sex FROM student WHERE name = '李军') AND class = ( SELECT class FROM student WHERE name = '李军');+-----------+-----+-------+| name | sex | class |+-----------+-----+-------+| 曾华 | 男 | 95033 || 李军 | 男 | 95033 || 王尼玛 | 男 | 95033 |+-----------+-----+-------+ 子查询 - 8查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。 需要的 “计算机导论” 和性别为 “男” 的编号可以在 course 和 student 表中找到。 12345678910111213SELECT * FROM score WHERE c_no = ( SELECT no FROM course WHERE name = '计算机导论') AND s_no IN ( SELECT no FROM student WHERE sex = '男');+------+-------+--------+| s_no | c_no | degree |+------+-------+--------+| 101 | 3-105 | 90 || 102 | 3-105 | 91 || 104 | 3-105 | 89 || 109 | 3-105 | 76 |+------+-------+--------+ 按等级查询建立一个 grade 表代表学生的成绩等级，并插入数据： 12345678910111213141516171819202122CREATE TABLE grade ( low INT(3), upp INT(3), grade char(1));INSERT INTO grade VALUES (90, 100, 'A');INSERT INTO grade VALUES (80, 89, 'B');INSERT INTO grade VALUES (70, 79, 'C');INSERT INTO grade VALUES (60, 69, 'D');INSERT INTO grade VALUES (0, 59, 'E');SELECT * FROM grade;+------+------+-------+| low | upp | grade |+------+------+-------+| 90 | 100 | A || 80 | 89 | B || 70 | 79 | C || 60 | 69 | D || 0 | 59 | E |+------+------+-------+ 查询所有学生的 s_no 、c_no 和 grade 列。 思路是，使用区间 ( BETWEEN ) 查询，判断学生的成绩 ( degree ) 在 grade 表的 low 和 upp 之间。 123456789101112131415161718SELECT s_no, c_no, grade FROM score, grade WHERE degree BETWEEN low AND upp;+------+-------+-------+| s_no | c_no | grade |+------+-------+-------+| 101 | 3-105 | A || 102 | 3-105 | A || 103 | 3-105 | A || 103 | 3-245 | B || 103 | 6-166 | B || 104 | 3-105 | B || 105 | 3-105 | B || 105 | 3-245 | C || 105 | 6-166 | C || 109 | 3-105 | C || 109 | 3-245 | D || 109 | 6-166 | B |+------+-------+-------+ 连接查询准备用于测试连接查询的数据： 12345678910111213141516171819202122232425262728293031323334CREATE DATABASE testJoin;CREATE TABLE person ( id INT, name VARCHAR(20), cardId INT);CREATE TABLE card ( id INT, name VARCHAR(20));INSERT INTO card VALUES (1, '饭卡'), (2, '建行卡'), (3, '农行卡'), (4, '工商卡'), (5, '邮政卡');SELECT * FROM card;+------+-----------+| id | name |+------+-----------+| 1 | 饭卡 || 2 | 建行卡 || 3 | 农行卡 || 4 | 工商卡 || 5 | 邮政卡 |+------+-----------+INSERT INTO person VALUES (1, '张三', 1), (2, '李四', 3), (3, '王五', 6);SELECT * FROM person;+------+--------+--------+| id | name | cardId |+------+--------+--------+| 1 | 张三 | 1 || 2 | 李四 | 3 || 3 | 王五 | 6 |+------+--------+--------+ 分析两张表发现，person 表并没有为 cardId 字段设置一个在 card 表中对应的 id 外键。如果设置了的话，person 中 cardId 字段值为 6 的行就插不进去，因为该 cardId 值在 card 表中并没有。 内连接要查询这两张表中有关系的数据，可以使用 INNER JOIN ( 内连接 ) 将它们连接在一起。 123456789101112-- INNER JOIN: 表示为内连接，将两张表拼接在一起。-- on: 表示要执行某个条件。SELECT * FROM person INNER JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 |+------+--------+--------+------+-----------+-- 将 INNER 关键字省略掉，结果也是一样的。-- SELECT * FROM person JOIN card on person.cardId = card.id; 注意：card 的整张表被连接到了右边。 左外连接完整显示左边的表 ( person ) ，右边的表如果符合条件就显示，不符合则补 NULL 。 123456789-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。SELECT * FROM person LEFT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || 3 | 王五 | 6 | NULL | NULL |+------+--------+--------+------+-----------+ 右外链接完整显示右边的表 ( card ) ，左边的表如果符合条件就显示，不符合则补 NULL 。 12345678910SELECT * FROM person RIGHT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || NULL | NULL | NULL | 2 | 建行卡 || NULL | NULL | NULL | 4 | 工商卡 || NULL | NULL | NULL | 5 | 邮政卡 |+------+--------+--------+------+-----------+ 全外链接完整显示两张表的全部数据。 12345678910111213141516171819-- MySQL 不支持这种语法的全外连接-- SELECT * FROM person FULL JOIN card on person.cardId = card.id;-- 出现错误：-- ERROR 1054 (42S22): Unknown column 'person.cardId' in 'on clause'-- MySQL全连接语法，使用 UNION 将两张表合并在一起。SELECT * FROM person LEFT JOIN card on person.cardId = card.idUNIONSELECT * FROM person RIGHT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id | name | cardId | id | name |+------+--------+--------+------+-----------+| 1 | 张三 | 1 | 1 | 饭卡 || 2 | 李四 | 3 | 3 | 农行卡 || 3 | 王五 | 6 | NULL | NULL || NULL | NULL | NULL | 2 | 建行卡 || NULL | NULL | NULL | 4 | 工商卡 || NULL | NULL | NULL | 5 | 邮政卡 |+------+--------+--------+------+-----------+ 事务在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够保证一个业务的完整性。 比如我们的银行转账： 12345-- a -&gt; -100UPDATE user set money = money - 100 WHERE name = 'a';-- b -&gt; +100UPDATE user set money = money + 100 WHERE name = 'b'; 在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。 因此，在执行多条有关联 SQL 语句时，事务可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。 如何控制事务 - COMMIT / ROLLBACK在 MySQL 中，事务的自动提交状态默认是开启的。 1234567-- 查询事务的自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+| 1 |+--------------+ 自动提交的作用：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能回滚。 什么是回滚？举个例子： 123456789101112131415161718CREATE DATABASE bank;USE bank;CREATE TABLE user ( id INT PRIMARY KEY, name VARCHAR(20), money INT);INSERT INTO user VALUES (1, 'a', 1000);SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+ 可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它提交到了数据库中。那么所谓回滚的意思就是，撤销执行过的所有 SQL 语句，使其回滚到最后一次提交数据时的状态。 在 MySQL 中使用 ROLLBACK 执行回滚： 123456789-- 回滚到最后一次提交ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+ 由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？ 12345678910-- 关闭自动提交SET AUTOCOMMIT = 0;-- 查询自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+| 0 |+--------------+ 将自动提交关闭后，测试数据回滚： 1234567891011121314151617181920212223242526272829INSERT INTO user VALUES (2, 'b', 1000);-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，-- 发生变化的数据并没有真正插入到数据表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+-- 数据表中的真实数据其实还是：+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+-- 由于数据还没有真正提交，可以使用回滚ROLLBACK;-- 再次查询SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 |+----+------+-------+ 那如何将虚拟的数据真正提交到数据库中？使用 COMMIT : 12345678910111213141516INSERT INTO user VALUES (2, 'b', 1000);-- 手动提交数据（持久性），-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。COMMIT;-- 提交后测试回滚ROLLBACK;-- 再次查询（回滚无效了）SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+ 总结 自动提交 查看自动提交状态：SELECT @@AUTOCOMMIT ； 设置自动提交状态：SET AUTOCOMMIT = 0 。 手动提交 @@AUTOCOMMIT = 0 时，使用 COMMIT 命令提交事务。 事务回滚 @@AUTOCOMMIT = 0 时，使用 ROLLBACK 命令回滚事务。 事务的实际应用，让我们再回到银行转账项目： 12345678910111213-- 转账UPDATE user set money = money - 100 WHERE name = 'a';-- 到账UPDATE user set money = money + 100 WHERE name = 'b';SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 900 || 2 | b | 1100 |+----+------+-------+ 这时假设在转账时发生了意外，就可以使用 ROLLBACK 回滚到最后一次提交的状态： 12345678910-- 假设转账发生了意外，需要回滚。ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+ 这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：COMMIT 。 手动开启事务 - BEGIN / START TRANSACTION事务的默认提交被开启 ( @@AUTOCOMMIT = 1 ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚： 1234567891011121314151617181920212223242526-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务-- START TRANSACTION;BEGIN;UPDATE user set money = money - 100 WHERE name = 'a';UPDATE user set money = money + 100 WHERE name = 'b';-- 由于手动开启的事务没有开启自动提交，-- 此时发生变化的数据仍然是被保存在一张临时表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 900 || 2 | b | 1100 |+----+------+-------+-- 测试回滚ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 1000 || 2 | b | 1000 |+----+------+-------+ 仍然使用 COMMIT 提交数据，提交后无法再发生本次事务的回滚。 1234567891011121314151617BEGIN;UPDATE user set money = money - 100 WHERE name = 'a';UPDATE user set money = money + 100 WHERE name = 'b';SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+| 1 | a | 900 || 2 | b | 1100 |+----+------+-------+-- 提交数据COMMIT;-- 测试回滚（无效，因为表的数据已经被提交）ROLLBACK; 事务的 ACID 特征与使用事务的四大特征： A 原子性：事务是最小的单位，不可以再分割； C 一致性：要求同一事务中的 SQL 语句，必须保证同时成功或者失败； I 隔离性：事务1 和 事务2 之间是具有隔离性的； D 持久性：事务一旦结束 ( COMMIT ) ，就不可以再返回了 ( ROLLBACK ) 。 事务的隔离性事务的隔离性可分为四种 ( 性能从低到高 ) ： READ UNCOMMITTED ( 读取未提交 ) 如果有多个事务，那么任意事务都可以看见其他事务的未提交数据。 READ COMMITTED ( 读取已提交 ) 只能读取到其他事务已经提交的数据。 REPEATABLE READ ( 可被重复读 ) 如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。 SERIALIZABLE ( 串行化 ) 所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作。 查看当前数据库的默认隔离级别： 123456789101112-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。SELECT @@GLOBAL.TRANSACTION_ISOLATION;SELECT @@TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ | -- MySQL的默认隔离级别，可以重复读。+--------------------------------+-- MySQL 5.xSELECT @@GLOBAL.TX_ISOLATION;SELECT @@TX_ISOLATION; 修改隔离级别： 12345678910-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;-- 查询系统隔离级别，发现已经被修改。SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-UNCOMMITTED |+--------------------------------+ 脏读测试 READ UNCOMMITTED ( 读取未提交 ) 的隔离性： 1234567891011121314151617181920212223242526272829INSERT INTO user VALUES (3, '小明', 1000);INSERT INTO user VALUES (4, '淘宝店', 1000);SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+----+-----------+-------+-- 开启一个事务操作数据-- 假设小明在淘宝店买了一双800块钱的鞋子：START TRANSACTION;UPDATE user SET money = money - 800 WHERE name = '小明';UPDATE user SET money = money + 800 WHERE name = '淘宝店';-- 然后淘宝店在另一方查询结果，发现钱已到账。SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 200 || 4 | 淘宝店 | 1800 |+----+-----------+-------+ 由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 ROLLBACK 命令，会发生什么？ 12345678910111213-- 小明所处的事务ROLLBACK;-- 此时无论对方是谁，如果再去查询结果就会发现：SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+----+-----------+-------+ 这就是所谓的脏读，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。 读取已提交把隔离级别设置为 READ COMMITTED ： 1234567SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-COMMITTED |+--------------------------------+ 这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如： 12345678910111213141516171819202122232425262728293031-- 正在操作数据事务（当前事务）START TRANSACTION;UPDATE user SET money = money - 800 WHERE name = '小明';UPDATE user SET money = money + 800 WHERE name = '淘宝店';-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 200 || 4 | 淘宝店 | 1800 |+----+-----------+-------+-- 假设此时在远程开启了一个新事务，连接到数据库。$ mysql -u root -p12345612-- 此时远程连接查询到的数据只能是已经提交过的SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 |+----+-----------+-------+ 但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如： 1234567891011121314151617181920212223242526272829303132333435-- 小张在查询数据的时候发现：SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 200 || 4 | 淘宝店 | 1800 |+----+-----------+-------+-- 在小张求表的 money 平均值之前，小王做了一个操作：START TRANSACTION;INSERT INTO user VALUES (5, 'c', 100);COMMIT;-- 此时表的真实数据是：SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 |+----+-----------+-------+-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：SELECT AVG(money) FROM user;+------------+| AVG(money) |+------------+| 820.0000 |+------------+ 虽然 READ COMMITTED 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是在读取同一个表的数据时，可能会发生前后不一致的情况。这被称为不可重复读现象 ( READ COMMITTED ) 。 幻读将隔离级别设置为 REPEATABLE READ ( 可被重复读取 ) : 1234567SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ |+--------------------------------+ 测试 REPEATABLE READ ，假设在两个不同的连接上分别执行 START TRANSACTION : 123456789-- 小张 - 成都START TRANSACTION;INSERT INTO user VALUES (6, 'd', 1000);-- 小王 - 北京START TRANSACTION;-- 小张 - 成都COMMIT; 当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。 无论小张是否执行过 COMMIT ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录： 12345678910SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 |+----+-----------+-------+ 这是因为小王在此之前开启了一个新的事务 ( START TRANSACTION ) **，那么在他的这条新事务的线上，跟其他事务是没有联系的**，也就是说，此时如果其他事务正在操作数据，它是不知道的。 然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？ 12INSERT INTO user VALUES (6, 'd', 1000);-- ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY' 报错了，操作被告知已存在主键为 6 的字段。这种现象也被称为幻读，一个事务提交的数据，不能被其他事务读取到。 串行化顾名思义，就是所有事务的写入操作全都是串行化的。什么意思？把隔离级别修改成 SERIALIZABLE : 1234567SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| SERIALIZABLE |+--------------------------------+ 还是拿小张和小王来举例： 123456789101112131415161718192021-- 小张 - 成都START TRANSACTION;-- 小王 - 北京START TRANSACTION;-- 开启事务之前先查询表，准备操作数据。SELECT * FROM user;+----+-----------+-------+| id | name | money |+----+-----------+-------+| 1 | a | 900 || 2 | b | 1100 || 3 | 小明 | 1000 || 4 | 淘宝店 | 1000 || 5 | c | 100 || 6 | d | 1000 |+----+-----------+-------+-- 发现没有 7 号王小花，于是插入一条数据：INSERT INTO user VALUES (7, '王小花', 1000); 此时会发生什么呢？由于现在的隔离级别是 SERIALIZABLE ( 串行化 ) ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作 ( 这意味着队列中同时只能执行一个事务的写入操作 ) 。 根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 COMMIT 结束它所处的事务，或者出现等待超时。","link":"/2021/04/05/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"踩坑","slug":"踩坑","link":"/tags/%E8%B8%A9%E5%9D%91/"},{"name":"环境搭建","slug":"环境搭建","link":"/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"ftp","slug":"ftp","link":"/tags/ftp/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"ArrayList","slug":"ArrayList","link":"/tags/ArrayList/"},{"name":"hcl","slug":"hcl","link":"/tags/hcl/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"编译原理","slug":"编译原理","link":"/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"环境搭建","slug":"环境搭建","link":"/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"博客搭建","slug":"环境搭建/博客搭建","link":"/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"ftp配置","slug":"环境搭建/ftp配置","link":"/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ftp%E9%85%8D%E7%BD%AE/"},{"name":"组网技术","slug":"组网技术","link":"/categories/%E7%BB%84%E7%BD%91%E6%8A%80%E6%9C%AF/"},{"name":"深度学习","slug":"深度学习","link":"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"windows窗口程序","slug":"windows窗口程序","link":"/categories/windows%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/"},{"name":"c++安全学","slug":"c-安全学","link":"/categories/c-%E5%AE%89%E5%85%A8%E5%AD%A6/"},{"name":"cpp","slug":"cpp","link":"/categories/cpp/"},{"name":"c++ primer","slug":"cpp/c-primer","link":"/categories/cpp/c-primer/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}