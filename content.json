{"pages":[{"title":"目录","text":"","link":"/categories/index.html"},{"title":"关于","text":"等待更新……","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"83.删除排序链表中的重复元素","text":"给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例1： 12输入: 1-&gt;1-&gt;2输出: 1-&gt;2 这是一个简单的问题，仅测试你操作列表的结点指针的能力。由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。 12345678910111213class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode cur = head; while(cur != null &amp;&amp; cur.next != null){ if(cur.val == cur.next.val){ cur.next = cur.next.next; }else{ cur = cur.next; } } return head; }} 时间复杂度： 12时间复杂度：O(n)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为O(n)，其中 n 是链表表中的结点数。空间复杂度：O(1) 参考链接","link":"/2020/05/01/83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"title":"2.4 正规表达式到有限自动机的构造","text":"2.4.2 NFA确定化 $\\varepsilon$ 闭包的概念 子集法对NFA确定化","link":"/2020/04/28/2-4-%E6%AD%A3%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E6%9E%84%E9%80%A0/"},{"title":"Java关键字","text":"1 静态static关键字1.1 静态static关键字概述一旦用了static关键字修饰，那么这个元素就不再属于对象自己，而是属于类的，凡是本类的对象都共享同一份 比如下面的所在教室属性，用了static修饰，那么就属于这个学生类 2 private关键字2.1 概述问题描述：定义Person的年龄时，无法阻止不合理的数值被设置进来。解决方案：用private关键字将需要保护的成员变量进行修饰。 一旦使用了private进行修饰，那么本类当中仍然可以随意访问。但是！超出了本类范围之外就不能再直接访问了。 只可以间接访问private成员变量，就是定义一对儿Getter/Setter方法 1234567891011121314151617181920212223242526272829/*必须叫setXxx或者是getXxx命名规则。对于Getter来说，不能有参数，返回值类型和成员变量对应；对于Setter来说，不能有返回值，参数类型和成员变量对应。 */public class Person { String name; // 姓名 private int age; // 年龄 public void show() { System.out.println(\"我叫：\" + name + \"，年龄：\" + age); } // 这个成员方法，专门用于向age设置数据 public void setAge(int num) { if (num &lt; 100 &amp;&amp; num &gt;= 9) { // 如果是合理情况 age = num; } else { System.out.println(\"数据不合理！\"); } } // 这个成员方法，专门私语获取age的数据 public int getAge() { return age; }}","link":"/2020/05/06/Java%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"hexo、GitHubPage域名绑定","text":"1 域名解释在域名解释页面添加如下图所示记录 2 在source文件夹下新建CNAME文件里面写上自己的域名，如baidu.cn","link":"/2020/05/02/hexo%E3%80%81GitHubPage%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"},{"title":"InputStream和OutputStream","text":"1 例子 123456789101112131415161718192021222324import java.io.*;public class TestRead { public static void main(String[] args) throws IOException {//注意一定要抛出异常 String s; try (InputStream input = new FileInputStream(\"readme.c\")) {//1.创建 s = readAsString(input); } System.out.println(s); OutputStream output = new FileOutputStream(\"write.txt\");// 一、创建 output.write(s.getBytes(\"UTF-8\")); //二、调用方法 output.close(); } private static String readAsString(InputStream input) throws IOException { int n; StringBuilder sb = new StringBuilder(); while ((n = input.read()) != -1) {//2.使用方法 System.out.println(n); sb.append((char) n); } return sb.toString(); } }","link":"/2020/05/06/InputStream%E5%92%8COutputStream/"},{"title":"icarus主题gitalk评论配置踩坑","text":"1 在GitHub上面注册一个OAuth Apps获取相关的id和secret 2 在/Icarus/_config.yml下填写以下配置1234567comment: type: gitalk client_id: *******e35afa66dfd client_secret: ********eb0bf8c1 repo: username.github.io owner: username admin: [username] 3 遇到的错误我在写admin时直接写了username，结果报一下错误 1234567{keyword: 'type',dataPath: '.comment.admin',schemaPath: '/comment/gitalk.json/properties/admin/type',params: { type: 'array' },message: 'should be array'}, 错误是因为admin接收的时数组array而不是string。所以就算你可以正常应用，但还是会提示warn。 结果没看懂，这个错误，去GitHub问了Icarus原作者，才帮我指正，很谢谢原作者的指正。 参考资料 &lt;https://blog.zhangruipeng.me/hexo-theme-icarus/Plugins/Comment/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E7%94%A8%E6%88%B7%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#Gitalk&gt; icarus项目地址","link":"/2020/05/04/icarus%E4%B8%BB%E9%A2%98gitalk%E8%AF%84%E8%AE%BA%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/"},{"title":"java的api文档和Scanner类","text":"1 API概述 api概述 API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的 字典 ，是JDK中提供给 我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学 习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。 api使用步骤 打开帮助文档。 点击显示，找到索引，看到输入框。 你要找谁？在输入框里输入，然后回车。 看包。java.lang下的类不需要导包，其他需要。 看类的解释和说明。 学习构造方法。 使用成员方法。 2 引用类型的一般使用步骤 导包import 包路径.类名称;如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。只有java.lang包下的内容不需要导包，其他的包都需要import语句。 创建类名称 对象名 = new 类名称(); 使用对象名.成员方法名() 3 Scanner类12345678910111213141516171819202122232425262728package cn.itcast.day07.demo01;import java.util.Scanner; // 1. 导包/*Scanner类的功能：可以实现键盘输入数据，到程序当中。获取键盘输入的一个int数字：int num = sc.nextInt();获取键盘输入的一个字符串：String str = sc.next();遇到空格就会结束sc.nextLine();遇到Enter键才会结束 */public class Demo01Scanner { public static void main(String[] args) { // 2. 创建 // 备注：System.in代表从键盘进行输入 Scanner sc = new Scanner(System.in); // 3. 获取键盘输入的int数字 int num = sc.nextInt(); System.out.println(\"输入的int数字是：\" + num); // 4. 获取键盘输入的字符串 String str = sc.next(); System.out.println(\"输入的字符串是：\" + str); }}","link":"/2020/05/06/java%E7%9A%84api%E6%96%87%E6%A1%A3%E5%92%8CScanner%E7%B1%BB/"},{"title":"linux操作系统复习总结","text":"1操作系统概述1.1操作系统概述 从使用者角度看 程序开发者角度，调用操作系统的接口，如read（）函数，这些繁琐的操作留给操作系统 从所处位置看，操作系统是上层软件与硬件打交道的窗口和桥梁，是其他所有用户程序运行的基础 从设计者角度看，目标是让各种软件资源和硬件资源高效而协调地运转起来 操作系统的组成， 1. 2操作系统的发展 1946年宾夕法尼亚大学大学出现第一台通用计算机 第二代计算机，50s~60s，单道批处理系统 第三代计算机，60s中~70s初，多道批处理系统和分时系统和实时系统 四代，至今 软件角度下，操作系统的发展 单模块操作系统：进程管理，内存管理，设备管理，文件管理，通过调用函数交互，效率高，维护困难 微内核操作系统，用过通信机制交互，效率较低，维护简单 1.3开放源代码的Unix/Linux操作系统 Linux之父，linus torvalds linux遵循posix标准，所以流行 1.4Linux内核 内核子系统 进程调度 内存管理 虚拟文件系统 网络 进程间通信 1.5Linux内核源代码1.6Linux 内核模块编程入门1.7Linux 内核中链表的实现及应用2虚拟内存管理的硬件机制2.1内存寻址的演变 石器，8位寻址，Intel8080 青铜，16位寻址，Intel8086，段的引入 白银，保护模式的引入Intel80286 黄金，Intel80386，32位 常用寄存器 用于分页机制的控制寄存器 物理地址、虚拟地址及线性地址2.2段机制 段表 地址转换及保护2.3分页机制 页表 两级页表 线性地址到物理地址的转换 页面高速缓存2.4Linux中的分页机制2.5Linux中的汇编语言2.6Linux系统地址映射示例 3进程3.1进程介绍 程序和进程 进程层次结构 进程状态3.2进程控制块 信息分类 Linux进程状态及转换 进程标识符 进程之间的亲属关系 如何存放 3.3进程的组织方式 进程链表 哈希表 可运行队列 等待队列 等待队列的操作3.4进程调度 调度算法 时间片 调度时机 调度函数schedule( )-变量说明 调度程序的改进3.5进程的创建Fork()函数线程及其创建内核线程3.6与进程相关的系统调用及其应用3.7与调度相关的系统调用及应用4内存管理4.1Linux的内存管理内存的层次结构扩大了的记忆－虚拟内存虚地址到实地址转换虚拟内存、内核空间和用户空间Linux进程在虚拟内存中的标准内存段布局内核空间到物理内存的映射内核映像虚拟内存实现机制 4.2进程的用户空间管理mm_struct 结构VM_AREA_STRUCT 结构vm_operation结构创建进程用户空间虚存映射进程的虚存区举例与用户空间相关的主要系统调用mmap() 4.3请页机制实现虚存管理的重要手段页故障产生的原因缺页异常处理程序请求调页－动态内存分配技术写时复制 4.4物理内存的分配与回收物理页描述符 struct page结构页面分配与回收算法－伙伴算法物理页面的分配物理页面的回收Slab 分配机制－分配小内存通用缓冲区内核空间非连续内存区的分配vmalloc()与 kmalloc()之区别 4.5交换机制页面交换选择被换出的页面在交换区中存放页面页面交换策略页面交换守护进程kswapd 4.6内存管理实例5中断与异常5.1中断的基本知识中断源的类型外设可屏蔽中断异常及非屏蔽中断中断描述符表相关汇编指令 5.2中断描述符表的初始化IDT表项的设置初始化陷阱门和系统门中断门的设置 5.3中断处理中断和异常的硬件处理中断和异常处理中CPU的工作中断请求队列的建立中断服务例程与中断处理程序中断线共享的数据结构注册中断服务例程 5.4中断的下半部处理机制小任务机制工作队列机制下半部任务队列 5.5中断的应用－时钟中断时钟运作机制Linux时间系统时钟中断处理程序定时器及应用 6系统调用6.1系统调用与API、系统命令、内核函数系统调用与API系统调用与系统命令系统调用与内核函数系统调用与内核函数 6.2系统调用基本概念系统调用基本概念系统调用处理程序及服务例程 6.3系统调用实现调用一个系统调用初始化系统调用system_call( )函数参数传递跟踪系统调用的执行 6.4封装例程6.5添加新的系统调用6.6系统调用实例——日志收集7内核中的同步7.1临界区和竞争状态并发执行的原因临界区举例共享队列和加锁确定保护对象死 锁死锁的避免 7.2内核同步措施原子操作自旋锁信号量信号量与自旋锁的比较 7.3生产者-消费者并发实例7.4内核多任务并发实例内核任务及其之间的并发关系实现机制 8文件系统8.1Linux文件系统Linux的文件结构文件类型访问权限和文件模式软链接和硬链接安装文件系统 8.2虚拟文件系统虚拟文件系统的引入VFS中对象的演绎VFS超级块数据结构VFS的索引节点目录项对象目录项对象的数据结构与进程相关的文件结构 －文件对象文件对象数据结构的主要域与进程相关的文件结构 －用户打开文件表与进程相关的文件结构 － fs_struct结构主要数据结构间的关系 8.3文件系统的注册、安装与卸载文件系统的安装文件系统的卸载页缓冲区address_space对象的操作函数表 8.4文件的打开与读写generic_file_read()函数所执行的主要步骤从用户发出读请求到最终的从磁盘读取数据的步骤 8.5文件系统的编写Linux文件系统的实现要素什么是Romfs文件系统 9设备驱动9.1设备驱动概述9.2设备驱动程序设备驱动程序基础 9.3专用I/O端口I/O 端口设备文件中断处理用中断实现驱动程序的典型例子设备驱动程序框架 9.4字符设备驱动程序字符设备驱动程序的注册简单字符设备驱动程序举例 9.5块设备驱动程序块驱动程序的注册注册和注销一个驱动程序模块时所要调用的函数及数据结构块设备请求","link":"/2020/05/07/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"title":"win下ftp配置和使用","text":"1 用flashfxp连接ftp服务器与传输文件破解版下载地址： 链接：https://pan.baidu.com/s/1zY8vnCJvPBFycvZwV1L-pA提取码：kvhn 关于首次打开显示试用界面，点击输入代码按钮即可永久使用 解压缩后打开flashfxp.exe如下图所示： 左边是本地文件夹，右边是服务器文件夹，点击箭头那里输入相应信息进行连接。 然后就可以进入服务器的文件夹。就可以传输文件了。 2 服务器收作业时文件夹权限分配 在根文件夹普通权限只给用户列出文件的权限 每个作业的文件夹给以下三个权限 这样该用户就只能上传文件而不能执行其他操作，保证作业不会被抄袭。","link":"/2020/05/01/win%E4%B8%8Bftp%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"title":"关于markdown文件不能正常显示数学公式的解决方案","text":"Typora编辑器不能正常显示解决方法 latex是markdown的扩展语法，必须要打开内联公式。首先，打开偏好设置。 选择内联公式 然后重启Typora google浏览器不能正常显示下载相应插件： https://chrome.google.com/webstore/detail/tex-all-the-things/cbimabofgmfdkicghcadidpemeenbffn 参考链接","link":"/2020/04/28/%E5%85%B3%E4%BA%8Emarkdown%E6%96%87%E4%BB%B6%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"对象数组和ArrayList集合","text":"1 引入–对象数组使用学生数组，存储三个学生对象 123456789101112131415161718192021222324252627282930313233343536373839public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } publicvoid setName(String name) { this.name = name; } publicint getAge() { return age; } publicvoid setAge(int age) { this.age = age; }} public class Test01StudentArray { //创建学生数组 Student[] students = new Student[3]; //创建学生对象 Student s1 = new Student(\"曹操\",40); Student s2 = new Student(\"刘备\",35); Student s3 = new Student(\"孙权\",30); //把学生对象作为元素赋值给学生数组 students[0] = s1; students[1] = s2; students[2] = s3; //遍历学生数组 for(int x=0; x&lt;students.length; x++) { Student s = students[x]; System.out.println(s.getName()+\"‐‐‐\"+s.getAge()); }} 到目前为止，我们想存储对象数据，选择的容器，只有对象数组。而数组的长度是固定的，无法适应数据变化的需 求。为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对象数据。 2 ArrayList类2.1 基本概念和使用 查看类 java.util.ArrayList &lt;E&gt; ：该类需要 import导入使后使用。&lt;E&gt; ：表示一种指定的数据类型，叫做泛型。 E ，取自Element（元素）的首字母。在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。代码如下： ArrayList&lt;String&gt;，ArrayList&lt;Student&gt; 查看构造方法public ArrayList() ：构造一个内容为空的集合。 基本格式: ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 在JDK 7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。简化格式： ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); 查看成员方法public boolean add(E e) ： 将指定的元素添加到此集合的尾部。 参数 E e ，在构造ArrayList对象时， &lt;E&gt; 指定了什么数据类型，那么 add(E e) 方法中，只能添加什么数据 类型的对象。 例子 使用ArrayList类，存储三个字符串元素，代码如下： 1234567891011121314151617public class Test02StudentArrayList { public static void main(String[] args) { //创建学生数组 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //创建学生对象 String s1 = \"曹操\"; String s3 = \"孙权\"; //打印学生ArrayList集合 System.out.println(list); //把学生对象作为元素添加到集合 list.add(s1); list.add(s2); list.add(s3); //打印学生ArrayList集合 System.out.println(list); } } 2.2 常用方法和遍历对于元素的操作,基本体现在——增、删、查。 常用的方法有： public boolean add(E e) ：将指定的元素添加到此集合的尾部。 public E remove(int index) ：移除此集合中指定位置上的元素。返回被删除的元素。 public E get(int index) ：返回此集合中指定位置上的元素。返回获取的元素。 public int size() ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。 这些都是基本的方法，操作非常简单，代码如下: 12345678910111213141516171819202122public class Demo91ArrayListMethod{ public static void main(String[] args) { //创建集合对象 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add(\"hello\"); list.add(\"world\"); list.add(\"java\"); //public E get(int index):返回指定索引处的元素 System.out.println(\"get:\"+list.get(0)); System.out.println(\"get:\"+list.get(1)); System.out.println(\"get:\"+list.get(2)); //public int size():返回集合中的元素的个数 System.out.println(\"size:\"+list.size()); //public E remove(int index):删除指定索引处的元素，返回被删除的元素 System.out.println(\"remove:\"+list.remove(0)); //遍历输出 for(int i = 0; i &lt; list.size(); i++){ System.out.println(list.get(i)); } } } 2.3 ArrayList练习*数值添加到集合 * 生成6个1~33之间的随机整数,添加到集合,并遍历 12345678910111213141516public class Test01ArrayList { public static void main(String[] args) { // 创建Random 对象 Random random = new Random(); // 创建ArrayList 对 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 添加随机数到集合 for (int i = 0; i &lt; 6; i++) { int r = random.nextInt(33) + 1; list.add(r); } // 遍历集合输出 for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); } } }","link":"/2020/05/06/%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%92%8CArrayList%E9%9B%86%E5%90%88/"},{"title":"HCL静态聚合链路实验","text":"1 题目 2 我的预览图 3 配置sw1 配置与pc连接的口vlan10 sw1与sw3之间的trunk口 sw1与sw2之间的聚合链路，先配置聚合集，再配置trunk类型 验证聚合链路是否配置成功 在聚合链路组上配置trunk类型 3 配置sw3接口配置为trunk类型 4 pc1 ping pc2 5 pc2 https://xiaoheidiannao.com/articles/HCL-Link-Aggregation.html","link":"/2020/05/02/%E7%BB%84%E7%BD%91HCL%E9%9D%99%E6%80%81%E8%81%9A%E5%90%88%E9%93%BE%E8%B7%AF%E5%AE%9E%E9%AA%8C/"},{"title":"词法分析器实验","text":"源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140import java.io.*;import java.util.ArrayList;public class JunMingAnalysis { public static void main(String[] args) throws IOException { String s; InputStream input = new FileInputStream(\"source.c\"); s = readAsString(input); if (s.isEmpty()||s.toCharArray()[0]=='#') { System.out.println(\"源代码为空，无法进行词法分析！\"); return ; } Analysis analysis = new Analysis(s); analysis.JudgeState(0); ArrayList&lt;String&gt; token = analysis.getToken(); OutputStream output = new FileOutputStream(\"word.txt\"); for(int i = 0; i &lt; token.size(); i++){ System.out.println(token.get(i)); output.write(token.get(i).getBytes(\"UTF-8\")); } } private static String readAsString(InputStream input) throws IOException { int n; StringBuilder sb = new StringBuilder(); while ((n = input.read()) != -1) { sb.append((char) n); } return sb.toString(); }}class Analysis{ private static char[] sourceCode; //字符数组，等待解析的源程序 private char ch; private String s; private static ArrayList&lt;String&gt; token = new ArrayList&lt;&gt;();//存放解析结果 public Analysis(String s){ sourceCode = s.toCharArray(); } public void JudgeState(int curponter){ ch = sourceCode[curponter]; while((int)ch == 13 || (int)ch == 32 || (int)ch == 10){ ch = sourceCode[++curponter]; } if( ch == '#'){ System.out.println(\"end\"); }else if(isAlpha(ch)){ s = Character.toString(ch); ch = sourceCode[++curponter]; while(isAlpha(ch) || isDigital(ch)){ s = s + ch; ch = sourceCode[++curponter]; } if(!reserve(s)){ s = \"(id,\" + s + \")\"; token.add(s); } JudgeState(curponter); }else if(isDigital(ch)){ s = Character.toString(ch); ch = sourceCode[++curponter]; while(isDigital(ch)){ s = s + ch; ch = sourceCode[++curponter]; } s = \"(num,\" + s + \")\"; token.add(s); JudgeState(curponter); }else if(ch == '+'){ s = \"(+,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '-'){ s = \"(-,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '*'){ s = \"(*,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '{'){ s = \"({,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '}'){ s = \"(},null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '('){ s = \"((,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == ')'){ s = \"(),null)\"; token.add(s); JudgeState(++curponter); }else if(ch == ';'){ s = \"(;,null)\"; token.add(s); JudgeState(++curponter); }else if(ch == '='){ s = \"(=,null)\"; token.add(s); JudgeState(++curponter); }else { System.out.println(\"未收录字符:\" + ch); return; } } public ArrayList&lt;String&gt; getToken(){ return token; } private boolean isAlpha(char ch){ return Character.isLetter(ch); } private boolean isDigital(char ch){ return Character.isDigit(ch); } private boolean reserve(String s){ switch(s){ case \"while\": token.add(\"(while,null)\"); return true; case \"if\": token.add(\"(if,null)\"); return true; case \"main\": token.add(\"(main,null)\"); return true; case \"int\": token.add(\"(int,null)\"); return true; case \"return\": token.add(\"(return,null)\"); return true; default: return false; } }}","link":"/2020/05/07/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%AE%9E%E9%AA%8C/"},{"title":"facenet人脸识别算法训练","text":"实验环境 win10 tensorflow 1.12.0 anaconda3.6 facenet源码地址：https://github.com/davidsandberg/facenet 数据预处理下载数据集fw—&gt;链接：https://pan.baidu.com/s/1kH-OcCCAvLVLP1wEQxlvRg提取码：twmg 64_CASIA-FaceV5链接：https://pan.baidu.com/s/1vHk_BE6ycoz7ujPSvB9e9A提取码：20a7 CASIA-WebFace链接：https://pan.baidu.com/s/17m9Ym45g4km7VLCxedQ7GA提取码：c951 Celeba链接：https://pan.baidu.com/s/18RmCCj7uHfvtkmmb8LZoHw提取码：a6ug 用人脸检测模型检测并且剪裁出人脸","link":"/2020/05/15/facenet%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"},{"title":"基于ssd人脸检测训练实践","text":"实验环境 win10 tensorflow-gpu1.14.0 anaconda3.6 cuda10.0 cudnn7.6 数据预处理下载widerface数据集http://shuoyang1213.me/WIDERFACE/ 将数据打包成voc格式在我是在数据集下的相同目录下创建5个文件夹：JPEGImages：用来保存你的数据图片Annotations：这里是存放你对所有数据图片做的标注，每张照片的标注信息必须是xml格式ImageSets/Main：train.txt、val.txtTF-record:是将voc格式的数据转化成tfrecord文件的参考博客：https://blog.csdn.net/bingbign0607/article/details/105727746 运行：python widerface.py #文件名是widerface 注意文件夹的路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159import os,cv2,sys,shutil,numpyfrom xml.dom.minidom import Documentimport osdef writexml(filename, saveimg, bboxes, xmlpath): doc = Document() annotation = doc.createElement('annotation') doc.appendChild(annotation) folder = doc.createElement('folder') folder_name = doc.createTextNode('widerface') folder.appendChild(folder_name) annotation.appendChild(folder) filenamenode = doc.createElement('filename') filename_name = doc.createTextNode(filename) filenamenode.appendChild(filename_name) annotation.appendChild(filenamenode) source = doc.createElement('source') annotation.appendChild(source) database = doc.createElement('database') database.appendChild(doc.createTextNode('wider face Database')) source.appendChild(database) annotation_s = doc.createElement('annotation') annotation_s.appendChild(doc.createTextNode('PASCAL VOC2007')) source.appendChild(annotation_s) image = doc.createElement('image') image.appendChild(doc.createTextNode('flickr')) source.appendChild(image) flickrid = doc.createElement('flickrid') flickrid.appendChild(doc.createTextNode('-1')) source.appendChild(flickrid) owner = doc.createElement('owner') annotation.appendChild(owner) flickrid_o = doc.createElement('flickrid') flickrid_o.appendChild(doc.createTextNode('muke')) owner.appendChild(flickrid_o) name_o = doc.createElement('name') name_o.appendChild(doc.createTextNode('muke')) owner.appendChild(name_o) size = doc.createElement('size') annotation.appendChild(size) width = doc.createElement('width') width.appendChild(doc.createTextNode(str(saveimg.shape[1]))) height = doc.createElement('height') height.appendChild(doc.createTextNode(str(saveimg.shape[0]))) depth = doc.createElement('depth') depth.appendChild(doc.createTextNode(str(saveimg.shape[2]))) size.appendChild(width) size.appendChild(height) size.appendChild(depth) segmented = doc.createElement('segmented') segmented.appendChild(doc.createTextNode('0')) annotation.appendChild(segmented) for i in range(len(bboxes)): bbox = bboxes[i] objects = doc.createElement('object') annotation.appendChild(objects) object_name = doc.createElement('name') object_name.appendChild(doc.createTextNode('face')) objects.appendChild(object_name) pose = doc.createElement('pose') pose.appendChild(doc.createTextNode('Unspecified')) objects.appendChild(pose) truncated = doc.createElement('truncated') truncated.appendChild(doc.createTextNode('0')) objects.appendChild(truncated) difficult = doc.createElement('difficult') difficult.appendChild(doc.createTextNode('0')) objects.appendChild(difficult) bndbox = doc.createElement('bndbox') objects.appendChild(bndbox) xmin = doc.createElement('xmin') xmin.appendChild(doc.createTextNode(str(bbox[0]))) bndbox.appendChild(xmin) ymin = doc.createElement('ymin') ymin.appendChild(doc.createTextNode(str(bbox[1]))) bndbox.appendChild(ymin) xmax = doc.createElement('xmax') xmax.appendChild(doc.createTextNode(str(bbox[0] + bbox[2]))) bndbox.appendChild(xmax) ymax = doc.createElement('ymax') ymax.appendChild(doc.createTextNode(str(bbox[1] + bbox[3]))) bndbox.appendChild(ymax) f = open(xmlpath, \"w\") f.write(doc.toprettyxml(indent='')) f.close()rootdir = \"D:\\\\face\\\\dataset\\\\widerface\"gtfile = \"D:\\\\face\\\\dataset\\\\widerface\\\\wider_face_split\\\\\" \\ \"wider_face_val_bbx_gt.txt\";im_folder = \"D:\\\\face\\\\dataset\\\\widerface\\\\WIDER_val\\\\images\";##这里可以是test也可以是valfwrite = open(\"D:\\\\face\\\\dataset\\\\widerface\\\\ImageSets\\\\Main\\\\test.txt\", \"w\")with open(gtfile, \"r\") as gt: while(True): gt_con = gt.readline()[:-1] if gt_con is None or gt_con == \"\": break im_path = im_folder + \"/\" + gt_con; print(im_path) im_data = cv2.imread(im_path) if im_data is None: continue ##需要注意的一点是，图片直接经过resize之后，会存在更多的长宽比例，所以我们直接加pad sc = max(im_data.shape) im_data_tmp = numpy.zeros([sc, sc, 3], dtype=numpy.uint8) off_w = (sc - im_data.shape[1]) // 2 off_h = (sc - im_data.shape[0]) // 2 ##对图片进行周围填充，填充为正方形 im_data_tmp[off_h:im_data.shape[0]+off_h, off_w:im_data.shape[1]+off_w, ...] = im_data im_data = im_data_tmp # # cv2.imshow(\"1\", im_data) # cv2.waitKey(0) numbox = int(gt.readline()) #numbox = 0 bboxes = [] for i in range(numbox): line = gt.readline() infos = line.split(\" \") #x y w h --- #去掉最后一个（\\n） for j in range(infos.__len__() - 1): infos[j] = int(infos[j]) ##注意这里加入了数据清洗 ##保留resize到640×640 尺寸在8×8以上的人脸 if infos[2] * 80 &lt; im_data.shape[1] or infos[3] * 80 &lt; im_data.shape[0]: continue bbox = (infos[0] + off_w, infos[1] + off_h, infos[2], infos[3]) # cv2.rectangle(im_data, (int(infos[0]) + off_w, int(infos[1]) + off_h), # (int(infos[0]) + off_w + int(infos[2]), int(infos[1]) + off_h + int(infos[3])), # color=(0, 0, 255), thickness=1) bboxes.append(bbox) # cv2.imshow(\"1\", im_data) # cv2.waitKey(0) filename = gt_con.replace(\"/\", \"_\") fwrite.write(filename.split(\".\")[0] + \"\\n\") cv2.imwrite(\"{}/JPEGImages/{}\".format(rootdir, filename), im_data) xmlpath = \"{}/Annotations/{}.xml\".format(rootdir, filename.split(\".\")[0]) writexml(filename, im_data, bboxes, xmlpath)fwrite.close() 将voc数据转换成tfrecord格式参考博客:https://my.oschina.net/u/876354/blog/1927351 训练代码下载地址：https://github.com/balancap/SSD-Tensorflow 运行： 1python create_face_tf_record.py --data_dir=D:\\face\\dataset --year=widerface --output_path=D:\\face\\dataset\\widerface\\TF_data\\test.record --set=test 下载预训练模型链接：https://pan.baidu.com/s/1U9b7IlW6C4YDoFcLroL-DA提取码：idbz 训练模型12 参考博客:https://my.oschina.net/u/876354/blog/1927351 测试模型安装jupyter 运行: 1jupyter-notebook SSD-Tensorflow-master/ssd_notebook.ipynb 注意模型的路径命名 运行效果图","link":"/2020/05/10/%E5%9F%BA%E4%BA%8Essd%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E8%AE%AD%E7%BB%83%E5%AE%9E%E8%B7%B5/"},{"title":"Unit 01","text":"state12345graph LR;A[state n.] --&gt;B(statute) A --&gt; C(manifestation) A --&gt; D[assert] A --&gt; E[affirm]","link":"/2020/05/16/state/"},{"title":"HCL三层交换机配置路由","text":"开启交换机三层功能,配置合适的路由实现PC1能够ping通PC2，拓扑结构如下图所示 参考连接:https://www.xiaoheidiannao.com/HCL-Switch-Route.html","link":"/2020/05/22/HCL%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/"},{"title":"语法分析器","text":"1 实验目的掌握LR分析表的设计方法和语义加工程序的扩充 2 实验原理 自底向上的语法分析，从分析树的底部(叶节点)向顶部(根节点)方向构造分析树，可以看成是将输入串w归约为文法开始符号S的过程 自底向上语法分析的通用框架，移入-归约分析(Shift-Reduce Parsing)过程：在对输入串的一次从左到右扫描过程中，语法分析 器将零个或多个输入符号移入到栈的顶端，直到它可以对栈顶的一个文法符号串β进行归约为止。 然后，它将β归约为某个产生式的左部。 语法分析器不断地重复这个循环，直到它检测到一。 个语法错误，或者栈中包含了开始符号且输入缓冲 区为空(当进入这样的格局时，语法分析器停止运行， 并宣称成功完成了语法分析)为止。 增广文法(Augmented Grammar)，使得文法开始符号仅出现 在一个产生式的左边，从而使得分析器只有一个接受状态 FIRST ( X )：可以从X推导出的所有串首终结符构成的集合如果X ε，那么ε∈FIRST( X )。FOLLOW(A)：可能在某个句型中紧跟在A后边的终结符a的集合 FOLLOW(A)={a|S-&gt;*αAaβ, a∈VT，α,β∈(VT∪VN)} 如果A是某个句型的的最右符号，则将结束符“$”添加到FOLLOW(A)中。 构造LR(0)自动机的状态集，规范LR(0) 项集族(Canonical LR(0) Collection) SLR分析表,动作表 ACTION,转移表 GOTO sn：将符号a、状态n压入栈 rn：用第n个产生式进行归约 SLR分析表构造算法 SLR文法解决归约移入冲突的方法 已知项目集I： A1→α1.a1β1 A2→α2.a2β2 … Am→αm.amβm B1→γ1. B2→γ2. … Bn→γn. 如果集合{a1, a2, …, am}和 FOLLOW(B1)，FOLLOW(B2)，…， FOLLOW(Bn)两两不相交，则项目 集I中的冲突可以按以下原则解决： 设a是下一个输入符号 若a∈{ a1, a2, …, am}，则移进a 若a∈FOLLOW(Bi)，则用产生式 Bi→γi归约 此外，报错 3 实验环境Java Vscode 4 实验内容参照算术表达式LR分析表的设计方法，设计扩充后的算术表达式LR分析表，并对原语义加工程序修改，加入新添的内容。 算术表达式文法扩充如下： E→E+E| E-E|E*E |E/E| (E) | I 试根据该文法重新设计LR分析表，并修改语义加工程序，最后验证修改的结果。 增广文法G’为: 0) S-&gt;E 1) E-&gt;E+A 2) E-&gt;A 3) A-&gt;A-B 4) A-&gt;B 5) B-&gt;B*C 6) B-&gt;C 7) C-&gt;C/D 8) C-&gt;D 9) D-&gt;(E) 10) D-&gt;i 文法的first集和follow集 X First(X) S i ( E i ( A i ( B i ( C i ( D i ( X Follow(X) S $ E + $ ) A + - $ ) B + - * $ ) C + - * / $ ) D + - * / $ ) 自动机 SLR分析表 相关数据结构： 123456789private LinkedList&lt;Character&gt; list1 = new LinkedList&lt;Character&gt;();//保存输入字符串的列表private Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();//保存符号的栈,移入符号到该栈，用顶部的符号进行归约private Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;();//保存状态的栈，栈顶表示当前状态private Production production = new Production();//描述产生式的类private String[][] table//SLR分析表表的二维字符串数组 类设计: 5 实验结果分析输入： 12i**ii+i-i*(i/i) 输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596state symbol input action0 $ i**i$ Shift to state 707 $i **i$ Reduce by production 1005 $D **i$ Reduce by production 804 $C **i$ Reduce by production 603 $B **i$ Shift to state 10语法错误不符合SLR(1)文法\\-----------------------------------------在状态10，下一个符号*时，为空，所以出错state symbol input action0 $ i+i-i*(i/i)$ Shift to state 707 $i +i-i*(i/i)$ Reduce by production 1005 $D +i-i*(i/i)$ Reduce by production 804 $C +i-i*(i/i)$ Reduce by production 603 $B +i-i*(i/i)$ Reduce by production 402 $A +i-i*(i/i)$ Reduce by production 201 $E +i-i*(i/i)$ Shift to state 8018 $E+ i-i*(i/i)$ Shift to state 70187 $E+i -i*(i/i)$ Reduce by production 100185 $E+D -i*(i/i)$ Reduce by production 80184 $E+C -i*(i/i)$ Reduce by production 60183 $E+B -i*(i/i)$ Reduce by production 401813 $E+A -i*(i/i)$ Shift to state 9018139 $E+A- i*(i/i)$ Shift to state 70181397 $E+A-i *(i/i)$ Reduce by production 100181395 $E+A-D *(i/i)$ Reduce by production 80181394 $E+A-C *(i/i)$ Reduce by production 601813914 $E+A-B *(i/i)$ Shift to state 100181391410 $E+A-B* (i/i)$ Shift to state 601813914106 $E+A-B*( i/i)$ Shift to state 7018139141067 $E+A-B*(i /i)$ Reduce by production 10018139141065 $E+A-B*(D /i)$ Reduce by production 8018139141064 $E+A-B*(C /i)$ Shift to state 1101813914106411 $E+A-B*(C/ i)$ Shift to state 7018139141064117 $E+A-B*(C/i )$ Reduce by production 100181391410641116 $E+A-B*(C/D )$ Reduce by production 7018139141064 $E+A-B*(C )$ Reduce by production 6018139141063 $E+A-B*(B )$ Reduce by production 4018139141062 $E+A-B*(A )$ Reduce by production 20181391410612 $E+A-B*(E )$ Shift to state 17018139141061217 $E+A-B*(E) $ Reduce by production 901813914105 $E+A-B*D $ Reduce by production 8018139141015 $E+A-B*C $ Reduce by production 501813914 $E+A-B $ Reduce by production 301813 $E+A $ Reduce by production 101 $E $ accept语法正确，表达式符合SLR(1)文法\\-----------------------------------------实验结果与预期一致 6 实验总结 由于产生式是从0开始的，而我在规约时想成从1开始，从而导致归约时发生错误，如下图所示，状态13遇到+号时用了产生式3归约导致错误，my god让我又回到自动机推断了好久，我以为13是状态1和3，把我绕晕了，后来才理清思路， 导致分析表里的归约全都写错了 在状态7遇到$时忘记写上归约状态 导致归约时出错 后来我又按着自动机走了一遍并且查看follow集是否正确，才发现了错误 3.通过本次实验，使得我加深对自底向上分析方法的理解与操作，搞清楚了很多概念和算法，尤其是构造SLR1自动机和分析表，也使得我对栈链表等数据结构的使用更加熟练。 7 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.LinkedList;import java.util.Stack;public class JunMingAnalysis { private LinkedList&lt;Character&gt; list1 = new LinkedList&lt;Character&gt;();//保存输入字符串的列表 private Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();//保存符号的栈 private Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;();//保存状态的栈 private Production production = new Production();//描述产生式的类 private BufferedWriter output; private String temp1; private String actions = \"\"; //SLR分析表表的二维字符串数组 private String[][] table = { { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"2\", \"3\", \"4\", \"5\", \"1\" }, // 0 { \"\", \"S8\", \"\", \"\", \"\", \"\", \"\", \"accept\", \"\", \"\", \"\", \"\", \"\" }, // 1 { \"\", \"R2\", \"R9\", \"\", \"\", \"\", \"R2\", \"R2\", \"\", \"\", \"\", \"\", \"\" }, // 2 { \"\", \"R4\", \"R4\", \"S10\", \"\", \"\", \"R4\", \"R4\", \"\", \"\", \"\", \"\", \"\" },// 3 { \"\", \"R6\", \"R6\", \"R6\", \"S11\", \"\", \"R6\", \"R6\", \"\", \"\", \"\", \"\", \"\" },// 4 { \"\", \"R8\", \"R8\", \"R8\", \"R8\", \"\", \"R8\", \"R8\", \"\", \"\", \"\", \"\", \"\" },// 5 { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"2\", \"3\", \"4\", \"5\", \"12\" },// 6 { \"\", \"R10\", \"R10\", \"R10\", \"R10\", \"\", \"R10\", \"R10\", \"\", \"\", \"\", \"\", \"\" },// 7 { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"13\", \"3\", \"4\", \"5\", \"\" },// 8 { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"\", \"14\", \"4\", \"5\", \"\" },// 9 {\"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"\", \"\", \"15\", \"5\", \"\" },// 10 { \"S7\", \"\", \"\", \"\", \"\", \"S6\", \"\", \"\", \"\", \"\", \"\", \"16\", \"\" },// 11 { \"\", \"S8\", \"\", \"\", \"\", \"\", \"S17\", \"\", \"\", \"\", \"\", \"\", \"\" },//12 { \"\", \"R1\", \"S9\", \"\", \"\", \"\", \"R1\", \"R1\", \"\", \"\", \"\", \"\", \"\" },//13 { \"\", \"R3\", \"R3\", \"S10\", \"\", \"\", \"R3\", \"R3\", \"\", \"\", \"\", \"\", \"\" },//14 { \"\", \"R5\", \"R5\", \"R5\", \"S11\", \"\", \"R5\", \"R5\", \"\", \"\", \"\", \"\", \"\" },//15 { \"\", \"R7\", \"R7\", \"R7\", \"R7\", \"\", \"R7\", \"R7\", \"\", \"\", \"\", \"\", \"\" },//16 { \"\", \"R9\", \"R9\", \"R9\", \"R9\", \"\", \"R9\", \"R9\", \"\", \"\", \"\", \"\", \"\" },//17 }; public JunMingAnalysis() { try { output = new BufferedWriter(new FileWriter(\"output.txt\")); } catch (IOException e) { e.printStackTrace(); } } public void getText() { char a[]; BufferedReader bufferedReader = null; try { bufferedReader = new BufferedReader(new FileReader(\"input.txt\")); String lString; while ((lString = bufferedReader.readLine()) != null) { //数据预处理 stack.clear(); list1.clear(); stack2.clear(); temp1 = lString.trim(); temp1.replaceAll(\"\\\\s+\", \"\");// 去掉一个以上的空白符，用一个空白代替 a = temp1.toCharArray(); for (char _char : a) { list1.offer(_char); } list1.offerLast('$'); stack.push('$'); stack2.push(0); output.write(\"state\\t symbol\\t input\\t action\"); output.newLine(); boolean b = analysis(); if (b){ output.write(\"语法正确，表达式符合SLR(1)文法\"); output.newLine(); } else{ output.write(\"语法错误不符合SLR(1)文法\"); output.newLine(); } output.write(\"-----------------------------------------\"); output.newLine(); } } catch (Exception e) { } finally { // 关闭资源 if (bufferedReader != null) try { bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } if (output != null) try { output.close(); } catch (Exception e2) { } } } public int getOrder(char c) { //获取符号（终结符或非终结符）的编号（符号表中的横向顺序） if (c == 'i') return 0; else if (c == '+') return 1; else if (c == '-') return 2; else if (c == '*') return 3; else if (c == '/') return 4; else if (c == '(') return 5; else if (c == ')') return 6; else if (c == '$') return 7; else if(c=='A') return 8; else if(c=='B') return 9; else if(c=='C') return 10; else if(c=='D') return 11; else if(c=='E') return 12; else return -1; } public void display() { //读SymbolStack、StateStack和input里的所有字符，显示到输出文件 String symbols = \"\"; String states = \"\"; String input = \"\"; Object[] symbolObjects = stack.toArray(); for (int i = 0; i &lt; symbolObjects.length; i++) { symbols += symbolObjects[i].toString(); } Object[] stateObjects = stack2.toArray(); for (int i = 0; i &lt; stack2.size(); i++) { states += stateObjects[i].toString(); } Object[] inputObjects = list1.toArray(); for (int i = 0; i &lt; list1.size(); i++) { input += inputObjects[i].toString(); } try { output.write(states + \"\\t\" + symbols + \"\\t\" + input + \"\\t\" + actions); output.newLine(); } catch (IOException e) { e.printStackTrace(); } } public boolean analysis() { while (true) { actions = \"\"; char c = list1.peekFirst(); int i = getOrder(c); if(i==-1) //如果输入是除了规定的终结符和非终结符以外的符号，返回false return false; String string2 = table[stack2.peek()][i]; if (string2.trim().equals(\"\".trim())) return false; else if (string2.equals(\"accept\")) {//接收 actions+=\"accept\"; display(); return true; } else if (string2.charAt(0) == 'S') { // 移进 String s = string2.substring(1); // 取S后面的状态数 int n = Integer.parseInt(s); System.out.println(\"Shift \" + s); actions += \"Shift to state \" + s; display(); list1.pollFirst(); // 从输入带里弹出第一个字符，并把该字符送symbolStack,同时向StateStack压入取得的状态数 stack2.push(n); stack.push(c); } else if (string2.charAt(0) == 'R') { // 规约 String s = string2.substring(1); // 取r后面的产生式编号 int n = Integer.parseInt(s); System.out.println(\"Reduce \" + s); actions += \"Reduce by production \" + s; display(); int n2 = production.getNumOfP(n);// 取产生式右部的字符个数（应该在SymbolStack和StateStack中弹出来的个数） for (int i1 = 0; i1 &lt; n2; i1++) { stack.pop(); stack2.pop(); } char _char1 = production.getProduction(n).charAt(0);// 获取产生式左边的非终结符，压入SymbolStack stack.push(_char1); String s1 = table[stack2.peek()][getOrder(_char1)];// 查找goto字表，找到该终结符和当前状态对应的编号，压入StateStack if (s1.trim().equals(\"\")) return false; else stack2.push(Integer.parseInt(s1)); } } } public static void main(String[] args) { JunMingAnalysis ananlyzer = new JunMingAnalysis(); ananlyzer.getText(); }}public class Production { private String[] productions={\"S-&gt;E\",\"E-&gt;E+A\",\"E-&gt;A\",\"A-&gt;A-B\",\"A-&gt;B\",\"B-&gt;B*C\",\"B-&gt;C\",\"C-&gt;C/D\",\"C-&gt;D\",\"D-&gt;(E)\",\"D-&gt;i\"}; private int[] numOfP={1,3,1,3,1,3,1,3,1,3,1}; public String getProduction(int i){ return productions[i]; } public int getNumOfP(int i){ return numOfP[i]; }} ​ 资源地址：https://github.com/Jmlong23/note_src/tree/master/doc/CompilationPrinciple/exp2","link":"/2020/05/31/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"},{"title":"Google浏览器被恶意网站劫持","text":"解决方案如下图： 参考链接：https://blog.csdn.net/qq_32635971/article/details/72793115","link":"/2020/06/05/Google%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A2%AB%E6%81%B6%E6%84%8F%E7%BD%91%E7%AB%99%E5%8A%AB%E6%8C%81/"},{"title":"hcl配置路由器dhcp和acl","text":"配置合适的ACL,实现PC1可以访问telnetserver但是PC1不可以远程登录telnetserver,拓扑结构如下所示: 参考链接：https://www.xiaoheidiannao.com/HCL-DHCP.html 参考链接：https://www.xiaoheidiannao.com/HCL-ACL.html","link":"/2020/06/16/hcl%E9%85%8D%E7%BD%AEdhcp%E5%92%8Cacl/"},{"title":"hcl路由器ospf和交换机rip配置","text":"实现RT1和RT3的两个环回路lo0互相之间可以通信 实现SW1和SW3的两个环回路lo0互相之间可以通信 注意sw1时network那里错了,应该是172.16.1.1 然后，port的时候还应该有其他信息，没有信息，应该重启一下交换机，因为后来改了的时候没有截图，命令都差不多就放这些图片了。 参考链接： https://www.xiaoheidiannao.com/HCL-Switch-RIP-Configuration.html https://www.xiaoheidiannao.com/HCL-Router-OSPF-Configuration.html","link":"/2020/06/05/hcl%E8%B7%AF%E7%94%B1%E5%99%A8ospf%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BArip%E9%85%8D%E7%BD%AE/"},{"title":"hexo d出现错误","text":"hexo d 部署时出现以下错误1234567fatal: unable to access 'https://github.com/Jmlong23/Jmlong23.github.io.git/': Failed to connect to github.com port 443: Timed outFATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (D:\\blog\\blog\\node_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (events.js:310:20) at ChildProcess.cp.emit (D:\\blog\\blog\\node_modules\\cross-spawn\\lib\\enoent.js:34:29) at Process.ChildProcess._handle.onexit (internal/child_process.js:275:12) 解决方法用以下配置，我也不知道为什么 1git config --global http.proxy http://127.0.0.1:1080 参考链接：https://github.com/jeffsui/jeffsui.github.io/issues/76","link":"/2020/06/04/hexo-d%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF/"},{"title":"friends S03E5","text":"","link":"/2020/06/17/friends-S03E5/"},{"title":"安装openssl和gmssl","text":"参考链接：https://blog.csdn.net/apianmuse/article/details/107353574 一、安装openssl直接安装下载地址，一直下一步 https://slproweb.com/products/Win32OpenSSL.html 测试 二、安装gmssl1 下载Strawberry PerlActiveState Perl和 Strawberry Perl最大的区别是 Strawberry Perl 里面有多包含一些 CPAN 里的模块， 所以Strawberry Perl 下载的安装文件有 80多M, 而ActiveState Perl 只有20M 左右。 下载链接：http://strawberryperl.com/ 2 下载gmsslhttp://gmssl.org/docs/quickstart.html 3 NASM下载地址：&lt;www.nasm.us&gt;4 perl Configure VC-WIN32时出错This issue is due to the Perl package File::Glob, 一些简单的修改就能修复这个. 在 Configure文件和 test/build.info这个文件,把 123use if $^O ne &quot;VMS&quot;, 'File::Glob' =&gt; qw/glob/;改成use if $^O ne &quot;VMS&quot;, 'File::Glob' =&gt; qw/:glob/; https://www.xiaoheidiannao.com/211129.html 5 nmake时出错libcrypto.* libcrypto-1_1.* &amp;&amp; EXIT 1)libcrypto-1_1.def : error LNK2001: 无法解析的外部符号 EVP_get_ciphernameslibcrypto-1_1.def : error LNK2001: 无法解析的外部符号 EVP_get_digestnameslibcrypto.lib : fatal error LNK1120: 2 个无法解析的外部命令NMAKE : fatal error U1077: “link”: 返回代码“0x1 解决方法： https://github.com/guanzhi/GmSSL/issues/992 6 nmake install关于glob的错误，未找到解决方法 测试，安装成功在C:\\Program Files (x86)\\GmSSL目录下","link":"/2020/09/21/%E5%AE%89%E8%A3%85openssl%E5%92%8Cgmssl/"},{"title":"用openssl对代码进行签名和验证的例子跑通","text":"参考例子： 源码：https://gist.github.com/irbull/08339ddcd5686f509e9826964b17bb59 源码解析：https://eclipsesource.com/blogs/2016/09/07/tutorial-code-signing-and-verification-with-openssl/ 一、vs2019项目属性配置项目目录，把openssl的bin、lib、include目录拷贝进来 引入include目录../../include 引入lib目录../../lib 导入lib里面的libcrypto.lib文件名 这部要留意，如果显示“无法解析的外部符号 _BIO_new，函数 “void __cdecl Base64Decode(char const *,unsigned char * *,unsigned int *)” (?Base64Decode@@YAXPBDPAPAEPAI@Z) 中引用了该符号”的错误就是没有导入该文件。 运行结果图： 二、原理代码签名和验证代码签名和验证是对可执行文件或脚本进行数字签名的过程，以确保您执行的软件自签名以来没有被更改。代码签名有助于防止损坏的工件，进程崩溃（意外传送错误的东西），甚至恶意意图。 代码签名和验证的工作原理如下，作者还以代码为输入执行 哈希函数，从而产生 摘要。摘要使用作者的私钥进行进行加密，得到数字签名。然后，将代码，数字签名和哈希函数传递给验证者。验证者使用相同的哈希函数从代码生成摘要，然后使用公钥解密签名。如果两个摘要都匹配，则验证者可以确信代码未被篡改。 生成密钥https://cloud.tencent.com/developer/article/1622834 1234567891011121314151617181920212223242526272829生成私钥openssl.exe genrsa -out rsa.private 1024-----BEGIN RSA PRIVATE KEY-----MIICXQIBAAKBgQC6gR460tNZV9+rjeC46Jlba6vcwgPHlh0kWdebg+/lkR5uYs3WesBmlox7W1mFfWbv93X2WTVMdVbo/MteKKR2A4Hs7+kg+BFriXhdyCazBhP5ts9fvSQUOjGjq/hI6q6oIKOfXNez1VQ5SfNKGO6grFvQq2pmrO/SyQOh2BK7XwIDAQABAoGAbtFbwf4VYOfq2kfSOGzU+tJOazzI/CXBKSFNEHXj7Jc+6r5AqmmDuzFHReDwn3X03S8/42H8XnL2cjgLKuahWQzvyCltBRYsWU/lFGg2baGsnEEeuq5OgTZZ0z5WNKAL31u8XBFlv5sCuFGu3e71ggnenkMl4GMdjx3mnMdOLpkCQQDzQxKrOhMztN5WrDzTav85+RjGFQAtSw41lwACp0+lzj+Q2rWIBl/Lt4h1Ov9MXVAaEHtyYS6DyIvdvNCIvOB7AkEAxEU1hXM7r3xuuDOzbIHCe6giveQZntDNcwIkzrg9Nc48MH1BBJeuMGWVvJQp6rab/Ih73Cnc0iwsVKClw5JFbQJBALf6CTuAj5cyelk4qEQJDwAsWUUuCtU2h4eWLQbUvNMcWkzWbCZ1E6xBoS1wMjbx96vOvV4zC3fVi5pmu5w+pNMCQQCN81xFO1V0kzNkyAfBt4uYcb9GxX1+LpgY0PkcBYZHrvQ7QavPjYBvAlmsvSAf4JiqqW+jiSdrXoVlY5bf/p91AkAwHhRLuUxplgQcyRkEXzHud5znBiOKdpztI+ngTiWOFiaC6rRtqJYJnPphqtHp4jns7nOYmy8mzJDKGmwsdCXj-----END RSA PRIVATE KEY-----生成公钥openssl.exe rsa -in rsa.private -out rsa.public -pubout -outform PEM-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC6gR460tNZV9+rjeC46Jlba6vcwgPHlh0kWdebg+/lkR5uYs3WesBmlox7W1mFfWbv93X2WTVMdVbo/MteKKR2A4Hs7+kg+BFriXhdyCazBhP5ts9fvSQUOjGjq/hI6q6oIKOfXNez1VQ5SfNKGO6grFvQq2pmrO/SyQOh2BK7XwIDAQAB-----END PUBLIC KEY----- 数字签名数字签名在发送方，分两步： （1）从内容算摘要（哈希算法） （2）从摘要明文到摘要密文，也称数字签名（发送方私钥+加密算法） 数字验证数字签名验证在接收方，分两步： （1）从摘要密文（数字签名）到摘要明文（发送方公钥+解密算法） （2）从收到的内容当场计算摘要（哈希算法），与（1）的结果比对是否一致 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &lt;iostream&gt;#include &lt;openssl/aes.h&gt;#include &lt;openssl/evp.h&gt;#include &lt;openssl/rsa.h&gt;#include &lt;openssl/pem.h&gt;#include &lt;openssl/ssl.h&gt;#include &lt;openssl/bio.h&gt;#include &lt;openssl/err.h&gt;#include &lt;assert.h&gt;std::string privateKey = &quot;-----BEGIN RSA PRIVATE KEY-----\\n&quot;\\&quot;MIIEowIBAAKCAQEAy8Dbv8prpJ/0kKhlGeJYozo2t60EG8L0561g13R29LvMR5hy\\n&quot;\\&quot;vGZlGJpmn65+A4xHXInJYiPuKzrKUnApeLZ+vw1HocOAZtWK0z3r26uA8kQYOKX9\\n&quot;\\&quot;Qt/DbCdvsF9wF8gRK0ptx9M6R13NvBxvVQApfc9jB9nTzphOgM4JiEYvlV8FLhg9\\n&quot;\\&quot;yZovMYd6Wwf3aoXK891VQxTr/kQYoq1Yp+68i6T4nNq7NWC+UNVjQHxNQMQMzU6l\\n&quot;\\&quot;WCX8zyg3yH88OAQkUXIXKfQ+NkvYQ1cxaMoVPpY72+eVthKzpMeyHkBn7ciumk5q\\n&quot;\\&quot;gLTEJAfWZpe4f4eFZj/Rc8Y8Jj2IS5kVPjUywQIDAQABAoIBADhg1u1Mv1hAAlX8\\n&quot;\\&quot;omz1Gn2f4AAW2aos2cM5UDCNw1SYmj+9SRIkaxjRsE/C4o9sw1oxrg1/z6kajV0e\\n&quot;\\&quot;N/t008FdlVKHXAIYWF93JMoVvIpMmT8jft6AN/y3NMpivgt2inmmEJZYNioFJKZG\\n&quot;\\&quot;X+/vKYvsVISZm2fw8NfnKvAQK55yu+GRWBZGOeS9K+LbYvOwcrjKhHz66m4bedKd\\n&quot;\\&quot;gVAix6NE5iwmjNXktSQlJMCjbtdNXg/xo1/G4kG2p/MO1HLcKfe1N5FgBiXj3Qjl\\n&quot;\\&quot;vgvjJZkh1as2KTgaPOBqZaP03738VnYg23ISyvfT/teArVGtxrmFP7939EvJFKpF\\n&quot;\\&quot;1wTxuDkCgYEA7t0DR37zt+dEJy+5vm7zSmN97VenwQJFWMiulkHGa0yU3lLasxxu\\n&quot;\\&quot;m0oUtndIjenIvSx6t3Y+agK2F3EPbb0AZ5wZ1p1IXs4vktgeQwSSBdqcM8LZFDvZ\\n&quot;\\&quot;uPboQnJoRdIkd62XnP5ekIEIBAfOp8v2wFpSfE7nNH2u4CpAXNSF9HsCgYEA2l8D\\n&quot;\\&quot;JrDE5m9Kkn+J4l+AdGfeBL1igPF3DnuPoV67BpgiaAgI4h25UJzXiDKKoa706S0D\\n&quot;\\&quot;4XB74zOLX11MaGPMIdhlG+SgeQfNoC5lE4ZWXNyESJH1SVgRGT9nBC2vtL6bxCVV\\n&quot;\\&quot;WBkTeC5D6c/QXcai6yw6OYyNNdp0uznKURe1xvMCgYBVYYcEjWqMuAvyferFGV+5\\n&quot;\\&quot;nWqr5gM+yJMFM2bEqupD/HHSLoeiMm2O8KIKvwSeRYzNohKTdZ7FwgZYxr8fGMoG\\n&quot;\\&quot;PxQ1VK9DxCvZL4tRpVaU5Rmknud9hg9DQG6xIbgIDR+f79sb8QjYWmcFGc1SyWOA\\n&quot;\\&quot;SkjlykZ2yt4xnqi3BfiD9QKBgGqLgRYXmXp1QoVIBRaWUi55nzHg1XbkWZqPXvz1\\n&quot;\\&quot;I3uMLv1jLjJlHk3euKqTPmC05HoApKwSHeA0/gOBmg404xyAYJTDcCidTg6hlF96\\n&quot;\\&quot;ZBja3xApZuxqM62F6dV4FQqzFX0WWhWp5n301N33r0qR6FumMKJzmVJ1TA8tmzEF\\n&quot;\\&quot;yINRAoGBAJqioYs8rK6eXzA8ywYLjqTLu/yQSLBn/4ta36K8DyCoLNlNxSuox+A5\\n&quot;\\&quot;w6z2vEfRVQDq4Hm4vBzjdi3QfYLNkTiTqLcvgWZ+eX44ogXtdTDO7c+GeMKWz4XX\\n&quot;\\&quot;uJSUVL5+CVjKLjZEJ6Qc2WZLl94xSwL71E41H4YciVnSCQxVc4Jw\\n&quot;\\&quot;-----END RSA PRIVATE KEY-----\\n\\0&quot;;std::string publicKey = &quot;-----BEGIN PUBLIC KEY-----\\n&quot;\\&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAy8Dbv8prpJ/0kKhlGeJY\\n&quot;\\&quot;ozo2t60EG8L0561g13R29LvMR5hyvGZlGJpmn65+A4xHXInJYiPuKzrKUnApeLZ+\\n&quot;\\&quot;vw1HocOAZtWK0z3r26uA8kQYOKX9Qt/DbCdvsF9wF8gRK0ptx9M6R13NvBxvVQAp\\n&quot;\\&quot;fc9jB9nTzphOgM4JiEYvlV8FLhg9yZovMYd6Wwf3aoXK891VQxTr/kQYoq1Yp+68\\n&quot;\\&quot;i6T4nNq7NWC+UNVjQHxNQMQMzU6lWCX8zyg3yH88OAQkUXIXKfQ+NkvYQ1cxaMoV\\n&quot;\\&quot;PpY72+eVthKzpMeyHkBn7ciumk5qgLTEJAfWZpe4f4eFZj/Rc8Y8Jj2IS5kVPjUy\\n&quot;\\&quot;wQIDAQAB\\n&quot;\\&quot;-----END PUBLIC KEY-----\\n&quot;;RSA* createPrivateRSA(std::string key) { RSA* rsa = NULL; const char* c_string = key.c_str(); BIO* keybio = BIO_new_mem_buf((void*)c_string, -1); if (keybio == NULL) { return 0; } rsa = PEM_read_bio_RSAPrivateKey(keybio, &amp;rsa, NULL, NULL); return rsa;}RSA* createPublicRSA(std::string key) { RSA* rsa = NULL; BIO* keybio; const char* c_string = key.c_str(); keybio = BIO_new_mem_buf((void*)c_string, -1); if (keybio == NULL) { return 0; } rsa = PEM_read_bio_RSA_PUBKEY(keybio, &amp;rsa, NULL, NULL); return rsa;}//With an RSA object and plaintext you can create the digest and binary digital signature:bool RSASign(RSA* rsa, const unsigned char* Msg, size_t MsgLen, unsigned char** EncMsg, size_t* MsgLenEnc) { EVP_MD_CTX* m_RSASignCtx = EVP_MD_CTX_create(); EVP_PKEY* priKey = EVP_PKEY_new(); EVP_PKEY_assign_RSA(priKey, rsa); if (EVP_DigestSignInit(m_RSASignCtx, NULL, EVP_sha256(), NULL, priKey) &lt;= 0) { return false; } if (EVP_DigestSignUpdate(m_RSASignCtx, Msg, MsgLen) &lt;= 0) { return false; } if (EVP_DigestSignFinal(m_RSASignCtx, NULL, MsgLenEnc) &lt;= 0) { return false; } *EncMsg = (unsigned char*)malloc(*MsgLenEnc); if (EVP_DigestSignFinal(m_RSASignCtx, *EncMsg, MsgLenEnc) &lt;= 0) { return false; } EVP_MD_CTX_free(m_RSASignCtx); return true;}//with the RSA object, original message and binary encoded signature, you can verify that the signature matches the plain text.bool RSAVerifySignature(RSA* rsa, unsigned char* MsgHash, size_t MsgHashLen, const char* Msg, size_t MsgLen, bool* Authentic) { *Authentic = false; EVP_PKEY* pubKey = EVP_PKEY_new(); EVP_PKEY_assign_RSA(pubKey, rsa); EVP_MD_CTX* m_RSAVerifyCtx = EVP_MD_CTX_create(); if (EVP_DigestVerifyInit(m_RSAVerifyCtx, NULL, EVP_sha256(), NULL, pubKey) &lt;= 0) { return false; } if (EVP_DigestVerifyUpdate(m_RSAVerifyCtx, Msg, MsgLen) &lt;= 0) { return false; } int AuthStatus = EVP_DigestVerifyFinal(m_RSAVerifyCtx, MsgHash, MsgHashLen); if (AuthStatus == 1) { *Authentic = true; EVP_MD_CTX_free(m_RSAVerifyCtx); return true; } else if (AuthStatus == 0) { *Authentic = false; EVP_MD_CTX_free(m_RSAVerifyCtx); return true; } else { *Authentic = false; EVP_MD_CTX_free(m_RSAVerifyCtx); return false; }}void Base64Encode(const unsigned char* buffer, size_t length, char** base64Text) { BIO* bio, * b64; BUF_MEM* bufferPtr; b64 = BIO_new(BIO_f_base64()); bio = BIO_new(BIO_s_mem()); bio = BIO_push(b64, bio); BIO_write(bio, buffer, length); BIO_flush(bio); BIO_get_mem_ptr(bio, &amp;bufferPtr); BIO_set_close(bio, BIO_NOCLOSE); BIO_free_all(bio); *base64Text = (*bufferPtr).data;}size_t calcDecodeLength(const char* b64input) { size_t len = strlen(b64input), padding = 0; if (b64input[len - 1] == '=' &amp;&amp; b64input[len - 2] == '=') //last two chars are = padding = 2; else if (b64input[len - 1] == '=') //last char is = padding = 1; return (len * 3) / 4 - padding;}void Base64Decode(const char* b64message, unsigned char** buffer, size_t* length) { BIO* bio, * b64; int decodeLen = calcDecodeLength(b64message); *buffer = (unsigned char*)malloc(decodeLen + 1); (*buffer)[decodeLen] = '\\0'; bio = BIO_new_mem_buf(b64message, -1); b64 = BIO_new(BIO_f_base64()); bio = BIO_push(b64, bio); *length = BIO_read(bio, *buffer, strlen(b64message)); BIO_free_all(bio);}char* signMessage(std::string privateKey, std::string plainText) { //用私钥初始化一个rsa对象 RSA* privateRSA = createPrivateRSA(privateKey); unsigned char* encMessage; char* base64Text; size_t encMessageLength; RSASign(privateRSA, (unsigned char*)plainText.c_str(), plainText.length(), &amp;encMessage, &amp;encMessageLength); Base64Encode(encMessage, encMessageLength, &amp;base64Text); free(encMessage); return base64Text;}bool verifySignature(std::string publicKey, std::string plainText, char* signatureBase64) { RSA* publicRSA = createPublicRSA(publicKey); unsigned char* encMessage; size_t encMessageLength; bool authentic; Base64Decode(signatureBase64, &amp;encMessage, &amp;encMessageLength); bool result = RSAVerifySignature(publicRSA, encMessage, encMessageLength, plainText.c_str(), plainText.length(), &amp;authentic); return result &amp; authentic;}int main() { std::string plainText = &quot;My secret message.\\n&quot;; //得到用base64表示的数字签名 char* signature = signMessage(privateKey, plainText); bool authentic = verifySignature(publicKey, &quot;My secret message.\\n&quot;, signature); if (authentic) { std::cout &lt;&lt; &quot;Authentic&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Not Authentic&quot; &lt;&lt; std::endl; }}","link":"/2020/09/22/%E7%94%A8openssl%E5%AF%B9%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E8%AF%81%E7%9A%84%E4%BE%8B%E5%AD%90%E8%B7%91%E9%80%9A/"},{"title":"数字签名相关内容","text":"一、数字签名等概念https://zhuanlan.zhihu.com/p/32754315 私钥签名，公钥解密。有不可抵赖性。用于检验内容是否被篡改，丢失等。如数字签名与验证。 公钥加密，私钥解密。用于保密 只有你有私钥，所以只有你能解开，换句话说，有私钥才能看到信息，很安全。","link":"/2020/09/22/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"},{"title":"win下Github和hexo搭建个人博客","text":"1 Git安装https://git-scm.com/download/win 2 Node.js安装https://nodejs.org/en/download/ 确认是否安装成功 123git –versionnode -vnpm -v 3 GitHub新建一个仓库名字：username.github.io 4 安装hexonpm install hexo-cli -g 好像要科学上网才可以成功安装 常用命令： 1234hexo g //生成hexo s //开启本地服务器hexo new &quot;标题&quot;hexo d //部署 配置config文件 12345url: https://Jmlong23.github.io deploy: type: git repo: https://github.com/Jmlong23/Jmlong23.github.io.git branch: master 更换主题 在GitHub复制主题仓库地址 把文件复制到themes目录下 在config里面改动theme: hexo-theme-next next主题基础操作 仓库readme有 hexo隐藏文章https://github.com/printempw/hexo-hide-posts 加上： hidden: true icarus文章布局换成两行https://blog.nowcoder.net/n/0ccada7d538b4b62b4587298d8468553 更多配置https://kuang.netlify.app/blog/hexo.html","link":"/2020/05/01/hexo+icarus%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"},{"title":"x.509数字证书的解析","text":"要求X509规格的证书，要求解析出他的 1、序列号 2、签名算法 3、使用者 4、公钥 5、有效期开始，有效期结束 时间 什么是x.509数字证书https://blog.csdn.net/xy010902100449/article/details/52145009 数字证书：数字证书就是互联网通讯中标志通讯各方身份信息的一系列数据，提供了一种在Internet上验证您身份的方式，其作用类似于司机的驾驶执照或日常生活中的身份证。它是由一个由权威机构—–CA机构，又称为证书授权，（Certificate Authority）中心发行的，人们可以在网上用它来识别对方的身份。数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。 什么叫X.509数字证书X.509 标准规定了证书可以包含什么信息，并说明了记录信息的方法（数据格式）。除了签名外，所有 X.509 证书还包含以下数据： 12345678910111213141516**版本**识别用于该证书的 X.509 标准的版本，这可以影响证书中所能指定的信息。迄今为止，已定义的版本有三个。**序列号**发放证书的实体有责任为证书指定序列号，以使其区别于该实体发放的其它证书。此信息用途很多。例如，如果某一证书被撤消，其序列号将放到证书撤消清单 (CRL) 中。**签名算法标识符**用于识别 CA 签写证书时所用的算法。**签发人姓名**签写证书的实体的 X.500 名称。它通常为一个 CA。 使用该证书意味着信任签写该证书的实体（注意：有些情况下（例如根或顶层 CA 证书），签发人会签写自己的证书）。**有效期**每个证书均只能在一个有限的时间段内有效。该有效期以起始日期和时间及终止日期和时间表示，可以短至几秒或长至一世纪。所选有效期取决于许多因素，例如用于签写证书的私钥的使用频率及愿为证书支付的金钱等。它是在没有危及相关私钥的条件下，实体可以依赖公钥值的预计时间。**主体名**证书可以识别其公钥的实体名。此名称使用 X.500 标准，因此在Internet中应是唯一的。它是实体的特征名 (DN)，例如，CN=Java Duke，OU=Java Software Division，O=Sun Microsystems Inc，C=US（这些指主体的通用名、组织单位、组织和国家）。**主体公钥信息**这是被命名实体的公钥，同时包括指定该密钥所属公钥密码系统的算法标识符及所有相关的密钥参数。 x509数字证书的数据结构和存储结构https://www.cnblogs.com/chnking/archive/2007/08/28/872104.html x.509数据证书的解码法一：用openssl解析证书格式是Base64的 https://blog.csdn.net/liumiaocn/article/details/103483123 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758解析命令-in 输入文件-out 输出文件openssl x509 -in icbc_rsa.cer -out icbc_rsa.txt -text结果：Certificate: Data: Version: 3 (0x2) Serial Number: 6c:82:ca:10:24:96:00:29:9c:49 Signature Algorithm: sha1WithRSAEncryption Issuer: CN = ICBC Test Personal CA, O = personaltest.icbc.com.cn Validity Not Before: Nov 25 07:45:12 2019 GMT Not After : Nov 25 15:59:59 2024 GMT Subject: CN = 360200274427634.p.3602, OU = 3602, O = personaltest.icbc.com.cn Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (1024 bit) Modulus: 00:f1:01:f0:ee:6c:3e:ea:8d:48:23:5a:21:99:14: 09:80:b2:b8:ba:42:e5:0e:ff:ef:33:d4:5c:e3:5f: ec:52:d1:5b:13:c0:d5:f6:ea:9e:7d:a1:33:fa:02: fe:bd:d5:fb:33:d2:55:b2:6c:c1:3c:88:61:32:37: 3e:bc:8a:36:a2:86:4c:99:be:01:e8:4e:b9:9f:92: 12:a9:01:32:e3:fe:b2:7a:88:11:07:40:67:c9:69: f9:3a:60:59:60:72:13:11:8f:f7:ad:47:a0:d6:a7: 96:01:60:22:19:84:aa:11:30:ad:63:51:d0:a1:d3: 16:d7:2a:2f:a3:48:10:cd:0d Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Authority Key Identifier: keyid:76:F9:60:A6:1D:E6:99:24:D5:F2:80:D6:87:D9:4E:A8:4B:FF:B9:51 X509v3 CRL Distribution Points: Full Name: DirName:CN = crl546, OU = crl, O = personaltest.icbc.com.cn X509v3 Subject Key Identifier: AA:A2:9C:AA:1C:74:29:F6:2E:DF:DC:B8:11:85:94:57:66:8A:60:57 Signature Algorithm: sha1WithRSAEncryption 56:5b:fb:80:e2:12:e2:0d:97:07:b5:e3:c7:a6:b4:67:52:24: 38:11:b0:ba:ff:2a:92:20:c3:77:77:19:d4:7f:74:74:35:18: 99:64:71:5b:1e:c2:71:3a:44:d9:bf:a4:49:fd:2b:da:cc:de: bf:be:dc:74:3d:a8:0e:81:4d:0a:1a:e2:b1:28:b6:12:4a:61: 79:b4:f9:1f:d2:2c:9b:40:34:4f:a7:13:bd:7b:1a:da:40:21: 8d:44:dc:58:f7:26:d3:17:68:03:82:fc:6c:72:7a:fc:fa:26: 7d:7e:94:60:0a:41:92:99:f4:fd:c0:db:12:fa:ed:f3:67:eb: db:5a:79:c6:81:4c:fa:33:ca:1c:0d:e4:e4:6b:e1:14:d7:5a: 9e:85:25:aa:d0:d2:50:99:61:a2:cc:4b:32:3f:ee:65:b7:b4: 4c:c5:19:d7:0a:2e:ca:ce:69:46:f5:5b:64:86:68:c8:db:fb: c7:ac:2a:cb:1b:7c:27:b0:b5:7a:f8:85:3c:72:bb:15:ca:4e: e0:35:bf:51:31:e1:d0:44:c7:ba:41:f8:61:a1:52:42:2d:64: 52:42:45:62:7c:56:33:ad:0b:56:d2:67:d3:78:c0:0f:8a:c4: 0a:f4:e9:1b:45:10:c0:22:26:5d:94:09:44:03:7d:d7:c1:89: 85:3f:e7:f3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051解析命令-in 输入文件-out 输出文件openssl x509 -in netca.cer -out netca.txt -text Data: Version: 3 (0x2) Serial Number: 10:e1:11:9b:0d:78:0a:3c:f3:05:3b Signature Algorithm: 1.2.156.10197.1.501 Issuer: C = CN, O = NETCA Certificate Authority, CN = NETCA SM2 TEST01 and Evaluation CA01 Validity Not Before: Sep 25 09:04:26 2018 GMT Not After : Sep 25 09:04:26 2021 GMT Subject: C = CN, ST = Guangdong, L = \\E5\\B9\\BF\\E5\\B7\\9E\\E5\\B8\\82\\E5\\A4\\A9\\E6\\B2\\B3\\E5\\8C\\BA\\E4\\BA\\94\\E5\\B1\\B1\\E8\\B7\\AF246\\E3\\80\\81248\\E3\\80\\81250\\E5\\8F\\B7302\\E8\\87\\AA\\E7\\BC\\9601C, O = \\E5\\B9\\BF\\E5\\B7\\9E\\E7\\84\\B6\\E6\\80\\A1\\E8\\BD\\AF\\E4\\BB\\B6\\E6\\9C\\89\\E9\\99\\90\\E5\\85\\AC\\E5\\8F\\B8, CN = \\E5\\B9\\BF\\E5\\B7\\9E\\E7\\84\\B6\\E6\\80\\A1\\E8\\BD\\AF\\E4\\BB\\B6\\E6\\9C\\89\\E9\\99\\90\\E5\\85\\AC\\E5\\8F\\B8 Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (256 bit) pub: 04:ea:27:31:27:ce:1d:45:fe:ce:fb:db:18:76:cc: 91:f2:9e:03:95:f7:5f:96:2c:57:c3:07:e5:7f:cf: 39:58:a7:a0:c1:a4:40:22:ee:8d:6f:92:93:93:74: 9e:59:85:90:51:c6:63:11:a8:49:38:cd:42:98:71: b9:9d:fd:35:9a ASN1 OID: SM2 X509v3 extensions: X509v3 Basic Constraints: critical CA:FALSE X509v3 Subject Key Identifier: 46:F1:FF:54:72:C5:6E:4D:DD:2C:F0:E8:8D:0E:94:8A:95:55:E8:88 X509v3 Authority Key Identifier: keyid:0C:7B:EB:62:73:03:75:FA:8C:4A:24:0C:F6:8F:3B:21:65:7E:17:E9 X509v3 Certificate Policies: Policy: 1.3.6.1.4.1.18760.13.10 CPS: http://www.cnca.net/cs/knowledge/whitepaper/cps/netCAtestcertcps.pdf X509v3 CRL Distribution Points: Full Name: URI:http://test.cnca.net/crl/SM2CA.crl X509v3 Key Usage: critical Digital Signature, Non Repudiation 1.3.6.1.4.1.18760.1.14: .$bf86d4e64b664d84deabccb6baa898bf@S02 Signature Algorithm: 1.2.156.10197.1.501 30:45:02:21:00:a5:40:8b:40:17:41:53:d0:f1:4e:3c:25:61: e7:98:ac:76:da:e1:f2:05:0a:01:8d:3d:c2:0a:e7:5d:a8:88: c1:02:20:15:64:98:1a:72:3a:bb:54:f3:fb:23:f3:67:b8:e0: da:07:a6:9f:0a:70:c4:e6:6f:c9:07:30:44:3f:c0:b2:77 用c++来解码实验效果图用SM2签名的算法 用RSA签名的算法 https://www.cnblogs.com/jiu0821/p/4598352.html https://blog.csdn.net/think_A_lot/article/details/86326604 解码RSA算法加密的证书的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567#include &quot;decodeX509Cert.h&quot;int main() { X509Reader reader; reader.loadFile(&quot;netSm2.der&quot;); reader.compileContent(); reader.showX509(); reader.displayResult(); return 0;}#pragma once#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstdlib&gt;using namespace std;/*1、序列号2、签名算法3、使用者4、公钥5、有效期开始，有效期结束 时间*/struct Seg { int num; Seg(unsigned char s) { num = (int)s; }; Seg() { num = -1; }};typedef struct Seg Seg;struct TLV { Seg type; vector&lt;Seg&gt; length; vector&lt;Seg&gt; value;};typedef struct TLV TLV;struct SignatureAlgorithm { TLV algorithm; TLV parameters;};struct subjectPublicKey { TLV algorithm; TLV parameters; TLV PKey;};struct SignatureValue { TLV signatureValue;};struct signatureArray { TLV s1, s2;};typedef struct SignatureAlgorithm SignatureAlgorithm;typedef struct subjectPublicKey subjectPublicKey;typedef struct SignatureValue SignatureValue;typedef struct signatureArray signatureArray;struct TbsCertificate { TLV version; TLV serialNumber; SignatureAlgorithm signature; vector&lt;signatureArray&gt; issuer_; vector&lt;TLV&gt; validity; vector&lt;signatureArray&gt; subject_; subjectPublicKey subjectPublicKeyInfo; TLV issuerUniqueID; TLV subjectUniqueID; vector&lt;TLV&gt; extensions;};struct X509cer { struct TbsCertificate catb; struct SignatureAlgorithm casa; struct SignatureValue casv;};class X509Reader {private: vector&lt;Seg&gt; segList; vector&lt;TLV&gt; tlvList; struct X509cer x509cert; map&lt;string, string&gt; OIDMap;public: X509Reader() { OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.10040.4.1&quot;, &quot;DSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.10040.4.3&quot;, &quot;sha1DSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.113549.1.1.1&quot;, &quot;RSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.113549.1.1.2&quot;, &quot;md2RSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.113549.1.1.3&quot;, &quot;md4RSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.113549.1.1.4&quot;, &quot;md5RSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.113549.1.1.5&quot;, &quot;sha1RSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.113549.1.1.11&quot;, &quot;sha256RSA&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.10045.2.1&quot;, &quot;ECC&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.840.10045.3.1.7&quot;, &quot;ECDSA_P256&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;1.2.156.10197.1.501&quot;, &quot;SM2&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;2.5.4.6&quot;, &quot;C&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;2.5.4.8&quot;, &quot;S&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;2.5.4.7&quot;, &quot;L&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;2.5.4.10&quot;, &quot;O&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;2.5.4.11&quot;, &quot;OU&quot;)); OIDMap.insert(pair&lt;string, string&gt;(&quot;2.5.4.3&quot;, &quot;CN&quot;)); } void loadFile(string filename) { std::ifstream file; file.open(filename.c_str(), ios::in | ios::binary); while (!file.eof()) { char first; file.read(&amp;first, 1); segList.push_back(Seg((unsigned char)first)); } file.close(); } //把文本的所有字节解释成tlv结构保存在tlvlist中 void compileContent() { //由于要访问i+1的地址，所以i只能到size-1 for (int i = 0; i &lt; segList.size() - 1; ) { //如果是context-specific类型的数据 if (segList[i].num &gt;&gt; 6 == 2) { int n = segList[i].num &amp; 0x1f; //如果是3，表示扩展字段 if (n == 3) { TLV t; t.type = segList[i]; if (segList[i + 1].num &lt;= 0x7f) { t.length.push_back(segList[i + 1]); i += 2; } else { int l = segList[i + 1].num - 0x80; int s = 0, base = 1; for (int j = i + 2 + l - 1; j &gt;= i + 2; j--) { s += segList[j].num * base; base *= 256; } for (int j = i + 1; j &lt; i + 2 + l; j++) { t.length.push_back(segList[j]); } i += 2 + l; } tlvList.push_back(t); } else { TLV t; t.type = segList[i]; t.length.push_back(segList[i + 1]); tlvList.push_back(t); i += 2; } } //如果是结构类型的数据 else { if (segList[i].num &gt;&gt; 5 == 1) { TLV t; t.type = segList[i]; //如果该类型的长度小于127，用一个字节表示长度 if (segList[i + 1].num &lt;= 0x7f) { t.length.push_back(segList[i + 1]); i += 2; } //否则，用多个字节表示长度 else { //l记录长度由多少个字节表示 int l = segList[i + 1].num - 0x80; //s记录长度值 int s = 0, base = 1; for (int j = i + 2 + l - 1; j &gt;= i + 2; j--) { s += segList[j].num * base; base *= 256; } //把表示长度的字节放入tlv结构中的length中 for (int j = i + 1; j &lt; i + 2 + l; j++) { t.length.push_back(segList[j]); } //偏移2+L i += 2 + l; } tlvList.push_back(t); } //其他类型的数据，如简单类型 else { TLV t; t.type = segList[i]; if (segList[i + 1].num &lt;= 0x7f) { t.length.push_back(segList[i + 1]); for (int j = i + 2; j &lt; i + 2 + segList[i + 1].num; j++) { t.value.push_back(segList[j]); } i += segList[i + 1].num + 2; } else { int l = segList[i + 1].num - 0x80; int s = 0, base = 1; for (int j = i + 2 + l - 1; j &gt;= i + 2; j--) { s += segList[j].num * base; base *= 256; } for (int j = i + 1; j &lt; i + 2 + l; j++) { t.length.push_back(segList[j]); } for (int j = i + 2 + l; j &lt; i + 2 + l + s; j++) { t.value.push_back(segList[j]); } i += 2 + l + s; } tlvList.push_back(t); } } } } //把tlvlist里面的信息段，转化成证书类x509cert里面的信息 void showX509() { //count记录证书的第几部分信息 int count = 0, extensionSize = 0; bool isExtension = false; bool isBlock31 = false; for (int i = 0; i &lt; tlvList.size() - 1; i++) { if (isExtension) { //计算扩展部分的长度还剩下多少 extensionSize -= 1 + tlvList[i].length.size() + tlvList[i].value.size(); } //如果是SET类型 if (tlvList[i].type.num == 0x31) { isBlock31 = true; continue; } else { //如果是SEQUENCE类型，且没有在SET里面时 if (tlvList[i].type.num == 0x30 &amp;&amp; isBlock31 == false) { count++; continue; } else if (tlvList[i].type.num == 0x30 &amp;&amp; isBlock31 == true) { isBlock31 = false; continue; } //如果是证书的扩展字段 else if (tlvList[i].type.num == 0xa3) { count++; isExtension = true; int base = 1; for (int j = tlvList[i].length.size() - 1; j &gt;= 1; j--) { extensionSize += tlvList[i].length[j].num * base; base *= 256; } continue; } } //第二个SEQUENCE，版本信息，证书序号，一个SEQUENCE类型，对应一段信息 if (count == 2) { if (tlvList[i].type.num == 0xa0) { x509cert.catb.version = tlvList[i + 1]; i++; } else { x509cert.catb.serialNumber = tlvList[i]; } } //第3个SEQUENCE，证书签名算法标识，和参数 else if (count == 3) { if (tlvList[i].type.num == 0x06) { x509cert.catb.signature.algorithm = tlvList[i]; } else { x509cert.catb.signature.parameters = tlvList[i]; } } //证书发行者名称 else if (count == 4) { signatureArray a; if (tlvList[i].type.num == 0x06) { a.s1 = tlvList[i]; a.s2 = tlvList[i + 1]; x509cert.catb.issuer_.push_back(a); i += 1; } } //证书有效期 else if (count == 5) { x509cert.catb.validity.push_back(tlvList[i]); x509cert.catb.validity.push_back(tlvList[i + 1]); i += 1; } //证书主题名称 else if (count == 6) { signatureArray a; if (tlvList[i].type.num == 0x06) { a.s1 = tlvList[i]; a.s2 = tlvList[i + 1]; x509cert.catb.subject_.push_back(a); i += 1; } } //count=7 没有信息 //证书公钥信息 else if (count == 8) { if (tlvList[i].type.num == 0x06) { subjectPublicKey sbk; sbk.algorithm = tlvList[i]; sbk.parameters = tlvList[i + 1]; sbk.PKey = tlvList[i + 2]; x509cert.catb.subjectPublicKeyInfo = sbk; i += 2; } } //证书扩展部分 else if (count &gt;= 9 &amp;&amp; isExtension) { if (extensionSize &gt;= 0) { x509cert.catb.extensions.push_back(tlvList[i]); } if (extensionSize == 0) { isExtension = false; } } //最后，证书签名算法标志，签名值 else { if (tlvList[i].type.num == 0x06) { if (formatOID(x509cert.catb.signature.algorithm)._Equal(&quot;SM2&quot;)) { x509cert.casa.algorithm = tlvList[i]; x509cert.casv.signatureValue = tlvList[i + 1]; i += 1; } else { x509cert.casa.algorithm = tlvList[i]; x509cert.casa.parameters = tlvList[i + 1]; x509cert.casv.signatureValue = tlvList[i + 2]; i += 2; } } } } } //有效时间的输出 string formatDate(TLV&amp; p) { string result = &quot;20&quot;; if (p.type.num == 0x17) { int count = 0; for (int i = 0; i &lt; p.value.size() - 1; i += 2) { //根据ASCII码表转化成正常时间 result = result + (char)p.value[i].num + (char)p.value[i + 1].num; if (count &lt;= 1) { result += &quot;/&quot;; } else if (count == 2) { result += &quot; &quot;; } else if (count &lt;= 4) { result += &quot;:&quot;; } count++; } return result + &quot; GMT&quot;; } else { return &quot;&quot;; } } //对OID进行还原 string formatOID(TLV&amp; p) { string result = &quot;&quot;; char num[9]; vector&lt;int&gt; V; //如果是OBJECT IDENTIFIER类型 if (p.type.num == 0x06) { for (int i = 0; i &lt; p.value.size(); i++) { //第一个字节 if (i == 0) { int v2 = p.value[i].num % 40; int v1 = (p.value[i].num - v2) / 40; V.push_back(v1); V.push_back(v2); } else { int j = i, res = 0; int base = 128; //如果大于等于128，那么该字节不是最后一位 while (p.value[j].num &gt;= 0x80) { j++; } //计算出被表示值 res = p.value[j].num; for (int k = j - 1; k &gt;= i; k--) { res += (p.value[k].num - 0x80) * base; base *= 128; } V.push_back(res); i = j; } } //拼凑成oid标识串，并且在hash表中找到相应名 for (int i = 0; i &lt; V.size(); i++) { sprintf(num, &quot;%d&quot;, V[i]); result += num; if (i &lt; V.size() - 1) { result += &quot;.&quot;; } } return OIDMap[result]; } else { return &quot;&quot;; } } //输出segList的十六进制表示 void displayOrigin() { int count = 0; for (int i = 0; i &lt; segList.size(); i++) { printf(&quot;%02x &quot;, segList[i].num); count++; if (count == 16) { cout &lt;&lt; endl; count = 0; } } } //输出tlvList里面的内容 void displayTLVOrigin() { int count = 0; bool isBlock31 = false; for (int i = 0; i &lt; tlvList.size(); i++) { if (tlvList[i].type.num == 0x31) { isBlock31 = true; } else { if (tlvList[i].type.num == 0x30 &amp;&amp; isBlock31 == false) { count++; } else if (tlvList[i].type.num == 0x30 &amp;&amp; isBlock31 == true) { isBlock31 = false; } else if (tlvList[i].type.num == 0xa3) { count++; } } cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; endl; printf(&quot;type: %02x &quot;, tlvList[i].type); printf(&quot;length: &quot;); for (int j = 0; j &lt; tlvList[i].length.size(); j++) { printf(&quot;%02x &quot;, tlvList[i].length[j]); } printf(&quot;value(%02x): &quot;, tlvList[i].value.size()); for (int j = 0; j &lt; tlvList[i].value.size(); j++) { printf(&quot;%02x &quot;, tlvList[i].value[j]); } printf(&quot;\\n&quot;); } } void printValue(TLV&amp; p, int mode = 0) { if (p.value.size() == 0) { printf(&quot;NULL&quot;); } else { for (int i = 0; i &lt; p.value.size(); i++) { //如果时BIG STRING类型，那么把前面没用的那个字节省略掉 if (p.type.num == 0x03 &amp;&amp; i == 0) continue; //如果是表示ASCII码的类型，那么按字符输出 if (p.type.num == 0x13 || p.type.num == 0x0c) { printf(&quot;%c&quot;, p.value[i].num); } //否则按十六进制输出 else { //如果没指定参数，有空格输出 if (mode == 0) { printf(&quot;%02x &quot;, p.value[i].num); } else { printf(&quot;%02x&quot;, p.value[i].num); } } } //如果是表示ASCII码的类型 if (p.type.num == 0x0c) { printf(&quot;(UTF-8)&quot;); } } printf(&quot;\\n&quot;); } void displayResult() { printf(&quot;SerialNumber: &quot;); printValue(x509cert.catb.serialNumber, 1); printf(&quot;SignatureAlgorithm: &quot;); cout &lt;&lt; formatOID(x509cert.catb.signature.algorithm) &lt;&lt; endl; printf(&quot;Subject:\\n&quot;); for (int i = 0; i &lt; x509cert.catb.subject_.size(); i++) { cout &lt;&lt; &quot; &quot; &lt;&lt; formatOID(x509cert.catb.subject_[i].s1); printf(&quot; = &quot;); printValue(x509cert.catb.subject_[i].s2); } printf(&quot;Validity:\\n notBefore: &quot;); cout &lt;&lt; formatDate(x509cert.catb.validity[0]) &lt;&lt; endl; printf(&quot; notAfter: &quot;); cout &lt;&lt; formatDate(x509cert.catb.validity[1]) &lt;&lt; endl; /*其他信息 printf(&quot; PKey: &quot;); printValue(x509cert.catb.subjectPublicKeyInfo.PKey); printf(&quot;Version: V%d\\n&quot;, x509cert.catb.version.value[0].num + 1); printf(&quot; Params: &quot;); printValue(x509cert.catb.signature.parameters); printf(&quot;Issuer: \\n&quot;); for (int i = 0; i &lt; x509cert.catb.issuer_.size(); i++) { cout &lt;&lt; &quot; &quot; &lt;&lt; formatOID(x509cert.catb.issuer_[i].s1); printf(&quot; = &quot;); printValue(x509cert.catb.issuer_[i].s2); } printf(&quot;subjectPublicKeyInfo:\\n&quot;); //公钥算法 printf(&quot; Algorithm: &quot;); cout &lt;&lt; formatOID(x509cert.catb.subjectPublicKeyInfo.algorithm) &lt;&lt; endl; printf(&quot; Params: &quot;); printValue(x509cert.catb.subjectPublicKeyInfo.parameters); printf(&quot;issuerUniqueID: &quot;); printValue(x509cert.catb.issuerUniqueID); printf(&quot;subjectUniqueID: &quot;); printValue(x509cert.catb.subjectUniqueID); printf(&quot;Extensions:\\n&quot;); printf(&quot; Other: ellipsis\\n&quot;); /* 拓展部分不翻译 for(int i = 0; i &lt; x509cert.catb.extensions.size(); i++) { if(x509cert.catb.extensions[i].type.num == 0x01) { printf(&quot; isCACertification: &quot;); printValue(x509cert.catb.extensions[i]); printf(&quot; Other: ellipsis\\n&quot;); break; } } printf(&quot;SignatureAlgorithm:\\n&quot;); printf(&quot; Algorithm: &quot;); cout &lt;&lt; formatOID(x509cert.casa.algorithm) &lt;&lt; endl; printf(&quot; Params: &quot;); printValue(x509cert.casa.parameters); printf(&quot;SignatureValue: &quot;); printValue(x509cert.casv.signatureValue); */ }}; 算法描述1）、打开一个二进制的证书文件，按字节把文件中所有字节读入到字符容器中 2）、","link":"/2020/09/24/x-509%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E8%A7%A3%E6%9E%90/"},{"title":"Base64编码与解码","text":"原理http://blog.chacuo.net/719.html 工具https://base64.guru/converter/decode/file c语言实现https://blog.csdn.net/qq_26093511/article/details/78836087","link":"/2020/09/28/Base64%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/"},{"title":"ascii码表","text":"ASCII对照表 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 “ 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL 特殊字符解释 NUL空 VT 垂直制表 SYN 空转同步 STX 正文开始 CR 回车 CAN 作废 ETX 正文结束 SO 移位输出 EM 纸尽 EOY 传输结束 SI 移位输入 SUB 换置 ENQ 询问字符 DLE 空格 ESC 换码 ACK 承认 DC1 设备控制1 FS 文字分隔符 BEL 报警 DC2 设备控制2 GS 组分隔符 BS 退一格 DC3 设备控制3 RS 记录分隔符 HT 横向列表 DC4 设备控制4 US 单元分隔符 LF 换行 NAK 否定 DEL 删除 https://tool.oschina.net/commons?type=4","link":"/2020/09/25/ascii%E7%A0%81%E8%A1%A8/"},{"title":"windows窗口程序基础","text":"第一个程序打开vs-》新建-》Windows桌面想到-》桌面程序-》空项目 https://blog.csdn.net/hyman_c/article/details/53057037 123456789#include &quot;windows.h&quot;int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow){ MessageBoxA(NULL, &quot;Hello Win32&quot;, &quot;sdk&quot;, MB_ABORTRETRYIGNORE | MB_ICONERROR); return 0;} “const char *” 类型的实参与 “LPCWSTR” 类型的形参不兼容,改成字符集改成多字节才不会出现乱码 https://blog.csdn.net/harrywater123/article/details/51418888 官方例子 https://docs.microsoft.com/zh-cn/cpp/windows/walkthrough-creating-windows-desktop-applications-cpp?view=vs-2019 从零开始创建Windows窗口https://blog.csdn.net/hyman_c/article/details/53447695 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;windows.h&gt;HINSTANCE g_hInstance = 0;//窗口处理函数LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam){ switch (uMsg) { case WM_DESTROY: PostQuitMessage(0);//可以使GetMessage返回0 break; default: break; } return DefWindowProc(hWnd, uMsg, wParam, lParam);}//注册窗口类BOOL Register(LPCSTR lpClassName, WNDPROC wndProc){ WNDCLASSEX wce = { 0 }; wce.cbSize = sizeof(wce); wce.cbClsExtra = 0; wce.cbWndExtra = 0; wce.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); wce.hCursor = NULL; wce.hIcon = NULL; wce.hIconSm = NULL; wce.hInstance = g_hInstance; wce.lpfnWndProc = wndProc; wce.lpszClassName = lpClassName; wce.lpszMenuName = NULL; wce.style = CS_HREDRAW | CS_VREDRAW; ATOM nAtom = RegisterClassEx(&amp;wce); if (nAtom == 0) return FALSE; return true;}//创建主窗口HWND CreateMain(LPCSTR lpClassName, LPCSTR lpWndName){ HWND hWnd = CreateWindowEx(0, lpClassName, lpWndName, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, g_hInstance, NULL); return hWnd;}//显示窗口void Display(HWND hWnd){ ShowWindow(hWnd, SW_SHOW); UpdateWindow(hWnd);}//消息循环void Message(){ MSG nMsg = { 0 }; while (GetMessage(&amp;nMsg, NULL, 0, 0)) { TranslateMessage(&amp;nMsg); DispatchMessage(&amp;nMsg); }}int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow){ // TODO: Place code here. g_hInstance = hInstance; BOOL nRet = Register((LPCSTR)&quot;Main&quot;, WndProc); if (!nRet) { MessageBox(NULL, &quot;注册失败&quot;, &quot;Infor&quot;, MB_OK); return 0; } HWND hWnd = CreateMain((LPCSTR)&quot;Main&quot;, (LPCSTR)&quot;window&quot;); Display(hWnd); Message(); return 0;} windows程序创建过程https://blog.csdn.net/hyman_c/article/details/53447695 创建一个Windows界面程序共分为7步： （1）定义WinMain函数（这是windows界面程序的入口）。 （2）定义窗口处理函数。 （3）注册窗口 （4）创建窗口 （5）显示窗口 （6）编写消息循环函数 （7）处理消息(在第二步的窗口处理函数中) windows消息机制https://blog.csdn.net/hyman_c/article/details/53729066 看代码1 代码1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;windows.h&gt;// C 运行时头文件#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;memory.h&gt;#include &lt;tchar.h&gt;#include &lt;stdio.h&gt;HINSTANCE g_hInstance = 0;//窗口处理函数 LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam){ switch (uMsg) { case WM_DESTROY: PostQuitMessage(0);//可以使GetMessage返回0 break; case WM_CREATE: { CREATESTRUCT crt = *((CREATESTRUCT*)lParam); char buf[256] = { 0 }; sprintf(buf, &quot;创建的窗口类名称是%s，窗口名称是%s&quot;, crt.lpszClass, crt.lpszName); MessageBox(NULL, buf, &quot;消息处理&quot;, MB_OK); } case WM_QUIT: { int param = (int)wParam; char buf[256]; sprintf(buf, &quot;进程退出，退出码:%d&quot;, param); MessageBox(NULL, buf, &quot;消息处理&quot;, MB_OK); } case WM_SYSCOMMAND: { if (wParam == SC_MAXIMIZE) { short x = LOWORD(lParam); short y = HIWORD(lParam); char buf[256]; sprintf(buf, &quot;窗口最大化，x坐标:%d，y坐标:%d&quot;, x, y); MessageBox(NULL, buf, &quot;消息处理&quot;, MB_OK); } } case WM_SIZE: { if (wParam == SIZE_MAXIMIZED) { short width = LOWORD(lParam); short hight = HIWORD(lParam); char buf[256]; sprintf(buf, &quot;窗口最大化，高度:%d，宽度:%d&quot;, hight, width); MessageBox(NULL, buf, &quot;消息处理&quot;, MB_OK); } } default: break; } return DefWindowProc(hWnd, uMsg, wParam, lParam);}//注册窗口类 BOOL Register(LPSTR lpClassName, WNDPROC wndProc){ WNDCLASSEX wce = { 0 }; wce.cbSize = sizeof(wce); wce.cbClsExtra = 0; wce.cbWndExtra = 0; wce.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); wce.hCursor = NULL; wce.hIcon = NULL; wce.hIconSm = NULL; wce.hInstance = g_hInstance; wce.lpfnWndProc = wndProc; wce.lpszClassName = lpClassName; wce.lpszMenuName = NULL; wce.style = CS_HREDRAW | CS_VREDRAW; ATOM nAtom = RegisterClassEx(&amp;wce); if (nAtom == 0) return FALSE; return true;}//创建主窗口 HWND CreateMain(LPSTR lpClassName, LPSTR lpWndName){ HWND hWnd = CreateWindowEx(0, lpClassName, lpWndName, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, g_hInstance, NULL); return hWnd;}//显示窗口 void Display(HWND hWnd){ ShowWindow(hWnd, SW_SHOW); UpdateWindow(hWnd);}//消息循环 void Message(){ MSG nMsg = { 0 }; //GetMessage()不断的在消息队列中抓取消息 while (GetMessage(&amp;nMsg, NULL, 0, 0)) { /* GetMessage()获取到消息后，TranslateMessage会将消息进行翻译， 主要是把虚拟键消息转换为字符消息。字符消息被寄送到调用线程的消息队列里， 当下一次线程调用函数GetMessage或PeekMessage时被读出。 Windows中每一个键盘按键，都对应了一个宏，这个键盘按键发出的消息就是虚拟键消息。 TranslateMessage的作用就是将虚拟键消息转成字符消息WM_CHAR、WM_SYSCHAR等等。 */ TranslateMessage(&amp;nMsg); //把信息发给信息处理函数 DispatchMessage(&amp;nMsg); }}int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow){ // TODO: Place code here. g_hInstance = hInstance; BOOL nRet = Register((LPSTR)&quot;Main&quot;, WndProc); if (!nRet) { MessageBox(NULL, &quot;注册失败&quot;, &quot;Infor&quot;, MB_OK); return 0; } HWND hWnd = CreateMain((LPSTR)&quot;Main&quot;, (LPSTR)&quot;window&quot;); Display(hWnd); Message(); return 0;}","link":"/2020/09/28/windows%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"},{"title":"微软的CSP架构","text":"问题无法解析的外部符号impCertFreeCertificateContext https://blog.csdn.net/diaoxuesong/article/details/78664663 在跑用csp获取证书那个例子时，遇到错误，只要在 项目属性 - 链接器 - 输入 - 附加依赖项 中加入： Crypt32.lib 即可。 CSP入门简介https://blog.csdn.net/liuhuiyi/article/details/7778742 CryptAcquireContext函数https://blog.csdn.net/Qiplus/article/details/8086100?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.edu_weight Csp第一个例子https://blog.csdn.net/liuhuiyi/article/details/7778968 看代码一 CSP第二个例子https://blog.csdn.net/liuhuiyi/article/details/7787435 运行结果 1234567891011121314151617打开句柄成功获得签名密钥成功。we get the length of the public key.we get the memory.export the public key.CreateHash succeed.HashData succeed. Get the length of signature.get the memory.signature succeed.Signature:8a7595ada1c9125a86b4d01687a35768bd22728519302bfdd37559be6e2e1a64b5ff2d33803debb17d43cf3c6e50f21bbebe8ae2dfb7eab3c27d6c1b7142cd1ca4b28527021bd9849d63f6421a2e7a0f3df12371bd03ba18d9f608b3a5f4d21384b634a77f621b79991de2a8c324c7d968abf5a076bace2fd09c3f4e3708a1aeOK.Import the key.创建哈希对象成功数据哈希完成.验证签名成功。 看代码二 https://www.cnblogs.com/whbCNW/tag/CSP/ 探索用CSP获取商店里面的证书来进行签名和验证https://www.sysadmins.lv/retired-msft-blogs/alejacma/how-to-sign-and-verify-with-cryptoapi-and-a-user-certificate.aspx https://zhuanlan.zhihu.com/p/38105475 - 看代码4 用CSP获取系统里面的证书并且显示https://www.coder.work/article/982837 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;conio.h&gt;#include &lt;windows.h&gt;#include &lt;wincrypt.h&gt;#include &lt;string&gt;using namespace std;#define CERT_PERSONAL_STORE_NAME L&quot;My&quot;#define CERT_OTHER_PEOPLE_STORE_NAME L&quot;AddressBook&quot;#define MY_TYPE (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)#define BUFSIZE 1024void printfSerial(unsigned long count,unsigned char* str) { for (int i = 0; i &lt; count; i++) { printf(&quot;%2.2x&quot;, str[count - i -1]); } printf(&quot;\\n&quot;);}void printfPublicKey(unsigned long count, unsigned char* str) { for (int i = 0; i &lt; count; i++) { printf(&quot;%2.2x&quot;, str[i]); } printf(&quot;\\n&quot;);}void printfSubject(unsigned long count, unsigned char* str) { for (int i = 0; i &lt; count; i++) { printf(&quot;%c&quot;, str[i]); } printf(&quot;\\n&quot;);}void main() { HCERTSTORE hCertStore = NULL; PCCERT_CONTEXT pCertContext = NULL; PBYTE pbPKEY = NULL; DWORD iPKEYSize; const char* str = &quot;360200265999946.p.3602&quot;; DWORD dwNum = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0); // 转换成 宽字节大小9 (8+1) wchar_t* SignerName = new WCHAR[dwNum]; // 按宽字节 new 内存 memset(SignerName, 0, dwNum * sizeof(wchar_t)); // 全置0 可以用这句 memset(wch, 0, sizeof(wch)); // memset( the_array, '\\0', sizeof(the_array) ); 这是将一个数组的所以分量设置成零的很便捷的方法 MultiByteToWideChar(CP_ACP, 0, str, -1, SignerName, dwNum * sizeof(wchar_t)); //s转换到宽字节wch hCertStore = CertOpenStore( CERT_STORE_PROV_SYSTEM, 0, NULL, CERT_SYSTEM_STORE_CURRENT_USER, CERT_PERSONAL_STORE_NAME ); pCertContext = CertFindCertificateInStore( hCertStore, MY_TYPE, 0, CERT_FIND_SUBJECT_STR, SignerName, pCertContext ); //printf(&quot;version:%ld&quot;, pCertContext-&gt;pCertInfo-&gt;dwVersion + 1); printf(&quot;SerialNumber:&quot;); printfSerial(pCertContext-&gt;pCertInfo-&gt;SerialNumber.cbData, pCertContext-&gt;pCertInfo-&gt;SerialNumber.pbData); printf(&quot;SignatureAlgorithm:%s\\n&quot;, pCertContext-&gt;pCertInfo-&gt;SignatureAlgorithm.pszObjId); printf(&quot;Subject:\\n&quot;); printfSubject(pCertContext-&gt;pCertInfo-&gt;Subject.cbData,pCertContext-&gt;pCertInfo-&gt;Subject.pbData); printf(&quot;PublicKey:&quot;); printfPublicKey(pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo.PublicKey.cbData, pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo.PublicKey.pbData);} 读取usbkey中的密钥容器https://www.geek-share.com/detail/2730619280.html https://blog.csdn.net/xuebing1995/article/details/79388971 看代码3 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;direct.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;Windows.h&gt;using namespace std;void main() { DWORD dwIndex = 9; DWORD dwType = 0; DWORD dwNameLen = 0; HCRYPTPROV hProv = NULL; DWORD dwErr; while (CryptEnumProviders(dwIndex, NULL, 0, &amp;dwType, NULL, &amp;dwNameLen)) { DWORD dwItem = 0; TCHAR* pName = new TCHAR[dwNameLen + 1]; if (CryptEnumProviders(dwIndex++, NULL, 0, &amp;dwType, pName, &amp;dwNameLen)) { if (!CryptAcquireContext(&amp;hProv, NULL, pName, dwType, 0)) { dwErr = GetLastError(); } else { int num = WideCharToMultiByte(CP_OEMCP, NULL, (LPWSTR)pName, -1, NULL, 0, NULL, FALSE); char* pchar = new char[num]; WideCharToMultiByte(CP_OEMCP, NULL, (LPWSTR)pName, -1, pchar, num, NULL, FALSE); printf(&quot;%s\\n&quot;, pchar); } } } printf(&quot;end&quot;);} 调用网融公司包来签名验证的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include&lt;pkiapi.h&gt;#include&lt;pkiapp.h&gt;using namespace std;void main() { if (!pkiInit()) { cout &lt;&lt; &quot;succeed\\n&quot;; } else { cout &lt;&lt; &quot;error\\n&quot;; } BYTE* label = (unsigned char*)&quot;360200265999946.p.3602&quot;; LABEL_TYPE type = LBL_CERT; BYTE* buf; int size; if (!pkiReadLabel(label, type, NULL, &amp;size)) { cout &lt;&lt; &quot;succeed\\n&quot;; } else { cout &lt;&lt; &quot;error\\n&quot;; } BYTE* i_keyLabel = (unsigned char*)&quot;76f960a61de69924d5f280d687d94ea84bffb951&quot;; BYTE* i_keyPasswd = (unsigned char*)&quot;123456&quot;; ALG_ID digestAlgo = 32780; PKI_DATA i_inData; i_inData.size = 3; i_inData.value = (unsigned char*)&quot;abc&quot;; /// &lt;summary&gt; //分配内存 /// &lt;/summary&gt; PKI_DATA* signature = (PKI_DATA*)malloc(1000); /*PKI_DATA signature; signature.size = 300; signature.value = (BYTE*)malloc(signature.size);*/ //cout&lt;&lt;pkiSignData(i_keyLabel, i_keyPasswd, i_inData, signature)&lt;&lt;endl; cout &lt;&lt; pkiGetSignature(i_keyLabel, i_keyPasswd, digestAlgo, i_inData, signature) &lt;&lt; endl; if (!pkiGetSignature(i_keyLabel, i_keyPasswd, digestAlgo, i_inData, signature)) { cout &lt;&lt; &quot;succeed\\n&quot;; } else { cout &lt;&lt; &quot;error\\n&quot;; } /*if (!pkiVerifySignature(NULL, i_inData, *signature)) { cout &lt;&lt; &quot;succeed\\n&quot;; } else { cout &lt;&lt; &quot;error\\n&quot;; }*/ if (!pkiEnd()) { cout &lt;&lt; &quot;succeed\\n&quot;; } else { cout &lt;&lt; &quot;error\\n&quot;; }} 代码4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400// Includes#include &lt;stdio.h&gt;#include &lt;conio.h&gt;#include &lt;windows.h&gt;#include &lt;wincrypt.h&gt;// Defines#define CERT_PERSONAL_STORE_NAME L&quot;My&quot;#define CERT_OTHER_PEOPLE_STORE_NAME L&quot;AddressBook&quot;#define MY_TYPE (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)#define BUFSIZE 1024// Local functionsvoid Sign(wchar_t* SignerName, wchar_t* DataFileName, wchar_t* SignatureFileName);void Verify(wchar_t* SignerName, wchar_t* SignatureFileName, wchar_t* DataFileName);// ShowUsageAndExitvoid ShowUsageAndExit(){ wprintf(L&quot;Usage:\\n&quot;); wprintf(L&quot; - To sign: SignVerify s signer_name data_file signature_file\\n&quot;); wprintf(L&quot; - To verify: SignVerify v signer_name data_file signature_file\\n&quot;); wprintf(L&quot;\\n&lt;&lt; Press any key to continue &gt;&gt;\\n&quot;); _getch(); exit(1);}// End of ShowUsageAndExit// CheckErrorvoid CheckError(BOOL condition, const wchar_t* message){ wprintf(message); if (condition) { wprintf(L&quot;SUCCESS\\n&quot;); } else { // TODO: Some cleanup wprintf(L&quot;FAILURE (0x%x)\\n&quot;, GetLastError()); wprintf(L&quot;\\n&lt;&lt; Press any key to continue &gt;&gt;\\n&quot;); _getch(); exit(1); }}// End CheckError// Mainvoid wmain(int argc, wchar_t* argv[]){ // Usage if (argc != 5) { ShowUsageAndExit(); } if (!wcscmp(argv[1], L&quot;s&quot;)) { // Sign Sign(argv[2], argv[3], argv[4]); } else if (!wcscmp(argv[1], L&quot;v&quot;)) { // Verify Verify(argv[2], argv[3], argv[4]); } else { // Error ShowUsageAndExit(); } // The end wprintf(L&quot;\\n&lt;&lt; Press any key to continue &gt;&gt;\\n&quot;); _getch();}// End of main// Signvoid Sign(wchar_t* SignerName, wchar_t* DataFileName, wchar_t* SignatureFileName){ // Variables HCERTSTORE hStoreHandle = NULL; PCCERT_CONTEXT pSignerCert = NULL; HCRYPTPROV hCryptProv = NULL; DWORD dwKeySpec = 0; HCRYPTHASH hHash = NULL; HANDLE hDataFile = NULL; BOOL bResult = FALSE; BYTE rgbFile[BUFSIZE]; DWORD cbRead = 0; DWORD dwSigLen = 0; BYTE* pbSignature = NULL; HANDLE hSignatureFile = NULL; DWORD lpNumberOfBytesWritten = 0; wprintf(L&quot;SIGNING\\n\\n&quot;); // Open the certificate store. hStoreHandle = CertOpenStore( CERT_STORE_PROV_SYSTEM, 0, NULL, CERT_SYSTEM_STORE_CURRENT_USER, CERT_PERSONAL_STORE_NAME ); CheckError((BOOL)hStoreHandle, L&quot;CertOpenStore....................... &quot;); // Get signer's certificate with access to private key. do { // Get a certificate that matches the search criteria pSignerCert = CertFindCertificateInStore( hStoreHandle, MY_TYPE, 0, CERT_FIND_SUBJECT_STR, SignerName, pSignerCert ); CheckError((BOOL)pSignerCert, L&quot;CertFindCertificateInStore.......... &quot;); // Get the CSP, and check if we can sign with the private key bResult = CryptAcquireCertificatePrivateKey( pSignerCert, 0, NULL, &amp;hCryptProv, &amp;dwKeySpec, NULL ); CheckError(bResult, L&quot;CryptAcquireCertificatePrivateKey... &quot;); } while ((dwKeySpec &amp; AT_SIGNATURE) != AT_SIGNATURE); // Create the hash object. bResult = CryptCreateHash( hCryptProv, CALG_MD5, 0, 0, &amp;hHash ); CheckError(bResult, L&quot;CryptCreateHash..................... &quot;); // Open the file with the content to be signed hDataFile = CreateFileW(DataFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL ); CheckError((hDataFile != INVALID_HANDLE_VALUE), L&quot;CreateFile.......................... &quot;); // Compute the cryptographic hash of the data. while (bResult = ReadFile(hDataFile, rgbFile, BUFSIZE, &amp;cbRead, NULL)) { if (cbRead == 0) { break; } CheckError(bResult, L&quot;ReadFile............................ &quot;); bResult = CryptHashData( hHash, rgbFile, cbRead, 0 ); CheckError(bResult, L&quot;CryptHashData....................... &quot;); } CheckError(bResult, L&quot;ReadFile............................ &quot;); // Sign the hash object dwSigLen = 0; bResult = CryptSignHash( hHash, AT_SIGNATURE, NULL, 0, NULL, &amp;dwSigLen ); CheckError(bResult, L&quot;CryptSignHash....................... &quot;); pbSignature = (BYTE*)malloc(dwSigLen); CheckError((BOOL)pbSignature, L&quot;malloc.............................. &quot;); bResult = CryptSignHash( hHash, AT_SIGNATURE, NULL, 0, pbSignature, &amp;dwSigLen ); CheckError(bResult, L&quot;CryptSignHash....................... &quot;); // Create a file to save the signature hSignatureFile = CreateFileW( SignatureFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ); CheckError((hSignatureFile != INVALID_HANDLE_VALUE), L&quot;CreateFile.......................... &quot;); // Write the signature to the file bResult = WriteFile( hSignatureFile, (LPCVOID)pbSignature, dwSigLen, &amp;lpNumberOfBytesWritten, NULL ); CheckError(bResult, L&quot;WriteFile........................... &quot;); // Clean up and free memory. free(pbSignature); CloseHandle(hDataFile); CloseHandle(hSignatureFile); bResult = CryptDestroyHash(hHash); CheckError(bResult, L&quot;CryptDestroyHash.................... &quot;); bResult = CertFreeCertificateContext(pSignerCert); CheckError(bResult, L&quot;CertFreeCertificateContext.......... &quot;); bResult = CertCloseStore( hStoreHandle, CERT_CLOSE_STORE_CHECK_FLAG ); CheckError(bResult, L&quot;CertCloseStore...................... &quot;);}// End of Sign// Verifyvoid Verify(wchar_t* SignerName, wchar_t* DataFileName, wchar_t* SignatureFileName){ // Variables HCERTSTORE hStoreHandle = NULL; PCCERT_CONTEXT pSignerCert = NULL; DWORD dwKeySpec = 0; HCRYPTPROV hCryptProv = NULL; HCRYPTHASH hHash = NULL; HANDLE hDataFile = NULL; BOOL bResult = FALSE; BYTE rgbFile[BUFSIZE]; DWORD cbRead = 0; HANDLE hSignatureFile = NULL; BYTE* pbBinary = NULL; DWORD cbBinary = 0; HCRYPTKEY hPubKey = NULL; wprintf(L&quot;VERIFYING\\n\\n&quot;); // Open the certificate store. hStoreHandle = CertOpenStore( CERT_STORE_PROV_SYSTEM, 0, NULL, CERT_SYSTEM_STORE_CURRENT_USER, CERT_PERSONAL_STORE_NAME ); CheckError((BOOL)hStoreHandle, L&quot;CertOpenStore....................... &quot;); // Get a certificate that matches the search criteria pSignerCert = CertFindCertificateInStore( hStoreHandle, MY_TYPE, 0, CERT_FIND_SUBJECT_STR, SignerName, pSignerCert ); CheckError((BOOL)pSignerCert, L&quot;CertFindCertificateInStore.......... &quot;); // Get the CSP bResult = CryptAcquireContext( &amp;hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT ); CheckError(bResult, L&quot;CryptAcquireContext................. &quot;); // Create the hash object. bResult = CryptCreateHash( hCryptProv, CALG_MD5, 0, 0, &amp;hHash ); CheckError(bResult, L&quot;CryptCreateHash..................... &quot;); // Open the file with the content that was signed. hDataFile = CreateFileW( DataFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL ); CheckError((hDataFile != INVALID_HANDLE_VALUE), L&quot;CreateFile.......................... &quot;); // Compute the cryptographic hash of the data. while (bResult = ReadFile(hDataFile, rgbFile, BUFSIZE, &amp;cbRead, NULL)) { if (cbRead == 0) { break; } CheckError(bResult, L&quot;ReadFile............................ &quot;); bResult = CryptHashData( hHash, rgbFile, cbRead, 0 ); CheckError(bResult, L&quot;CryptHashData....................... &quot;); } CheckError(bResult, L&quot;ReadFile............................ &quot;); // Open the file with the signature hSignatureFile = CreateFileW( SignatureFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL ); CheckError((hSignatureFile != INVALID_HANDLE_VALUE), L&quot;CreateFile.......................... &quot;); // Read the signature from the file pbBinary = (BYTE*)malloc(BUFSIZE); CheckError((BOOL)pbBinary, L&quot;malloc.............................. &quot;); bResult = ReadFile(hSignatureFile, pbBinary, BUFSIZE, &amp;cbBinary, NULL); CheckError(bResult, L&quot;ReadFile............................ &quot;); // Get the public key from the certificate CryptImportPublicKeyInfo( hCryptProv, MY_TYPE, &amp;pSignerCert-&gt;pCertInfo-&gt;SubjectPublicKeyInfo, &amp;hPubKey ); CheckError(bResult, L&quot;CryptImportPublicKeyInfo............ &quot;); // Verify the signature bResult = CryptVerifySignature( hHash, pbBinary, cbBinary, hPubKey, NULL, 0 ); CheckError(bResult, L&quot;CryptVerifySignature................ &quot;); // Clean up and free memory. free(pbBinary); CloseHandle(hDataFile); CloseHandle(hSignatureFile); bResult = CryptDestroyHash(hHash); CheckError(bResult, L&quot;CryptDestroyHash.................... &quot;); bResult = CertFreeCertificateContext(pSignerCert); CheckError(bResult, L&quot;CertFreeCertificateContext.......... &quot;); bResult = CertCloseStore( hStoreHandle, CERT_CLOSE_STORE_CHECK_FLAG ); CheckError(bResult, L&quot;CertCloseStore...................... &quot;); bResult = CryptReleaseContext( hCryptProv, 0 ); CheckError(bResult, L&quot;CryptReleaseContext................. &quot;);}// End of Verify 代码3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include &lt;stdio.h&gt;#include &lt;direct.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;Windows.h&gt;#include &lt;Wincrypt.h&gt;using namespace std;#pragma warning(disable:4996)#pragma comment(lib, &quot;Crypt32&quot;)#define PROV_LENGTH 255#define MY_ENCODING_TYPE (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)struct keyInfo{ string certUserName; string providerName; string containerName;};void GetListProvider(vector&lt;string&gt;&amp; vProList){ DWORD dwIndex = 0; DWORD dwType = 0; char szKeyName[PROV_LENGTH] = { 0 }; DWORD dwMaxSubKey = PROV_LENGTH; while (CryptEnumProviders(dwIndex++, NULL, 0, &amp;dwType, (LPWSTR)szKeyName, &amp;dwMaxSubKey)) { int num = WideCharToMultiByte(CP_OEMCP, NULL, (LPWSTR)szKeyName, -1, NULL, 0, NULL, FALSE); char* pchar = new char[num]; WideCharToMultiByte(CP_OEMCP, NULL, (LPWSTR)szKeyName, -1, pchar, num, NULL, FALSE); if (dwType == PROV_RSA_FULL &amp;&amp; strnicmp(&quot;Microsoft&quot;, pchar, 9)) //csp类型 + 不区分大小写比较前9个字符 { vProList.push_back(pchar); } memset(szKeyName, 0, PROV_LENGTH); dwMaxSubKey = PROV_LENGTH; }}DWORD GetCertificate(HCRYPTPROV hProv, BYTE* pCertificate, DWORD* pCertificateLen){ if (hProv == NULL) return -1; //获取所获取密钥类型的句柄 //获取公私钥对和交换密钥,公私钥用来签名,而交换密钥用来导出会话密钥 HCRYPTKEY hSignKey; if (CryptGetUserKey(hProv, AT_SIGNATURE, &amp;hSignKey) == FALSE) { printf(&quot;CSP获取密钥句柄失败\\n&quot;); return -1; } if (CryptGetKeyParam(hSignKey, KP_CERTIFICATE, pCertificate, pCertificateLen, 0) == FALSE) { printf(&quot;CSP得到密钥参数失败\\n&quot;); return -1; } if (CryptDestroyKey(hSignKey) == FALSE) { printf(&quot;CSP销毁密钥失败\\n&quot;); return -1; } return 0;}DWORD DecodeX509Cert(BYTE* pCertificate, DWORD certificateLen, char keyID[255], char userName[255]){ PCCERT_CONTEXT pctx = CertCreateCertificateContext(MY_ENCODING_TYPE, pCertificate, certificateLen); //从编码证书中创建一个证书上下文。但这个上下文并不放到证书库里 if (pctx == NULL) { printf(&quot;解析证书失败\\n&quot;); return -1; } //找到扩展对象 PCERT_EXTENSION pCertExt = CertFindExtension(szOID_AUTHORITY_KEY_IDENTIFIER2, pctx-&gt;pCertInfo-&gt;cExtension, pctx-&gt;pCertInfo-&gt;rgExtension); //通过OID来查找扩展 if (!pCertExt) { printf(&quot;证书属性不存在\\n&quot;); return -1; } //解码对象,得到属性结构体 DWORD ulDataLen = 512; BYTE btData[512] = { 0 }; CHAR csProperty[512] = { 0 }; PCERT_AUTHORITY_KEY_ID2_INFO pAuthorityKeyID2 = (PCERT_AUTHORITY_KEY_ID2_INFO)btData; if (CryptDecodeObject(MY_ENCODING_TYPE, szOID_AUTHORITY_KEY_IDENTIFIER2, pCertExt-&gt;Value.pbData, pCertExt-&gt;Value.cbData, CRYPT_DECODE_NOCOPY_FLAG, pAuthorityKeyID2, &amp;ulDataLen)) //对属性结构体进行解码 { //获取颁发机构标识符 for (ULONG ulIndex = 0; ulIndex &lt; pAuthorityKeyID2-&gt;KeyId.cbData; ulIndex++) { CHAR csKeyID[8] = { 0 }; sprintf_s(csKeyID, 8, &quot;%02x &quot;, pAuthorityKeyID2-&gt;KeyId.pbData[ulIndex]); strcat_s(csProperty, 512, csKeyID); } csProperty[strlen(csProperty) - 1] = 0; strcpy(keyID, csProperty); //获取userName TCHAR sName[255]; DWORD nNameSize = 255; DWORD nNameType = 0; CertGetNameString(pctx, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, &amp;nNameType, sName, nNameSize); //得到证书的主题或颁发者名称并且把它转换成字符串 strcpy(userName, (char*)sName); CertFreeCertificateContext(pctx); return 0; } else { CertFreeCertificateContext(pctx); return -1; }}int getKeyList(){ //1.获取注册表中的Provider printf(&quot;\\n**1**---------------------------------获取Provider-------------------------------\\n&quot;); vector&lt;string&gt; vProvList; GetListProvider(vProvList); int numProv = vProvList.size(); if (numProv == 0) { printf(&quot;获取注册表中的Provider失败\\n&quot;); return -1; } for (int i = 0; i &lt; numProv; i++) { printf(&quot;%s\\n&quot;, vProvList[i].c_str()); } printf(&quot;\\n&quot;); vector&lt;string&gt; vContainer; printf(&quot;\\n**2**---------------------------------取出Container-------------------------------\\n&quot;); //2.获取Provider对应的句柄，枚举Container for (int i = 0; i &lt; numProv; i++) { HCRYPTPROV hProv = NULL; size_t size = vProvList[i].length(); wchar_t* buffer = new wchar_t[size + 1]; MultiByteToWideChar(CP_ACP, 0, vProvList[i].c_str(), size, buffer, size * sizeof(wchar_t)); buffer[size] = 0; //确保以 '\\0' 结尾 if (CryptAcquireContext(&amp;hProv, NULL, buffer, PROV_RSA_FULL, 0)) //获取Provider对应的句柄 { printf(&quot;%s---ok\\n&quot;, vProvList[i].c_str()); BYTE pbData[512] = { 0 }; DWORD cbData = 512; if (CryptGetProvParam(hProv, PP_ENUMCONTAINERS, pbData, &amp;cbData, CRYPT_FIRST)) //枚举container { printf(&quot;[%s]\\n&quot;, pbData); vContainer.push_back((char*)pbData); memset(pbData, 0, sizeof(pbData)); cbData = 512; while (CryptGetProvParam(hProv, PP_ENUMCONTAINERS, pbData, &amp;cbData, CRYPT_NEXT)) { printf(&quot;[%s]\\n&quot;, pbData); vContainer.push_back((char*)pbData); memset(pbData, 0, sizeof(pbData)); cbData = 512; } } else { DWORD errcode = GetLastError(); printf(&quot;[%s]CryptGetProvParam失败！--%d\\n&quot;, vProvList[i].c_str(), errcode); } CryptReleaseContext(hProv, 0); printf(&quot;\\n&quot;); } else { DWORD errcode = GetLastError(); printf(&quot;[%s]------CryptAcquireContext失败！---%d\\n&quot;, vProvList[i].c_str(), errcode); } } printf(&quot;\\n**3**---------------------------------取出Container对应证书-------------------------------\\n&quot;); //3.打开Container、Provider对应的加密设备，取出签名证书，取出证书信息（颁发机构标识符等） for (size_t i = 0; i &lt; vContainer.size(); i++) { for (int j = 0; j &lt; numProv; j++) { HCRYPTPROV hProv = NULL; if (CryptAcquireContext(&amp;hProv, (LPCWSTR)vContainer[i].c_str(), (LPCWSTR)vProvList[j].c_str(), PROV_RSA_FULL, 0)) { printf(&quot;[%s]------open container ok\\n&quot;, vContainer[i].c_str()); BYTE pbData[512] = { 0 }; DWORD cbData = 512; BYTE pCertificate[4096] = { 0 }; DWORD certificateLen = 4096; if (!GetCertificate(hProv, pCertificate, &amp;certificateLen)) //获取签名证书 { char userName[255] = { 0 }; char keyID[255] = { 0 }; if (!DecodeX509Cert(pCertificate, certificateLen, keyID, userName)) //获取证书【颁发机构标识符】-【用户名】 { printf(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;证书信息\\n&quot;); printf(&quot;keyID=%s\\n&quot;, keyID); printf(&quot;userName=%s\\n&quot;, userName); } } CryptReleaseContext(hProv, 0); printf(&quot;\\n&quot;); } else { printf(&quot;[%s]------CryptAcquireContext失败！\\n&quot;, vProvList[j].c_str()); } } } return 0;}int main(){ char buffer[100] = { 0 }; getcwd(buffer, 100); printf(&quot;%s\\n&quot;, buffer); getKeyList(); printf(&quot;\\n\\n########################################################################\\n\\n&quot;); Sleep(1000); getKeyList(); getchar(); return 0;} 代码2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;#include &lt;wincrypt.h&gt;void main() { HCRYPTPROV hProv; BYTE* puBuffer = (BYTE*)&quot;data hash and sign.one plus.&quot;; DWORD dwBufferLen = strlen((char*)puBuffer) + 1; HCRYPTHASH hHash; HCRYPTKEY hKey; //签名密钥句柄 HCRYPTKEY hPubKey; BYTE* pbKeyBlob; //保存密钥blob缓冲区指针 BYTE* pbSignature; DWORD dwSigLen; DWORD dwBlobLen; DWORD i; if (CryptAcquireContext(&amp;hProv, (LPCWSTR)&quot;test&quot;, NULL, PROV_RSA_FULL, 0)) printf(&quot;打开句柄成功\\n&quot;); else { if (!CryptAcquireContext(&amp;hProv, (LPCWSTR)&quot;test&quot;, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET)) printf(&quot;创建失败。\\n&quot;); } if (CryptGetUserKey(hProv, AT_SIGNATURE, &amp;hKey)) printf(&quot;获得签名密钥成功。\\n&quot;); else { printf(&quot;获取失败，现在创建新的RSA密钥对。\\n&quot;); if (!CryptAcquireContext(&amp;hProv, (LPCWSTR)&quot;test&quot;, NULL, PROV_RSA_FULL, 0)) printf(&quot;获取CSP句柄失败\\n&quot;); if (!CryptGenKey(hProv, 2, CRYPT_EXPORTABLE | 0X04000000, &amp;hKey)) printf(&quot;CryptGenKey error.\\n&quot;); } if (CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, NULL, &amp;dwBlobLen)) printf(&quot;we get the length of the public key.\\n&quot;); else printf(&quot;CryptExportKey erro.\\n&quot;); if (pbKeyBlob = (BYTE*)malloc(dwBlobLen)) printf(&quot;we get the memory.\\n&quot;); else printf(&quot;malloc erro.\\n&quot;); if (CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, pbKeyBlob, &amp;dwBlobLen)) printf(&quot;export the public key.\\n&quot;); else printf(&quot;CryptExportKeya error.\\n&quot;); if (CryptCreateHash(hProv, CALG_SHA1, 0, 0, &amp;hHash)) printf(&quot;CreateHash succeed.\\n&quot;); else printf(&quot;CreatHash error.\\n&quot;); //获得摘要 if (CryptHashData(hHash, puBuffer, dwBufferLen, 0)) printf(&quot;HashData succeed.\\n &quot;); else printf(&quot;HashData error.\\n&quot;); dwSigLen = 0; if (CryptSignHash(hHash, AT_SIGNATURE, NULL, 0, NULL, &amp;dwSigLen)) printf(&quot;Get the length of signature.\\n&quot;); else printf(&quot;CryptSignHash error.\\n&quot;); if (pbSignature = (BYTE*)malloc(dwSigLen)) printf(&quot;get the memory.\\n&quot;); else printf(&quot;memory error.\\n&quot;); //获得签名 if (CryptSignHash(hHash, AT_SIGNATURE, NULL, 0, pbSignature, &amp;dwSigLen)) printf(&quot;signature succeed.\\n&quot;); else printf(&quot;Signature error.\\n&quot;); printf(&quot;Signature: \\n&quot;); for (i = 0; i &lt; dwSigLen; i++) { if ((i == 0) &amp;&amp; (i != 0)) printf(&quot;\\n&quot;); //小数点后的数字代表最大宽度,小数点前的数字代表最小宽度，十六进制输出 printf(&quot;%2.2x&quot;, pbSignature[i]); } printf(&quot;\\n&quot;); printf(&quot;OK.\\n&quot;); if (hHash) CryptDestroyHash(hHash); if (CryptImportKey(hProv, pbKeyBlob, dwBlobLen, 0, 0, &amp;hPubKey)) printf(&quot;Import the key.\\n&quot;); else printf(&quot;erro&quot;); if (CryptCreateHash(hProv, CALG_SHA1, 0, 0, &amp;hHash)) printf(&quot;创建哈希对象成功 \\n&quot;); else printf(&quot;调用CryptCreateHash失败&quot;); if (CryptHashData(hHash, puBuffer, dwBufferLen, 0)) printf(&quot;数据哈希完成.\\n&quot;); else printf(&quot;调用CryptHashData失败&quot;); if (CryptVerifySignature(hHash, pbSignature, dwSigLen, hPubKey, NULL, 0)) printf(&quot;验证签名成功。\\n&quot;); else printf(&quot;签名验证失败，签名无效&quot;); if (pbSignature) free(pbSignature); if (hHash) CryptDestroyHash(hHash); if (hProv) CryptReleaseContext(hProv, 0); system(&quot;pause&quot;);} 代码1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;wincrypt.h&gt;#define MY_ENCODING_TYPE (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)#define KEYLENGTH 0x00800000void HandleError(const char* s);//--------------------------------------------------------------------// These additional #define statements are required.#define ENCRYPT_ALGORITHM CALG_RC4 #define ENCRYPT_BLOCK_SIZE 8 // Declare the function EncryptFile. The function definition// follows main.BOOL EncryptFile( PCHAR szSource, PCHAR szDestination, PCHAR szPassword);//--------------------------------------------------------------------// Begin main.void main(void){ CHAR szSource[100]; CHAR szDestination[100]; CHAR szPassword[100]; printf(&quot;Encrypt a file. \\n\\n&quot;); printf(&quot;Enter the name of the file to be encrypted: &quot;); scanf(&quot;%s&quot;, szSource); printf(&quot;Enter the name of the output file: &quot;); scanf(&quot;%s&quot;, szDestination); printf(&quot;Enter the password:&quot;); scanf(&quot;%s&quot;, szPassword); //-------------------------------------------------------------------- // Call EncryptFile to do the actual encryption. if (EncryptFile(szSource, szDestination, szPassword)) { printf(&quot;Encryption of the file %s was a success. \\n&quot;, szSource); printf(&quot;The encrypted data is in file %s.\\n&quot;, szDestination); } else { HandleError(&quot;Error encrypting file!&quot;); }} // End of main//--------------------------------------------------------------------// Code for the function EncryptFile called by main.static BOOL EncryptFile( PCHAR szSource, PCHAR szDestination, PCHAR szPassword) //-------------------------------------------------------------------- // Parameters passed are: // szSource, the name of the input, a plaintext file. // szDestination, the name of the output, an encrypted file to be // created. // szPassword, the password.{ //-------------------------------------------------------------------- // Declare and initialize local variables. FILE* hSource; FILE* hDestination; HCRYPTPROV hCryptProv; HCRYPTKEY hKey; HCRYPTHASH hHash; PBYTE pbBuffer; DWORD dwBlockLen; DWORD dwBufferLen; DWORD dwCount; //-------------------------------------------------------------------- // Open source file. if (hSource = fopen(szSource, &quot;rb&quot;)) { printf(&quot;The source plaintext file, %s, is open. \\n&quot;, szSource); } else { HandleError(&quot;Error opening source plaintext file!&quot;); } //-------------------------------------------------------------------- // Open destination file. if (hDestination = fopen(szDestination, &quot;wb&quot;)) { printf(&quot;Destination file %s is open. \\n&quot;, szDestination); } else { HandleError(&quot;Error opening destination ciphertext file!&quot;); } //以下获得一个CSP句柄 if (CryptAcquireContext( &amp;hCryptProv, NULL, //NULL表示使用默认密钥容器，默认密钥容器名 //为用户登陆名 NULL, PROV_RSA_FULL, 0)) { printf(&quot;A cryptographic provider has been acquired. \\n&quot;); } else { if (CryptAcquireContext( &amp;hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))//创建密钥容器 { //创建密钥容器成功，并得到CSP句柄 printf(&quot;A new key container has been created.\\n&quot;); } else { HandleError(&quot;Could not create a new key container.\\n&quot;); } } //-------------------------------------------------------------------- // 创建一个会话密钥（session key） // 会话密钥也叫对称密钥，用于对称加密算法。 // （注: 一个Session是指从调用函数CryptAcquireContext到调用函数 // CryptReleaseContext 期间的阶段。会话密钥只能存在于一个会话过程） //-------------------------------------------------------------------- // Create a hash object. if (CryptCreateHash( hCryptProv, CALG_MD5, 0, 0, &amp;hHash)) { printf(&quot;A hash object has been created. \\n&quot;); } else { HandleError(&quot;Error during CryptCreateHash!\\n&quot;); } //-------------------------------------------------------------------- // 用输入的密码产生一个散列 if (CryptHashData( hHash, (BYTE*)szPassword, strlen(szPassword), 0)) { printf(&quot;The password has been added to the hash. \\n&quot;); } else { HandleError(&quot;Error during CryptHashData. \\n&quot;); } //-------------------------------------------------------------------- // 通过散列生成会话密钥 if (CryptDeriveKey( hCryptProv, ENCRYPT_ALGORITHM, hHash, KEYLENGTH, &amp;hKey)) { printf(&quot;An encryption key is derived from the password hash. \\n&quot;); } else { HandleError(&quot;Error during CryptDeriveKey!\\n&quot;); } //-------------------------------------------------------------------- // Destroy the hash object. CryptDestroyHash(hHash); hHash = NULL; //-------------------------------------------------------------------- // The session key is now ready. //-------------------------------------------------------------------- // 因为加密算法是按ENCRYPT_BLOCK_SIZE 大小的块加密的，所以被加密的 // 数据长度必须是ENCRYPT_BLOCK_SIZE 的整数倍。下面计算一次加密的 // 数据长度。 dwBlockLen = 1000 - 1000 % ENCRYPT_BLOCK_SIZE; //-------------------------------------------------------------------- // Determine the block size. If a block cipher is used, // it must have room for an extra block. if (ENCRYPT_BLOCK_SIZE &gt; 1) dwBufferLen = dwBlockLen + ENCRYPT_BLOCK_SIZE; else dwBufferLen = dwBlockLen; //-------------------------------------------------------------------- // Allocate memory. if (pbBuffer = (BYTE*)malloc(dwBufferLen)) { printf(&quot;Memory has been allocated for the buffer. \\n&quot;); } else { HandleError(&quot;Out of memory. \\n&quot;); } //-------------------------------------------------------------------- // In a do loop, encrypt the source file and write to the source file. do { //-------------------------------------------------------------------- // Read up to dwBlockLen bytes from the source file. dwCount = fread(pbBuffer, 1, dwBlockLen, hSource); if (ferror(hSource)) { HandleError(&quot;Error reading plaintext!\\n&quot;); } //-------------------------------------------------------------------- // 加密数据 if (!CryptEncrypt( hKey, //密钥 0, //如果数据同时进行散列和加密，这里传入一个 //散列对象 feof(hSource), //如果是最后一个被加密的块，输入TRUE.如果不是输 //入FALSE这里通过判断是否到文件尾来决定是否为 //最后一块。 0, //保留 pbBuffer, //输入被加密数据，输出加密后的数据 &amp;dwCount, //输入被加密数据实际长度，输出加密后数据长度 dwBufferLen)) //pbBuffer的大小。 { HandleError(&quot;Error during CryptEncrypt. \\n&quot;); } //-------------------------------------------------------------------- // Write data to the destination file. fwrite(pbBuffer, 1, dwCount, hDestination); if (ferror(hDestination)) { HandleError(&quot;Error writing ciphertext.&quot;); } } while (!feof(hSource)); //-------------------------------------------------------------------- // End the do loop when the last block of the source file has been // read, encrypted, and written to the destination file. //-------------------------------------------------------------------- // Close files. if (hSource) fclose(hSource); if (hDestination) fclose(hDestination); //-------------------------------------------------------------------- // Free memory. if (pbBuffer) free(pbBuffer); //-------------------------------------------------------------------- // Destroy session key. if (hKey) CryptDestroyKey(hKey); //-------------------------------------------------------------------- // Destroy hash object. if (hHash) CryptDestroyHash(hHash); //-------------------------------------------------------------------- // Release provider handle. if (hCryptProv) CryptReleaseContext(hCryptProv, 0); return(TRUE);} // End of Encryptfile//--------------------------------------------------------------------// This example uses the function HandleError, a simple error// handling function, to print an error message to the standard error // (stderr) file and exit the program. // For most applications, replace this function with one // that does more extensive error reporting.void HandleError(const char* s){ fprintf(stderr, &quot;An error occurred in running the program. \\n&quot;); fprintf(stderr, &quot;%s\\n&quot;, s); fprintf(stderr, &quot;Error number %x.\\n&quot;, GetLastError()); fprintf(stderr, &quot;Program terminating. \\n&quot;); exit(1);} // End of HandleError","link":"/2020/09/30/%E5%BE%AE%E8%BD%AF%E7%9A%84CSP%E6%9E%B6%E6%9E%84/"},{"title":"c++基础语法","text":"vscode的cpp配置https://zhuanlan.zhihu.com/p/87864677 task.json 1234567891011121314151617181920212223242526272829{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;g++.exe build active file&quot;,//任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置 &quot;command&quot;: &quot;D:\\\\Program Files (x86)\\\\mingw64\\\\bin\\\\g++.exe&quot;, &quot;args&quot;: [//编译时候的参数 &quot;-g&quot;,//添加gdb调试选项 &quot;${file}&quot;, &quot;-o&quot;,//指定生成可执行文件的名称 &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;D:\\\\Program Files (x86)\\\\mingw64\\\\bin&quot; }, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true//表示快捷键Ctrl+Shift+B可以运行该任务 } } ]} launch.json 12345678910111213141516171819202122232425262728293031{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;preLaunchTask&quot;: &quot;g++.exe build active file&quot;,//调试前执行的任务，就是之前配置的tasks.json中的label字段 &quot;type&quot;: &quot;cppdbg&quot;,//配置类型，只能为cppdbg &quot;request&quot;: &quot;launch&quot;,//请求配置类型，可以为launch（启动）或attach（附加） &quot;program&quot;: &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot;,//调试程序的路径名称 &quot;args&quot;: [],//调试传递参数 &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true,//true显示外置的控制台窗口，false显示内置终端 &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\\\Program Files (x86)\\\\mingw64\\\\bin\\\\gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ] } ]} LPWSTR to char* 转换https://blog.csdn.net/moonlightpeng/article/details/80821872?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight 1234int num = WideCharToMultiByte(CP_OEMCP, NULL, (LPWSTR)szKeyName, -1, NULL, 0, NULL, FALSE); char* pchar = new char[num]; WideCharToMultiByte(CP_OEMCP, NULL, (LPWSTR)szKeyName, -1, pchar, num, NULL, FALSE); printf(&quot;%s\\n&quot;, pchar); string to LPCWSTRhttps://blog.csdn.net/wangshubo1989/article/details/50274103 1234size_t size = vProvList[i].length(); wchar_t* buffer = new wchar_t[size + 1]; MultiByteToWideChar(CP_ACP, 0, vProvList[i].c_str(), size, buffer, size * sizeof(wchar_t)); buffer[size] = 0; //确保以 '\\0' 结尾 char转wchar_t123456789char *s = &quot;一二三四五六七八&quot;; DWORD dwNum = MultiByteToWideChar(CP_ACP, 0, s, -1, NULL, 0); // 转换成 宽字节大小9 (8+1) WCHAR *wch = new WCHAR[dwNum]; // 按宽字节 new 内存 memset(wch, 0, dwNum*sizeof(wchar_t)); // 全置0 可以用这句 memset(wch, 0, sizeof(wch)); // memset( the_array, '\\0', sizeof(the_array) ); 这是将一个数组的所以分量设置成零的很便捷的方法 MultiByteToWideChar(CP_ACP, 0, s, -1, wch, dwNum*sizeof(wchar_t)); //s转换到宽字节wch wcout &lt;&lt; wch &lt;&lt; endl; // 宽字节输出","link":"/2020/09/26/cpp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"vs编译器相关问题","text":"c++fopen函数unsafehttps://blog.csdn.net/sgfmby1994/article/details/80432205 输入_CRT_SECURE_NO_WARNINGS 打不开源文件12在已安装好的情况下,编译时报E1696等一堆错误时,可采用此方法解决该问题.工具 -&gt; 获取工具和功能 -&gt; 在windows平台开发中的可选项中将windows 10SDK (10.0.177630.0)勾选上安装即可解决. https://blog.csdn.net/weixin_44094541/article/details/103854082?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight vs2019添加外部包项目目录，把openssl的bin、lib、include目录拷贝进来 引入include目录../../include 引入lib目录../../lib 导入lib里面的libcrypto.lib文件名 这部要留意，如果显示“无法解析的外部符号 _BIO_new，函数 “void __cdecl Base64Decode(char const *,unsigned char * *,unsigned int *)” (?Base64Decode@@YAXPBDPAPAEPAI@Z) 中引用了该符号”的错误就是没有导入该文件。 运行结果图：","link":"/2020/09/24/vs%E7%BC%96%E8%AF%91%E5%99%A8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"},{"title":"求职经验笔记","text":"CYCJava后台岗位 华科大学长的c++岗位 南开学长的C++岗https://www.nowcoder.com/tutorial/10018/index 腾讯后台c++学习路线https://www.nowcoder.com/discuss/164781?type=0&amp;order=4&amp;pos=1&amp;page=11","link":"/2020/12/30/%E6%B1%82%E8%81%8C%E7%BB%8F%E9%AA%8C%E7%AC%94%E8%AE%B0/"},{"title":"栈、队列、堆","text":"b站：https://www.bilibili.com/video/BV1GW411Q77S?p=1 知乎：https://zhuanlan.zhihu.com/p/143334754 STL基础栈： 1234567#include&lt;stack&gt;std::stack&lt;int&gt; S;S.top()：取出栈顶S.empty()：判断栈是否为空S.push(x)：将x添加至栈S.pop()·弹出栈顶S.size()栈的存储元累个数 队列： 12345678#include&lt;queue&gt;std::queue&lt;int&gt; Q;Q.empty():判断队列是否为空，return://true if the underlying container's size is 0, false otherwise.Q.front():返回队列头部元素Q.back():返回队列尾部元素Q.pop()：出队列头部元素Q.push(x)：将×添加至队列Q.size()：返回队列的存储元禦的个数 225.用队列实现栈：链接：https://leetcode-cn.com/problems/implement-stack-using-queues 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyStack {public: /** Initialize your data structure here. */ MyStack() { } queue&lt;int&gt; stackWithQ; /** Push element x onto stack. */ void push(int x) { queue&lt;int&gt; temp; temp.push(x); while(!stackWithQ.empty()){ temp.push(stackWithQ.front()); stackWithQ.pop(); } while(!temp.empty()){ stackWithQ.push(temp.front()); temp.pop(); } } /** Removes the element on top of the stack and returns that element. */ int pop() { int temp1; temp1 = stackWithQ.front(); stackWithQ.pop(); return temp1; } /** Get the top element. */ int top() { return stackWithQ.front(); } /** Returns whether the stack is empty. */ bool empty() { return stackWithQ.empty(); }};/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 232.用栈实现队列 https://leetcode-cn.com/problems/implement-queue-using-stacks/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyQueue {public: /** Initialize your data structure here. */ MyQueue() { } stack&lt;int&gt; queueData; stack&lt;int&gt; queueTemp; /** Push element x to the back of queue. */ void push(int x) { //queueTemp.push(x); while(!queueData.empty()){ queueTemp.push(queueData.top()); queueData.pop(); } queueTemp.push(x); while(!queueTemp.empty()){ queueData.push(queueTemp.top()); queueTemp.pop(); } } /** Removes the element from in front of queue and returns that element. */ int pop() { int temp = queueData.top(); queueData.pop(); return temp; } /** Get the front element. */ int peek() { return queueData.top(); } /** Returns whether the queue is empty. */ bool empty() { return queueData.empty(); }};/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */ 215 最小栈123456789101112131415161718192021222324252627282930313233class MinStack {public: /** initialize your data structure here. */ MinStack() { } std::stack&lt;int&gt; dataStack; std::stack&lt;int&gt; _minStack; void push(int x) { dataStack.push(x); if(_minStack.empty()){ _minStack.push(x);//这里写成dataStack.push(x)了 }else{ if(x &gt; _minStack.top()){ x = _minStack.top(); } _minStack.push(x); } } void pop() { dataStack.pop(); _minStack.pop(); } int top() { return dataStack.top(); } int getMin() { return _minStack.top(); }}; 222.基本计算器（栈）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//并不能提交成功#include&lt;stack&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Solution {public: stack&lt;int&gt; numStack; stack&lt;int&gt; operatorStack; void compute(){ if(numStack.size() &lt; 2){ return; }else{ int temp2 = numStack.top(); numStack.pop(); int temp1 = numStack.top(); numStack.pop(); if(operatorStack.top() == '+'){ numStack.push(temp1 + temp2); }else if(operatorStack.top() == '-'){ numStack.push(temp1 - temp2); } operatorStack.pop(); } } int calculate(string s) { static const int BEGIN_STATE = 0; static const int NUM_STATE = 1; static const int OPERATOR_STATE = 2; int state = BEGIN_STATE; int num = 0; int computeFlag = 0; for(int i = 0; i &lt; s.length(); i++){ if(s[i] == ' ') continue; switch(state){ case BEGIN_STATE: if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9'){ state = NUM_STATE; }else{ state = OPERATOR_STATE; } i--; break; case NUM_STATE: if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9'){ num = num*10 +(s[i] - '0'); }else{ numStack.push(num); num = 0; if(computeFlag == 1){ compute(); } state = OPERATOR_STATE; i--; } break; case OPERATOR_STATE: if(s[i] == '('){ computeFlag = 0; state = NUM_STATE; }else if(s[i] == ')'){ if(computeFlag == 1){ compute(); } }else if(s[i] == '+' || s[i] == '-'){ operatorStack.push(s[i]); computeFlag = 1; }else{ state = NUM_STATE; i--; } break; } } if(num != 0){ numStack.push(num); num = 0; compute(); } if(numStack.empty()){ return 0; } return numStack.top(); }};int main(){ string s = &quot;-2+1&quot;; Solution solu; cout&lt;&lt;solu.calculate(s);} STL-堆，优先级队列priority_queue声明： priority_queue&lt;Type, Container, Functional&gt; 默认最大堆：priority_queue p; 最小堆的声明：priority_queue&lt;int, vector, greater &gt; p; 123456789和队列基本操作相同:top 访问队头元素empty 队列是否为空size 返回队列内元素个数push 插入元素到队尾 (并排序)emplace 原地构造一个元素并插入队列pop 弹出队头元素swap 交换内容 215.数组中的第k大个元素-堆1234567891011121314151617class Solution {public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; Q; for(int i = 0; i &lt; nums.size(); i++){ if(Q.size() &lt; k){ Q.push(nums[i]); }else{ if(nums[i] &gt; Q.top()){ Q.pop(); Q.push(nums[i]); } } } return Q.top(); }}; 295.数据流中的中位数-堆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MedianFinder {public: /** initialize your data structure here. */ MedianFinder() { } void addNum(int num) { if(big_queue.empty()){ big_queue.push(num); }else if(big_queue.size() == small_queue.size()){ if(num &lt; big_queue.top()){ big_queue.push(num); }else{ small_queue.push(num); } }else if(big_queue.size() &gt; small_queue.size()){ if(num &gt; big_queue.top()){ small_queue.push(num); }else{ small_queue.push(big_queue.top()); big_queue.pop(); big_queue.push(num); } }else{ if(num &lt; small_queue.top()){ big_queue.push(num); }else{ big_queue.push(small_queue.top()); small_queue.pop(); small_queue.push(num); } } } double findMedian() { if(small_queue.size() == big_queue.size()){ return ((double)small_queue.top() + (double)big_queue.top())/2; }else if(small_queue.size() &lt; big_queue.size()){ return big_queue.top(); }else{ return small_queue.top(); } }private: priority_queue&lt;int&gt; big_queue; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; small_queue;};","link":"/2021/01/10/%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E5%A0%86/"},{"title":"排序","text":"排序类总结 颜色分类 (medium 快排) 排序链表 (medium 归并 堆排序) 数组中的第K个最大元素 (medium 快速排序 堆) 前K个高频元素 (medium 桶排序 堆) 最大间距 (hard 桶排序) 排序总结颜色分类LeetCode中文 LeetCode英文 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 解答方法1：计数排序哈希表统计每个颜色代表的数字出现的次数，然后更新原数组，按照0,1,2各自的个数按照顺序赋值。 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if(len == 0) return; vector&lt;int&gt; hash(3,0); for(int i=0;i&lt;len;i++) { hash[nums[i]]++; } int j = 0; for(int i=0;i&lt;3;i++) { while(hash[i] &gt; 0) { nums[j++] = i; hash[i]--; } } }};class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int length = nums.size(); if(length == 0) return; vector&lt;int&gt; hash(3,0); for(int i = 0; i &lt; length; i++){ hash[nums[i]]++; } int j = 0; for(int i = 0; i &lt; 3; i++){ while(hash[i] &gt; 0){ nums[j] = i; j++; hash[i]--; } } return; }}; 方法2：荷兰国旗问题定义两个指针，指针r指向数组开头前一个位置(代表红色)，指针b指向数组末尾后一个位置(代表蓝色)，然后从前向后遍历数组，对于遍历的每一个元素nums[w](w起始位置为0)，处理情况如下： 如果nums[w] == 0，则r后移一个位置，然后交换nums[r]和nums[w]的值，w后移一个位置； 如果nums[w] == 2，则b前移一个位置，然后交换nums[b]和nums[w]的值，w位置不变； 如果nums[w] == 1，则w后移一个位置。 直到w == b时，结束遍历。 时间复杂度：O(n) 空间复杂度：O(1) 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int r = -1,w = 0,b = nums.size(); while(w &lt; b) { if(nums[w] == 0) { swap(nums[++r],nums[w++]); } else if(nums[w] == 2) { swap(nums[--b],nums[w]); } else { ++w; } } }}; int front = -1, rear = nums.size(); for(int i = 0; i &lt; rear;){//i&lt;=rear不行 if(nums[i] == 0){ front++; int temp = nums[front]; nums[front] = nums[i]; nums[i] = temp; i++; }else if(nums[i] == 1){ i++; }else{ rear--; int temp = nums[rear]; nums[rear] = nums[i]; nums[i] = temp; } } 排序链表LeetCode中文 LeetCode英文 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解答方法1归并排序 + 链表 时间复杂度：O(n log n) 空间复杂度：O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* sortList(ListNode* head) { if(!head || !head-&gt;next) return head; ListNode *slow = head,*fast = head; while(fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } ListNode *p1 = head,*p2 = slow-&gt;next; slow-&gt;next = nullptr; p1 = sortList(p1); p2 = sortList(p2); ListNode node(0),*head1 = &amp;node; while(p1 &amp;&amp; p2) { if(p1-&gt;val &lt; p2-&gt;val) { head1-&gt;next = p1; head1 = p1; p1 = p1-&gt;next; } else{ head1-&gt;next = p2; head1 = p2; p2 = p2-&gt;next; } } if(p1) head1-&gt;next = p1; if(p2) head1-&gt;next = p2; return node.next; }}; 方法2堆排序（优先级队列） + 链表 时间复杂度：O(n log n) 空间复杂度：O(n) 使用优先级队列priority_queue（底层用堆实现） 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */inline bool comp(const ListNode* p1,const ListNode* p2){ return p1-&gt;val &gt; p2-&gt;val;}class Solution {public: ListNode* sortList(ListNode* head) { priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,decltype(comp)*&gt; que(comp); ListNode* p = head; while(p) { que.push(p); p = p-&gt;next; } ListNode node(0),*head1 = &amp;node; while(!que.empty()) { auto tmp = que.top(); que.pop(); head1-&gt;next = tmp; head1 = head1-&gt;next; } head1-&gt;next = nullptr; return node.next; }}; 直接用STL中heap的接口：make_heap, push_heap ,pop_heap。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */inline bool comp(const ListNode* p1,const ListNode* p2){ return p1-&gt;val &gt; p2-&gt;val;}class Solution {public: ListNode* sortList(ListNode* head) { vector&lt;ListNode*&gt; vec; ListNode* p = head; while(p) { vec.push_back(p); p = p-&gt;next; } make_heap(vec.begin(),vec.end(),comp); ListNode node(0),*head1 = &amp;node; while(!vec.empty()) { auto tmp = vec.front(); pop_heap(vec.begin(),vec.end(),comp); vec.pop_back(); head1-&gt;next = tmp; head1 = head1-&gt;next; } head1-&gt;next = nullptr; return node.next; }}; 数组中的第K个最大元素LeetCode中文 LeetCode英文 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解答方法1:堆维护一个最小堆min，将nums前k个元素nums[i](0 &lt;= i &lt; k )放入min中，然后遍历第k个元素之后的元素nums[i](k &lt;= i &lt;= len)，比较nums[i]和堆顶元素tmp： 如果nums[i] &gt; tmp，则从堆中弹出堆顶元素tmp，同时将num[i]放入堆中； 否则，跳过 最终，遍历完nums所有元素之后，堆顶元素即为数组nums的第k个最大元素。 时间复杂度：O(n log k) 空间复杂度：O(k) 1234567891011121314151617181920212223242526class Solution {public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); if(k &lt;= 0 || len == 0 || len &lt; k) return 0; vector&lt;int&gt; min(nums.begin(),nums.begin()+k); make_heap(min.begin(),min.end(),greater&lt;int&gt;()); for(int i=k;i&lt;len;i++) { int tmp = min.front(); if(nums[i] &gt; tmp) { pop_heap(min.begin(),min.end(),greater&lt;int&gt;()); min.pop_back(); min.push_back(nums[i]); push_heap(min.begin(),min.end(),greater&lt;int&gt;()); } } return min[0]; }}; 方法2：红黑树利用红黑树自动排序的功能，思路和堆的解法类似，利用STL的multiset结构(底层红黑树实现),排序方式定义为less&lt;int&gt;(从小到大)，最终遍历完nums元素之后，红黑树的第一个元素即为数组第k个最大元素。 时间复杂度：O(n log k) 空间复杂度：O(k) 1234567891011121314151617181920212223class Solution {public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); if(k &lt;= 0 || len == 0 || len &lt; k) return 0; //红黑树实现 multiset&lt;int,less&lt;int&gt;&gt; st(nums.begin(),nums.begin()+k,less&lt;int&gt;()); for(auto it = nums.begin() + k;it != nums.end();it++) { auto iter = st.begin(); if(*iter &lt; *it) { st.erase(iter); st.insert(*it); } } return *(st.begin()); }}; 方法3：快排利用快速排序中的partition功能,partition根据所选的主元pivot，将数组分为三段：左半段 &lt; pivot,中间段 = pivot,右半段 &gt; pivot，设= pivot段的左边缘为l，右边缘为r，维护两个指针start和end确定第k大元素所在区间，同时初始化start = 0，end = len-1，然后partition每处理一次，就比较k-1和l大小以及k-1和r大小，处理情况如下： 如果l &gt; k-1，则第k个最大元素位于&lt; pivot段，令end = l； 如果r &lt; k-1，则第k个最大元素位于&gt; pivot段，令start = r； 如果l &lt;= k-1 &lt;= r，则找到了第k个最大元素，返回nums[k-1]。 假设每次partition处理后，左半段和右半段都被分为对等的两段，此时时间复杂度最优为O(n)，而最坏时间复杂度为O(n2) 时间复杂度：O(n)~O(n2) 空间复杂度：O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution {public: pair&lt;int,int&gt; partition(vector&lt;int&gt;&amp; vec,int l,int r) { int m = l + (r -l)/2; if(vec[l] &gt; vec[r]) swap(vec[l],vec[r]); if(vec[l] &gt; vec[m]) swap(vec[l],vec[m]); if(vec[m] &gt; vec[r]) swap(vec[m],vec[r]); swap(vec[l],vec[m]); int pivot = vec[l]; int len = vec.size(); int more = l; int cur = l+1; int less = r+1; while(cur &lt; less) { if(vec[cur] &gt; pivot) { swap(vec[++more],vec[cur++]); } else if(vec[cur] &lt; pivot) { swap(vec[--less],vec[cur]); } else cur++; } swap(vec[l],vec[more]); more--; return make_pair(more+1,less-1); } int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { //快排partition实现 int len=nums.size(); if(k &lt;= 0 || len == 0 || len &lt; k) return 0; pair&lt;int,int&gt; pr = partition(nums,0,len-1); int start = 0; int end = len - 1; while(k-1 &lt; pr.first || k-1 &gt; pr.second) { if(k-1 &lt; pr.first) { end = pr.first - 1; pr = partition(nums,start,end); } else if(k-1 &gt; pr.second) { start = pr.second + 1; pr = partition(nums,start,end); } } return nums[k-1]; }}; 前K个高频元素LeetCode中文 LeetCode英文 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 12输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 解答方法1：哈希表 + 堆/红黑树首先利用哈希表统计数组每个元素出现的次数，然后问题转化为 数组中的第K个最大元素 的 方法1 和 方法2。 时间复杂度：O(n log k) 空间复杂度：O(k) 方法2：哈希表 + 快排首先利用哈希表统计数组每个元素出现的次数，然后问题转化为 数组中的第K个最大元素 的 方法3。 时间复杂度：O(n)~O(n2) 空间复杂度：O(1) 方法3：桶排序利用桶排序中的计数排序。首先用哈希表统计每个元素的频率，然后创建桶数组bucket，bucket长度为nums.size() + 1，数组下标表示元素的频率，每个桶也是一个数组，内含出现频率等于相应下标i的元素。例如bucket[i]表示出现频率为i的桶，内含所有出现i次的元素。最后，按频率从高到低输出k个数字到结果中。 时间复杂度：O(n) 空间复杂度：O(n) 12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int,int&gt; mp; for(auto a : nums) mp[a]++; vector&lt;int&gt; res; int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; buckets(len+1,vector&lt;int&gt;()); for(auto a : mp) { buckets[a.second].push_back(a.first); } for(int i=len;i&gt;=0;i--) { for(auto b : buckets[i]) { res.push_back(b); k--; if(k == 0) return res; } } return vector&lt;int&gt;(); }}; 最大间距LeetCode中文 LeetCode英文 给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。 如果数组元素个数小于 2，则返回 0。 示例 1: 123输入: [3,6,9,1]输出: 3解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。 示例 2: 123输入: [10]输出: 0解释: 数组元素个数小于 2，因此返回 0。 说明: 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。 解答利用基数排序。首先取桶的个数为nums.size()+1，然后遍历一遍数组找出元素最大值Max和最小值Min，将Min放入第一个桶，Max放入最后一个桶，整个大范围 Max~Min 被平分成多个局部范围，每个桶对应一个局部范围，数组的每个元素都一定位于某一个桶当中，而且由于桶的个数比数组长度大1，那么就一定存在一个空桶，由于第一个桶和最后一个桶都装有元素，所以在这个空桶前面和后面一定都能找到一个最近的非空桶，又因为每个桶的范围大小一样，那么数组排序后最大间距的相邻元素一定不位于同一个桶中，而是一个非空桶的局部最小值和它前一个非空桶的局部最大值之间的差值。因此，找到每个非空桶的局部最小值和局部最大值，找出相邻非空桶局部最小值和局部最大值的最大差值即可。 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution {public: unsigned int getpos(int max,int min,int len,int num) { double a = num - min; double b = max - min; return (unsigned int)(a * len / b); } int maximumGap(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if(len &lt;= 1) return 0; vector&lt;bool&gt; flag(len + 1,false); vector&lt;int&gt; maxs(len + 1,INT_MIN); vector&lt;int&gt; mins(len + 1,INT_MAX); int Max = INT_MIN; int Min = INT_MAX; for(int i=0;i&lt;len;i++) { Min = min(nums[i],Min); Max = max(nums[i],Max); } if(Min == Max) return 0; flag[0] = true; flag[len] = true; for(int i=0;i&lt;len;i++) { unsigned int pos = getpos(Max,Min,len,nums[i]); mins[pos] = min(mins[pos],nums[i]); maxs[pos] = max(maxs[pos],nums[i]); flag[pos] = true; } int res = INT_MIN; bool flag1 = false; int lastMax = maxs[0]; for(int i=1;i&lt;=len;i++) { if(flag[i]) { res = max(res,mins[i] - lastMax); lastMax = maxs[i]; } } return res; }};","link":"/2020/12/31/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"踩坑","slug":"踩坑","link":"/tags/%E8%B8%A9%E5%9D%91/"},{"name":"环境搭建","slug":"环境搭建","link":"/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"ftp","slug":"ftp","link":"/tags/ftp/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"ArrayList","slug":"ArrayList","link":"/tags/ArrayList/"},{"name":"hcl","slug":"hcl","link":"/tags/hcl/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"编译原理","slug":"编译原理","link":"/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"环境搭建","slug":"环境搭建","link":"/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"博客搭建","slug":"环境搭建/博客搭建","link":"/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"ftp配置","slug":"环境搭建/ftp配置","link":"/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ftp%E9%85%8D%E7%BD%AE/"},{"name":"组网技术","slug":"组网技术","link":"/categories/%E7%BB%84%E7%BD%91%E6%8A%80%E6%9C%AF/"},{"name":"深度学习","slug":"深度学习","link":"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"windows窗口程序","slug":"windows窗口程序","link":"/categories/windows%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/"},{"name":"c++安全学","slug":"c-安全学","link":"/categories/c-%E5%AE%89%E5%85%A8%E5%AD%A6/"}]}