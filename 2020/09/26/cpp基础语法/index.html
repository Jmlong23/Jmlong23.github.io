<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>c++基础语法 - topLOW的博客</title><meta description="begin:"><meta property="og:type" content="blog"><meta property="og:title" content="c++基础语法"><meta property="og:url" content="https://sanguocloud.cn/2020/09/26/cpp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"><meta property="og:site_name" content="topLOW的博客"><meta property="og:description" content="begin:"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://sanguocloud.cn/images/202103/4.png"><meta property="article:published_time" content="2020-09-26T04:58:55.000Z"><meta property="article:modified_time" content="2021-04-11T14:36:51.981Z"><meta property="article:author" content="long"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/202103/4.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://sanguocloud.cn/2020/09/26/cpp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},"headline":"topLOW的博客","image":["https://sanguocloud.cn/images/202103/4.png"],"datePublished":"2020-09-26T04:58:55.000Z","dateModified":"2021-04-11T14:36:51.981Z","author":{"@type":"Person","name":"long"},"description":"begin:"}</script><link rel="canonical" href="https://sanguocloud.cn/2020/09/26/cpp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="topLOW的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">目录</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-09-26T04:58:55.000Z" title="2020-09-26T04:58:55.000Z">2020-09-26</time><span class="level-item"><a class="link-muted" href="/categories/cpp/">cpp</a></span><span class="level-item">1 小时 读完 (大约 11125 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">c++基础语法</h1><div class="content"><p>begin:</p>
<a id="more"></a>

<h1 id="cpp开发工程师学习资料"><a href="#cpp开发工程师学习资料" class="headerlink" title="cpp开发工程师学习资料"></a>cpp开发工程师学习资料</h1><p>前言，牛客面经：<a href="https://www.nowcoder.com/tutorial/93/8ba2828006dd42879f3a9029eabde9f1">https://www.nowcoder.com/tutorial/93/8ba2828006dd42879f3a9029eabde9f1</a></p>
<ol>
<li>cpp primer 第5版 </li>
</ol>
<p>c++学习手册：<a href="https://zh.cppreference.com/w/cpp">https://zh.cppreference.com/w/cpp</a></p>
<p>学习笔记：<a href="https://github.com/czs108/Cpp-Primer-5th-Notes-CN">https://github.com/czs108/Cpp-Primer-5th-Notes-CN</a></p>
<ol start="2">
<li><p>stl源码剖析</p>
</li>
<li><p>面经：</p>
</li>
</ol>
<p><a href="https://leetcode-cn.com/u/crystal_yyf/">https://leetcode-cn.com/u/crystal_yyf/</a> </p>
<p><a href="https://blog.csdn.net/qq_41589622/article/details/109813884">https://blog.csdn.net/qq_41589622/article/details/109813884</a></p>
<ol start="4">
<li>剑指offer：</li>
</ol>
<p><a href="https://github.com/gatieme/CodingInterviews">https://github.com/gatieme/CodingInterviews</a></p>
<p><a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/50c26h/">https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/50c26h/</a></p>
<ol start="5">
<li>设计模式：单例模式和工厂模式</li>
</ol>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html">https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html</a></p>
<p><a href="https://www.bilibili.com/video/BV1KW411t7FV">https://www.bilibili.com/video/BV1KW411t7FV</a></p>
<ol start="6">
<li>计算机网络：<a href="https://jiangren.work/2020/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/">https://jiangren.work/2020/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</a></li>
<li>数据库：<a href="https://leetcode-cn.com/u/crystal_yyf/">https://leetcode-cn.com/u/crystal_yyf/</a></li>
<li>项目：网融公司实习</li>
<li>qt:</li>
</ol>
<p>时间、资料、方法</p>
<h1 id="cpp基础"><a href="#cpp基础" class="headerlink" title="cpp基础"></a>cpp基础</h1><h2 id="重载（overload）覆盖（override）和重写（overwrite）区别"><a href="#重载（overload）覆盖（override）和重写（overwrite）区别" class="headerlink" title="重载（overload）覆盖（override）和重写（overwrite）区别"></a>重载（overload）覆盖（override）和重写（overwrite）区别</h2><p>重载指同一作用域内，的同名函数、不同参数类型或者个数不同。称这些函数为重载函数 是静多态的一种。</p>
<p>覆盖指子类重新实现了父类的虚函数，要求同名同参同返回，此时子类虚函数表中只存在子类虚函数入口。是动多态的条件之一。</p>
<p>重写指父类与子类中存在同名函数，不考虑参数与返回值，此时在子类中默认访问子类新的实现体，如果要访问父类版实现，需要显式写出父类作用域，这种情况也称子类隐藏了父类函数。</p>
<p><strong>一、重载（overload）</strong><br>指函数名相同，但是它的参数列表个数或顺序，类型不同。但是不能靠返回类型来判断,即不以返回值类型不同作为函数重载的条件<br>（1）同一类中（在同一个作用域中） ；<br>（2）函数名字相同；<br>（3）参数不同；<br>（4）virtual 关键字可有可无。<br>（5）返回值可以不同；</p>
<p><strong>二、覆盖 （override）</strong><br>是指派生类重新定义基类的虚函数，特征是：<br>（1）不在同一个作用域（分别位于派生类与基类） ；<br>（2）函数名字相同；<br>（3）参数相同；<br>（4）基类函数必须有 virtual 关键字，不能有 static 。<br>（5）返回值相同（或是协变），否则报错；&lt;—-协变这个概念我也是第一次才知道…</p>
<p>（6）重写函数的访问修饰符可以不同。尽管 virtual 是 private 的，派生类中重写改写为 public,protected 也是可以的</p>
<p><strong>三、重写（overwrite）</strong></p>
<p>指父类与子类中存在同名函数，不考虑参数与返回值，此时在子类中默认访问子类新的实现体，如果要访问父类版实现，需要显式写出父类作用域，这种情况也称子类隐藏了父类函数。</p>
<p>（1）不在同一个作用域（分别位于派生类与基类） ；<br>（2）函数名字相同；<br>（3）返回值可以不同；<br>（4）参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载以及覆盖混淆） 。<br>（5）参数相同，但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 。</p>
<h2 id="C-中是如何申请内存的"><a href="#C-中是如何申请内存的" class="headerlink" title="C++中是如何申请内存的"></a>C++中是如何申请内存的</h2><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</p>
<p>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
<p>映射区:存储动态链接库以及调用mmap函数进行的文件映射</p>
<p>堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。</p>
<p>bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</p>
<p>数据段：存储程序中已初始化的全局变量和静态变量</p>
<p>代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p>32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0<del>3G是用户态空间，3</del>4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。</p>
<p><img src="/images/202103/4.png" alt=""></p>
<p><a href="https://www.runoob.com/cplusplus/cpp-dynamic-memory.html">https://www.runoob.com/cplusplus/cpp-dynamic-memory.html</a></p>
<p><a href="https://blog.csdn.net/qq_33266987/article/details/51965221">https://blog.csdn.net/qq_33266987/article/details/51965221</a></p>
<ul>
<li>虚拟内存的五大段，内存的五大分区</li>
</ul>
<p><a href="https://blog.csdn.net/ganpengjin1/article/details/38269989">https://blog.csdn.net/ganpengjin1/article/details/38269989</a></p>
<p>少了一个映射区</p>
<h2 id="new与malloc"><a href="#new与malloc" class="headerlink" title="new与malloc"></a>new与malloc</h2><p>new是关键字不需要引入库，malloc是库函数，</p>
<p>new返回完整类型指针，malloc返回（void*）类型需要强转。</p>
<p>malloc失败返回null指针，new失败抛出异常（bad_alloc）.</p>
<p>new会调用构造函数和析构函数</p>
<table>
<thead>
<tr>
<th align="center">特征</th>
<th align="center">new/delete</th>
<th align="center">malloc/free</th>
</tr>
</thead>
<tbody><tr>
<td align="center">分配内存的位置</td>
<td align="center">自由存储区</td>
<td align="center">堆</td>
</tr>
<tr>
<td align="center">内存分配成功的返回值</td>
<td align="center">完整类型指针</td>
<td align="center">void*</td>
</tr>
<tr>
<td align="center">内存分配失败的返回值</td>
<td align="center">默认抛出异常</td>
<td align="center">返回NULL</td>
</tr>
<tr>
<td align="center">分配内存的大小</td>
<td align="center">由编译器根据类型计算得出</td>
<td align="center">必须显式指定字节数</td>
</tr>
<tr>
<td align="center">处理数组</td>
<td align="center">有处理数组的new版本new[]</td>
<td align="center">需要用户计算数组的大小后进行内存分配</td>
</tr>
<tr>
<td align="center">已分配内存的扩充</td>
<td align="center">无法直观地处理</td>
<td align="center">使用realloc简单完成</td>
</tr>
<tr>
<td align="center">是否相互调用</td>
<td align="center">可以，看具体的operator new/delete实现</td>
<td align="center">不可调用new</td>
</tr>
<tr>
<td align="center">分配内存时内存不足</td>
<td align="center">客户能够指定处理函数或重新制定分配器</td>
<td align="center">无法通过用户代码进行处理</td>
</tr>
<tr>
<td align="center">函数重载</td>
<td align="center">允许</td>
<td align="center">不允许</td>
</tr>
<tr>
<td align="center">构造函数与析构函数</td>
<td align="center">调用</td>
<td align="center">不调用</td>
</tr>
</tbody></table>
<p><a href="https://www.cnblogs.com/qg-whz/p/5140930.html">https://www.cnblogs.com/qg-whz/p/5140930.html</a></p>
<p><a href="https://blog.csdn.net/nie19940803/article/details/76358673">https://blog.csdn.net/nie19940803/article/details/76358673</a></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><a href="https://github.com/czs108/Cpp-Primer-5th-Notes-CN/tree/master/Chapter-15%20Object-Oriented%20Programming">https://github.com/czs108/Cpp-Primer-5th-Notes-CN/tree/master/Chapter-15%20Object-Oriented%20Programming</a></p>
<p>三个条件<br>1、基类有虚函数<br>2、派生类覆盖（override）了基类虚函数。（要求函数名，返值类型，函数参数个数及类型全部匹配。并根据派生类的需要重新定义函数体。可以为任意访问权限）<br>3、通过基类指针或引用指向派生类对象，调用公共接口（虚函数）</p>
<p>如果派生类重写（overwrite）基类的函数比如没加virtual，以及函数重载和模板，那叫静多态，因为函数调用在程序执行前就准备好了。</p>
<h2 id="虚函数表机制"><a href="#虚函数表机制" class="headerlink" title="虚函数表机制"></a>虚函数表机制</h2><p><a href="https://blog.csdn.net/lihao21/article/details/50688337">https://blog.csdn.net/lihao21/article/details/50688337</a></p>
<ul>
<li>虚函数与多态</li>
</ul>
<p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载、模板，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重定义了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。<br>虚函数的实现：在有虚函数的类中，<strong>类的最开始部分是一个虚函数表的指针</strong>，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。（父类和子类分别有自己的虚函数表）使用了虚函数，会增加访问内存开销，降低效率。</p>
<p>C++中，一个类存在虚函数，那么编译器就会为这个类生成一个虚函数表，在虚函数表里存放的是这个类所有虚函数的地址。当生成类对象的时候，编译器会自动的将类对象的前四个字节设置为虚表的地址，而这四个字节就可以看作是一个指向虚函数表的指针。<strong>虚函数表可以看做一个函数指针数组。</strong></p>
<ol>
<li>虚函数表属于类，类的所有对象共享这个类的虚函数表。</li>
<li>虚函数表由编译器在编译时生成，保存在.rdata只读数据段。</li>
</ol>
<p><a href="https://blog.csdn.net/qq_39885372/article/details/105626044">https://blog.csdn.net/qq_39885372/article/details/105626044</a></p>
<p><a href="https://blog.csdn.net/fw72fw72/article/details/68488739?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&amp;dist_request_id=1328707.494.16166787919971027&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs">https://blog.csdn.net/fw72fw72/article/details/68488739?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&amp;dist_request_id=1328707.494.16166787919971027&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs</a></p>
<h3 id="虚函数与数据封装private"><a href="#虚函数与数据封装private" class="headerlink" title="虚函数与数据封装private"></a>虚函数与数据封装private</h3><p>C++中<strong>, 虚函数</strong>可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。</p>
<p>一个成员函数被定义为private属性，标志着其只能被当前类的其他成员函数(或友元函数)所访问。而virtual修饰符则强调父类的成员函数可以在子类中被重写，因为重写之时并没有与父类发生任何的调用关系，故而重写是被允许的。</p>
<p>编译器不检查虚函数的各类属性。被virtual修饰的成员函数，不论他们是private、protect或是public的，都会被统一的放置到虚函数表中。对父类进行派生时，子类会继承到拥有相同偏移地址的虚函数表（相同偏移地址指，各虚函数相对于VPTR指针的偏移），则子类就会被允许对这些虚函数进行覆盖。且覆盖时可以给重载函数定义新的属性，例如public，其只标志着该重载函数在该子类中的访问属性为public，和父类的private属性没有任何关系！</p>
<p><strong>纯虚函数</strong>可以设计成私有的，不过这样不允许在本类之外的非友元函数中直接调用它，子类中只有覆盖这种纯虚函数的义务，却没有调用它的权利。</p>
<p><a href="https://www.cnblogs.com/yangguang-it/p/6547314.html">https://www.cnblogs.com/yangguang-it/p/6547314.html</a></p>
<h2 id="多继承与虚继承"><a href="#多继承与虚继承" class="headerlink" title="多继承与虚继承"></a>多继承与虚继承</h2><p><a href="https://blog.csdn.net/qq_41589622/article/details/109783029">https://blog.csdn.net/qq_41589622/article/details/109783029</a></p>
<p><a href="https://github.com/czs108/Cpp-Primer-5th-Notes-CN/blob/master/Chapter-18%20Tools%20for%20Large%20Programs/README.md#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BFmultiple-and-virtual-inheritance">https://github.com/czs108/Cpp-Primer-5th-Notes-CN/blob/master/Chapter-18%20Tools%20for%20Large%20Programs/README.md#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BFmultiple-and-virtual-inheritance</a></p>
<h3 id="多重继承（Multiple-Inheritance）"><a href="#多重继承（Multiple-Inheritance）" class="headerlink" title="多重继承（Multiple Inheritance）"></a>多重继承（Multiple Inheritance）</h3><p>是指派生类可以有多个基类。多重继承的派生类继承了所有父类的属性。</p>
<h3 id="虚继承（Virtual-Inheritance）"><a href="#虚继承（Virtual-Inheritance）" class="headerlink" title="虚继承（Virtual Inheritance）"></a>虚继承（Virtual Inheritance）</h3><p>尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。如果某个类在派生过程中出现了多次，则派生类中会包含该类的多个子对象。这种默认情况对某些类并不适用，存在二义性。虚继承可以让某个类共享它的基类，其中共享的基类子对象称为虚基类（virtual base class）。在该机制下，不论虚基类在继承体系中出现了多少次，派生类都只包含唯一一个共享的虚基类子对象。</p>
<h2 id="类型转换（Type-Conversions）"><a href="#类型转换（Type-Conversions）" class="headerlink" title="类型转换（Type Conversions）"></a>类型转换（Type Conversions）</h2><p>无须程序员介入，会自动执行的类型转换叫做隐式转换（implicit conversions）。</p>
<ul>
<li>算术转换（Integral Promotions）</li>
</ul>
<p>把一种算术类型转换成另一种算术类型叫做算术转换。</p>
<p>整型提升（integral promotions）负责把小整数类型转换成较大的整数类型。</p>
<ul>
<li>其他隐式类型转换（Other Implicit Conversions）</li>
</ul>
<p>在大多数表达式中，数组名字自动转换成指向数组首元素的指针。</p>
<p>常量整数值0或字面值<code>nullptr</code>能转换成任意指针类型；指向任意非常量的指针能转换成<code>void*</code>；指向任意对象的指针能转换成<code>const void*</code>。</p>
<p>任意一种算术类型或指针类型都能转换成布尔类型。如果指针或算术类型的值为0，转换结果是<code>false</code>，否则是<code>true</code>。</p>
<p>指向非常量类型的指针能转换成指向相应的常量类型的指针。</p>
<ul>
<li>显式转换（Explicit Conversions）</li>
</ul>
<p>显式类型转换也叫做强制类型转换（cast）。命名的强制类型转换（named cast）形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-name&lt;type&gt;(expression);</span><br></pre></td></tr></table></figure>

<p>其中<em>type</em>是转换的目标类型，<em>expression</em>是要转换的值。如果<em>type</em>是引用类型，则转换结果是左值。<em>cast-name</em>是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>中的一种，用来指定转换的方式。</p>
<ul>
<li><code>dynamic_cast</code>：运行时类型识别。当expression指向目标类型时，返回目标类型对象地址，否则返回0，0，720</li>
<li><code>static_cast</code>：用于各种隐式转换，比如非const转const，void*转指针等</li>
<li><code>const_cast</code>：用于将const变量转为非const</li>
<li><code>reinterpret_cast</code>：几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</li>
</ul>
<p>早期版本的C++语言中，显式类型转换包含两种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type (expression);    &#x2F;&#x2F; function-style cast notation</span><br><span class="line">(type) expression;    &#x2F;&#x2F; C-language-style cast notation</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qq_41589622/article/details/106464662">https://blog.csdn.net/qq_41589622/article/details/106464662</a></p>
<h2 id="数组与链表的区别"><a href="#数组与链表的区别" class="headerlink" title="数组与链表的区别"></a>数组与链表的区别</h2><p>链表：可以无限拉链，分配的空间可以不连续</p>
<p>数组：分配的空间必须连续，数组如果溢出，需要新建更大的数组再搬迁数据，比较麻烦。</p>
<p>查找：效率的话，数组是优于链表的，因为通过下标访问是O(1)。而链表需要遍历，O(n)。<br>插入删除：链表比较方便，需要断开节点，插入或者删除节点，而数组可能需要后移数据。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p><a href="https://www.cnblogs.com/lanxuezaipiao/p/4132096.html">https://www.cnblogs.com/lanxuezaipiao/p/4132096.html</a></p>
<p>C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。</p>
<p>为什么要使用智能指针：</p>
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>
<p><a href="https://zhuanlan.zhihu.com/p/79850064">https://zhuanlan.zhihu.com/p/79850064</a></p>
<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><p>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）<br>指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间（是否占内存）<br>指针可以为空，但是引用必须绑定对象（是否可为空）<br>指针可以有多级，但是引用只能一级（是否能为多级）</p>
<p>作者：Crystal<br>链接：<a href="https://leetcode-cn.com/circle/discuss/f40g4J/">https://leetcode-cn.com/circle/discuss/f40g4J/</a></p>
<h2 id="cpp的左值和右值"><a href="#cpp的左值和右值" class="headerlink" title="cpp的左值和右值"></a>cpp的左值和右值</h2><p><em>左值 (lvalue, locator value)</em> 表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</p>
<p><em>右值 (rvalue)</em> 则使用排除法来定义。一个表达式不是 <em>左值</em> 就是 <em>右值</em> 。 那么，右值是一个 <em>不</em> 表示内存中某个可识别位置的对象的表达式。</p>
<p><a href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/</a></p>
<h2 id="cpp程序编译过程"><a href="#cpp程序编译过程" class="headerlink" title="cpp程序编译过程"></a>cpp程序编译过程</h2><p><a href="https://leetcode-cn.com/circle/discuss/f40g4J/">https://leetcode-cn.com/circle/discuss/f40g4J/</a></p>
<p>编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接</p>
<p>编译预处理：处理以 # 开头的指令<br>编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码<br>汇编：将汇编代码 .s 翻译成机器指令 .o 文件<br>链接：汇编程序生成的目标文件并不会立即执行，可能有源文件中的函数引用了另一个源文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。</p>
<p>链接分类：</p>
<p>静态链接：代码从其所在的动态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中<br>动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间</p>
<p>二者的优缺点：</p>
<p>静态链接 浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容<br>动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要进行链接，性能会有一定的损失。</p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>作用域是程序的一个区域，一般来说有三个地方可以定义变量：</p>
<ul>
<li>在函数或一个代码块内部声明的变量，称为局部变量。</li>
<li>在函数参数的定义中声明的变量，称为形式参数。</li>
<li>在所有函数外部声明的变量，称为全局变量。</li>
</ul>
<h2 id="RTTI（run-time-type-identification-运行时类型识别"><a href="#RTTI（run-time-type-identification-运行时类型识别" class="headerlink" title="RTTI（run-time type identification) 运行时类型识别"></a>RTTI（run-time type identification) 运行时类型识别</h2><h2 id="请你回答一下C-中拷贝赋值函数的形参能否进行值传递？"><a href="#请你回答一下C-中拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="请你回答一下C++中拷贝赋值函数的形参能否进行值传递？"></a>请你回答一下C++中拷贝赋值函数的形参能否进行值传递？</h2><p>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。</p>
<h2 id="bits-stdc-h头文件"><a href="#bits-stdc-h头文件" class="headerlink" title="bits/stdc++.h头文件"></a>bits/stdc++.h头文件</h2><p><a href="https://blog.csdn.net/prime_lee/article/details/80489284">https://blog.csdn.net/prime_lee/article/details/80489284</a></p>
<p>很多小伙伴估计看有的代码会碰见没有多余的其它头文件比如algorithm、cmath、iostream而是用了一行#include&lt;bits/stdc++.h&gt;这样的头文件并感到诧异，想这是什么。其实这是一个包含了C++所有头文件的一个头文件，为了方便而发明的，其中包含了一下头文件</p>
<h2 id="fork（）函数"><a href="#fork（）函数" class="headerlink" title="fork（）函数"></a>fork（）函数</h2><p><a href="https://cloud.tencent.com/developer/article/1338482">https://cloud.tencent.com/developer/article/1338482</a></p>
<h2 id="类中的引用成员变量"><a href="#类中的引用成员变量" class="headerlink" title="类中的引用成员变量"></a>类中的引用成员变量</h2><p><a href="https://blog.csdn.net/lazyq7/article/details/48186291">https://blog.csdn.net/lazyq7/article/details/48186291</a></p>
<ul>
<li>请你回答一下C++类内可以定义引用数据成员吗？</li>
</ul>
<p>可以，必须通过成员函数初始化列表初始化。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><a href="https://github.com/czs108/Cpp-Primer-5th-Notes-CN/tree/master/Chapter-18%20Tools%20for%20Large%20Programs#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86exception-handling">https://github.com/czs108/Cpp-Primer-5th-Notes-CN/tree/master/Chapter-18%20Tools%20for%20Large%20Programs#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86exception-handling</a></p>
<h3 id="noexcept异常说明"><a href="#noexcept异常说明" class="headerlink" title="noexcept异常说明"></a>noexcept异常说明</h3><p><a href="https://blog.csdn.net/LaoJiu_/article/details/50781352">https://blog.csdn.net/LaoJiu_/article/details/50781352</a></p>
<h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p><a href="https://blog.csdn.net/bl520025/article/details/8967648">https://blog.csdn.net/bl520025/article/details/8967648</a></p>
<h3 id="lt-lt-移位运算"><a href="#lt-lt-移位运算" class="headerlink" title="&lt;&lt;移位运算"></a>&lt;&lt;移位运算</h3><pre><code>//1*2^(n-1)
int value = 1 &lt;&lt; (n - 1);</code></pre><p><a href="https://stackoverflow.com/questions/10983078/c-what-does-ab-mean#">https://stackoverflow.com/questions/10983078/c-what-does-ab-mean#</a></p>
<p>1 &lt;&lt; 1 means:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000001</span> changes to <span class="number">00000000</span> <span class="number">00000010</span></span><br></pre></td></tr></table></figure>

<p>1 &lt;&lt; 8 means:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000001</span> changes to <span class="number">00000001</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure>

<p>It’s a bit shift operation. For every 1 on the right, you can think of yourself as multiplying the value on the left by 2. So, 2 &lt;&lt; 1 = 4 and 2 &lt;&lt; 2 = 8. This is much more efficient than doing 1 * 2.</p>
<p>Also, you can do 4 &gt;&gt; 1 = 2 (and 5 &gt;&gt; 1 = 2 since you round down) as the inverse operation.</p>
<h2 id="请你说说内存泄漏如何判断"><a href="#请你说说内存泄漏如何判断" class="headerlink" title="请你说说内存泄漏如何判断"></a>请你说说内存泄漏如何判断</h2><p>1.尽量不去手动<a href="https://www.baidu.com/s?wd=分配内存&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">分配内存</a>。比如，我一般不使用数组，而使用STL的vector.</p>
<p> 2.如果需要手动分配数组，尽量使用STL中的分配方式，或者使用STL和BOOST中的<a href="https://www.baidu.com/s?wd=智能指针&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">智能指针</a>。</p>
<p> 3.某些应用，比如MSXML，尽量使用<a href="https://www.baidu.com/s?wd=智能指针&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">智能指针</a>。</p>
<p> 4.凡是使用new和delete的地方，首先注意指针的初始化，然后要注意new和delete的配对，再就是要注意错误的捕捉。很多时候，内存泄漏不是因为new和delete的配对造成的，而是在自己没有考虑到的可能结果中，程序中断而没有delete手动分配的内存.</p>
<p> 5.使用varglind，mtrace检测,不过我只听说过，没用过。</p>
<h2 id="cpp多线程"><a href="#cpp多线程" class="headerlink" title="cpp多线程"></a>cpp多线程</h2><p><a href="https://zhuanlan.zhihu.com/p/194198073">https://zhuanlan.zhihu.com/p/194198073</a></p>
<h2 id="构造函数为什么不能是虚指针"><a href="#构造函数为什么不能是虚指针" class="headerlink" title="构造函数为什么不能是虚指针"></a>构造函数为什么不能是虚指针</h2><p> 虚函数的调用需要虚函数表指针，而该指针存放在对象的内容空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数——构造函数了。</p>
<p><a href="https://www.cnblogs.com/ktao/p/7563289.html">https://www.cnblogs.com/ktao/p/7563289.html</a></p>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p><a href="https://leetcode-cn.com/circle/discuss/qNLDjE/">https://leetcode-cn.com/circle/discuss/qNLDjE/</a></p>
<h3 id="六大组件"><a href="#六大组件" class="headerlink" title="六大组件"></a>六大组件</h3><ul>
<li>空间配置器 allocator:负责动态空间的配置和管理</li>
<li>迭代器 iterators: 在23个设计模式中，有一种是迭代器模式（提供一种方法，使之能够依序访问某个容器所含的各个元素，而无需暴露该容器的内部表述方式），其行为类似于智能指针；STL的设计中，将数据容器和算法分开，彼此独立设计，通过迭代器(容器和算法的胶粘剂)将他们撮合在一起。</li>
<li>容器 containers ：各种数据结构，从实现的角度来看，STL容器是一种class template</li>
<li>算法 algorithms: 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。从实现角度来看，STL算法是一种function template</li>
<li>仿函数 functors:也叫函数对象，行为类似于函数；从实现角度来看，仿函数是重载了operator()的class或者class template </li>
<li>配接器 adapters:用来修饰容器或者迭代器接口</li>
</ul>
<h3 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h3><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><ul>
<li>vector：可变大小的数组。底层数据结构为数组，支持快速随机访问，在尾部之外的位置插入或者删除元素可能很慢</li>
</ul>
<ol>
<li>vector底层存储机制<br>vector是一个动态数组，里面是一个指针指向一片连续的空间，当空间不够用时，会自动申请一块更大的空间（一般是增加当前容量的50%或者100%），然后把原来的数据拷贝过去，接着释放原来的空间；当释放或者删除里面的数据时，其存储空间不释放，仅仅是清空了里面的数据</li>
</ol>
<ul>
<li>string：与vector相似的容器，专门用于存储字符。随机访问快，在尾位置插入/删除速度快</li>
<li>list：双向链表。底层数据结构为双向链表，支持双向顺序访问。在list任何位置插入/删除速度很快</li>
</ul>
<ol>
<li>list以节点为单位存放数据，节点的地址在内存中不一定连续，每次插入或者删除数据时，就配置或者释放一个元素的空间</li>
</ol>
<ul>
<li>deque：双端队列。底层数据结构为一个中央控制器和多个缓冲区，支持快速随机访问，在头尾位置插入/删除速度很快</li>
</ul>
<ol>
<li>deque底层存储机制<br>deque动态的以分段连续的空间组成，随时可以增加一段新的连续的空间并链接起来，不提供空间保留（reserve）功能。<br>deque采用一块map(不是STL的map容器)作为主控，其为一小块连续的空间，其中的每个元素都是指针，指向另一段较大的连续空间（缓冲区）</li>
</ol>
<ul>
<li><p>priority_queue：优先队列。底层用vector实现，堆heap为处理规则来管理底层容器的实现</p>
<p>源码剖析p183</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;queue&gt;</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap;</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;最小堆</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;my_lovely_lemon_tree&#x2F;article&#x2F;details&#x2F;78007316</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>stack：栈。底层用deque实现，封闭头部，在尾部进行插入和删除元素</p>
</li>
<li><p>queue：队列。底层用deque实现</p>
</li>
</ul>
<h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><ul>
<li><p>set：集合。底层为红黑树，元素有序，不重复</p>
</li>
<li><p>map：底层为红黑树，键有序，不重复</p>
<p>红黑树详解：<a href="https://xieguanglei.github.io/blog/post/red-black-tree.html">https://xieguanglei.github.io/blog/post/red-black-tree.html</a></p>
</li>
</ul>
<ol>
<li><p>map底层机制<br>map以红黑树作为底层机制，红黑树是平衡二叉树的一种，在要求上比AVL树更宽泛。通过map的迭代器只能修改其实值，不能修改其键值，所以map的迭代器既不能是const也不是mutable</p>
</li>
<li><p>红黑树满足以下几个条件：<br>每个节点不是红色就是黑色<br>根节点是黑色<br>红色节点的子节点必须是黑色（不能有连续的红节点）<br>从根节点到NULL的任何路径所含的黑节点数目相同<br>叶子节点是黑色的NULL节点（注：这里不是我们常说的二叉树中的叶节点，是它的子节点（NULL））</p>
</li>
<li><p>是弱平衡的二叉搜索树，查找删除添加时间复杂度都是log(n)</p>
</li>
</ol>
<ul>
<li>hash_map：底层为哈希表，无序，不重复</li>
</ul>
<ol>
<li>说一下unordered_map是底层是数组加链表，如果冲突则在相同哈希值的链表尾部添加节点。（拉链法）<br>说说其他解决哈希冲突的方法：再哈希还有线性探测。</li>
</ol>
<h2 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 iterator"></a>迭代器 iterator</h2><p><a href="https://leetcode-cn.com/circle/discuss/musCOX/">https://leetcode-cn.com/circle/discuss/musCOX/</a></p>
<p>数组型数据结构，如vector：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(<em>iter)(或erase(</em>iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);</p>
<p>链表型数据结构，如list：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).</p>
<p>树形数据结构，如set、map： 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。</p>
<p>注意：经过erase(iter)之后的迭代器完全失效，该迭代器iter不能参与任何运算，包括iter++,*ite《大佬的解释》</p>
<h2 id="常见容器的操作时间复杂度"><a href="#常见容器的操作时间复杂度" class="headerlink" title="常见容器的操作时间复杂度"></a>常见容器的操作时间复杂度</h2><p><a href="https://blog.csdn.net/qq_36631379/article/details/108833192">https://blog.csdn.net/qq_36631379/article/details/108833192</a></p>
<h2 id="stl常见容器api总结"><a href="#stl常见容器api总结" class="headerlink" title="stl常见容器api总结"></a>stl常见容器api总结</h2><p><a href="http://vernlium.github.io/2019/12/29/C-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8API%E6%80%BB%E7%BB%93/">http://vernlium.github.io/2019/12/29/C-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8API%E6%80%BB%E7%BB%93/</a></p>
<h2 id="stl常用算法总结"><a href="#stl常用算法总结" class="headerlink" title="stl常用算法总结"></a>stl常用算法总结</h2><p><a href="https://www.cnblogs.com/linuxAndMcu/p/10264339.html">https://www.cnblogs.com/linuxAndMcu/p/10264339.html</a></p>
<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="求二叉树的最大高度"><a href="#求二叉树的最大高度" class="headerlink" title="求二叉树的最大高度"></a>求二叉树的最大高度</h2><p><a href="https://cloud.tencent.com/developer/article/1491138">https://cloud.tencent.com/developer/article/1491138</a></p>
<p><a href="https://www.geeksforgeeks.org/iterative-method-to-find-height-of-binary-tree/">https://www.geeksforgeeks.org/iterative-method-to-find-height-of-binary-tree/</a></p>
<h3 id="二叉树定义与遍历"><a href="#二叉树定义与遍历" class="headerlink" title="二叉树定义与遍历"></a>二叉树定义与遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BiTNode&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	Struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line">void preOrder(BiTree T)&#123;</span><br><span class="line">	if(T !&#x3D; NULL)&#123;</span><br><span class="line">		visit(T);</span><br><span class="line">		preOrder(T-&gt;lchild);</span><br><span class="line">		preOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void layerTrace(BTreeNode *T)</span><br><span class="line">&#123;</span><br><span class="line">	if(T&#x3D;&#x3D; nullptr)return;</span><br><span class="line">	BTreeNode *p&#x3D;T;</span><br><span class="line">	queue&lt;BTreeNode*&gt;q;</span><br><span class="line">	q.push(p);</span><br><span class="line">	while(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		p&#x3D;q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		cout&lt;&lt;&lt;&lt;p-&gt;data;</span><br><span class="line">		if(p-&gt;left!&#x3D; nullptr)q.push(p-&gt;left);</span><br><span class="line">		if(p-&gt;right!&#x3D; nullptr)q.push(p-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>递归遍历</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><a href="https://blog.csdn.net/qq_41589622/article/details/107853558">https://blog.csdn.net/qq_41589622/article/details/107853558</a></p>
<p>王道p330</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/ohwddh/">https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/ohwddh/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void quickSort(vector&lt;int&gt;&amp; arr, int l, int r) &#123;</span><br><span class="line">     &#x2F;&#x2F; 子数组长度为 1 时终止递归</span><br><span class="line">     if (l &gt;&#x3D; r) return;</span><br><span class="line">     &#x2F;&#x2F; 哨兵划分操作（以 arr[l] 作为基准数）</span><br><span class="line">     int i &#x3D; l, j &#x3D; r;</span><br><span class="line">     while (i &lt; j) &#123;</span><br><span class="line">         while (i &lt; j &amp;&amp; arr[j] &gt;&#x3D; arr[l]) j--; &#x2F;&#x2F;不能用i &lt;&#x3D; j，会出错</span><br><span class="line">         while (i &lt; j &amp;&amp; arr[i] &lt;&#x3D; arr[l]) i++;</span><br><span class="line">         swap(arr[i], arr[j]);</span><br><span class="line">     &#125;</span><br><span class="line">     swap(arr[i], arr[l]);</span><br><span class="line">     &#x2F;&#x2F; 递归左（右）子数组执行哨兵划分</span><br><span class="line">     quickSort(arr, l, i - 1);</span><br><span class="line">     quickSort(arr, i + 1, r);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>链表的快速排序（不交换节点只交换值）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *sortList(ListNode *head) &#123;</span><br><span class="line">        &#x2F;&#x2F; IMPORTANT: Please reset any member data you declared, as</span><br><span class="line">        &#x2F;&#x2F; the same Solution instance will be reused for each test case.</span><br><span class="line">        &#x2F;&#x2F;链表快速排序</span><br><span class="line">        if(head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL)return head;</span><br><span class="line">        qsortList(head, NULL);</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    void qsortList(ListNode*head, ListNode*tail)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;链表范围是[low, high)</span><br><span class="line">        if(head !&#x3D; tail &amp;&amp; head-&gt;next !&#x3D; tail)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* mid &#x3D; partitionList(head, tail);</span><br><span class="line">            qsortList(head, mid);</span><br><span class="line">            qsortList(mid-&gt;next, tail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* partitionList(ListNode*low, ListNode*high)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;链表范围是[low, high)</span><br><span class="line">        int key &#x3D; low-&gt;val;</span><br><span class="line">        ListNode* loc &#x3D; low;</span><br><span class="line">        for(ListNode*i &#x3D; low-&gt;next; i !&#x3D; high; i &#x3D; i-&gt;next)</span><br><span class="line">            if(i-&gt;val &lt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                loc &#x3D; loc-&gt;next;</span><br><span class="line">                swap(i-&gt;val, loc-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        swap(loc-&gt;val, low-&gt;val);</span><br><span class="line">        return loc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>又称二分查找</p>
<p>基本思想：首先给定值key与表中中间的位置的元素比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分。然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int Binary_Search(SeqList L, ElemType key)&#123;</span><br><span class="line">	int low &#x3D; 0, high &#x3D; L.length - 1, mid;</span><br><span class="line">	while(low &lt;&#x3D; high)&#123;</span><br><span class="line">		mid &#x3D; (low + high)&#x2F;2;</span><br><span class="line">		if(L[mid] &#x3D;&#x3D; key) return mid;</span><br><span class="line">		else if(L[mid] &gt; key)&#123;</span><br><span class="line">			high &#x3D; mid - 1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			low &#x3D; mid + 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见的排序算法"><a href="#常见的排序算法" class="headerlink" title="常见的排序算法"></a>常见的排序算法</h2><p>1、冒泡排序：</p>
<p>从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，每一轮循环下来找出剩余未排序数的中的最大数并“冒泡”至数列的顶端。</p>
<p>稳定性：稳定</p>
<p>平均时间复杂度：O(n ^ 2)</p>
<p>2、插入排序：</p>
<p>从待排序的n个记录中的第二个记录开始，依次与前面的记录比较并寻找插入的位置，每次外循环结束后，将当前的数插入到合适的位置。</p>
<p>稳定性：稳定</p>
<p>平均时间复杂度：O(n ^ 2)</p>
<p>3、希尔排序（缩小增量排序）：</p>
<p>希尔排序法是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。</p>
<p>希尔排序开始时增量较大，分组较多，每组的记录数目较少，故在各组内采用直接插入排序较快，后来增量di逐渐缩小，分组数减少，各组的记录数增多，但由于已经按di−1分组排序，文件叫接近于有序状态，所以新的一趟排序过程较快。因此希尔 排序在效率上比直接插入排序有较大的改进。</p>
<p>在直接插入排序的基础上，将直接插入排序中的1全部改变成增量d即可，因为希尔排序最后一轮的增量d就为1。</p>
<p>稳定性：不稳定</p>
<p>平均时间复杂度：希尔排序算法的时间复杂度分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。时间复杂度在O(n ^ 1.3)到O(n ^ 2)之间。</p>
<p>4、选择排序：</p>
<p>从所有记录中选出最小的一个数据元素与第一个位置的记录交换；然后在剩下的记录当中再找最小的与第二个位置的记录交换，循环到只剩下最后一个数据元素为止。</p>
<p>稳定性：不稳定</p>
<p>平均时间复杂度：O(n ^ 2)</p>
<p>5、快速排序</p>
<p>1）从待排序的n个记录中任意选取一个记录（通常选取第一个记录）为分区标准;</p>
<p>2）把所有小于该排序列的记录移动到左边，把所有大于该排序码的记录移动到右边，中间放所选记录，称之为第一趟排序；</p>
<p>3）然后对前后两个子序列分别重复上述过程，直到所有记录都排好序。</p>
<p>稳定性：不稳定</p>
<p>平均时间复杂度：O(nlogn)</p>
<p>6、堆排序：</p>
<p>堆：</p>
<p>1、完全二叉树或者是近似完全二叉树。</p>
<p>2、大顶堆：父节点不小于子节点键值，小顶堆：父节点不大于子节点键值。左右孩子没有大小的顺序。</p>
<p>堆排序在选择排序的基础上提出的，步骤：</p>
<p>1、建立堆</p>
<p>2、删除堆顶元素，同时交换堆顶元素和最后一个元素，再重新调整堆结构，直至全部删除堆中元素。</p>
<p>稳定性：不稳定</p>
<p>平均时间复杂度：O(nlogn)</p>
<p>7、归并排序：</p>
<p>采用分治思想，现将序列分为一个个子序列，对子序列进行排序合并，直至整个序列有序。</p>
<p>稳定性：稳定</p>
<p>平均时间复杂度：O(nlogn)</p>
<p>8、桶排序：</p>
<p>步骤：</p>
<p>1）设置一个定量的数组当作空桶子； 常见的排序算法及其复杂度：</p>
<p>2）寻访序列，并且把记录一个一个放到对应的桶子去；</p>
<p>3）对每个不是空的桶子进行排序。</p>
<p>4）从不是空的桶子里把项目再放回原来的序列中。</p>
<p>时间复杂度：O(n+C) ，C为桶内排序时间。</p>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><ol>
<li>构造方法</li>
</ol>
<p>给定n个权值分别为w1，w2,……,wn的结点，构造哈夫曼的算法描述如下：</p>
<p>1) 将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F</p>
<p>2）构造一个新的结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。</p>
<p>3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中</p>
<p>4）重复2）3），直至F中仅剩一棵树为止</p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h3 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h3><p><a href="https://zhuanlan.zhihu.com/p/32754315">https://zhuanlan.zhihu.com/p/32754315</a></p>
<ol>
<li>能显示x509数字证书的信息</li>
<li>用CSP密码服务对信息进行签名与验证</li>
<li>获取u盾的私钥进行签名（数字证书里面没有U盾的私钥），和获取U盾的公钥进行验证</li>
</ol>
<p><strong>证书结构：</strong></p>
<p><a href="https://www.cnblogs.com/jiu0821/p/4598352.html">https://www.cnblogs.com/jiu0821/p/4598352.html</a></p>
<p><a href="https://blog.csdn.net/weixin_34367845/article/details/86145395（实例）">https://blog.csdn.net/weixin_34367845/article/details/86145395（实例）</a></p>
<p>1.简单类型的编码</p>
<p>1&gt;BOOLEAN：01</p>
<p>2&gt;INTEGER：02</p>
<p>2.构造类型数据的编码</p>
<p>1&gt;序列构造类型：30</p>
<p>2&gt;集合构造类型：31</p>
<p>/*<br>1、序列号 INTEGER：02<br>2、签名算法 OBJECT IDENTIFIER：06<br>3、使用者   12 无 字符串<br>4、公钥 BIT STRING：03<br>5、有效期开始，有效期结束 时间 23  UTCTime：17<br>*/</p>
<h2 id="windows程序创建过程"><a href="#windows程序创建过程" class="headerlink" title="windows程序创建过程"></a>windows程序创建过程</h2><p><a href="https://blog.csdn.net/hyman_c/article/details/53447695">https://blog.csdn.net/hyman_c/article/details/53447695</a></p>
<p>创建一个Windows界面程序共分为7步：</p>
<p>（1）定义WinMain函数（这是windows界面程序的入口）。</p>
<p>（2）定义窗口处理函数。</p>
<p>（3）注册窗口</p>
<p>（4）创建窗口</p>
<p>（5）显示窗口</p>
<p>（6）编写消息循环函数</p>
<p>（7）处理消息(在第二步的窗口处理函数中)</p>
<h3 id="定义WinMain函数（这是windows界面程序的入口）"><a href="#定义WinMain函数（这是windows界面程序的入口）" class="headerlink" title="定义WinMain函数（这是windows界面程序的入口）"></a>定义WinMain函数（这是windows界面程序的入口）</h3><p>程序入口的wWinMain函数：</p>
<p>lpCmdLine —— 命令行参数，我们执行程序时可以用命令行的形式传入一些参数。</p>
<p>nCmdShow —— 窗口的显示方式，最大化、最小化那种。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int APIENTRY wWinMain(_In_ HINSTANCE hInstance,</span><br><span class="line">_In_opt_ HINSTANCE hPrevInstance,</span><br><span class="line">_In_ LPWSTR    lpCmdLine,</span><br><span class="line">_In_ int       nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="定义窗口处理函数。"><a href="#定义窗口处理函数。" class="headerlink" title="定义窗口处理函数。"></a>定义窗口处理函数。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;窗口处理函数</span><br><span class="line">LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">    switch (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">        case WM_DESTROY:</span><br><span class="line">        PostQuitMessage(0);&#x2F;&#x2F;可以使GetMessage返回0</span><br><span class="line">        break;</span><br><span class="line">        default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return DefWindowProc(hWnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hWnd —— 是窗口的句柄。</p>
<p>uMsg —— 是传入的消息，它的本质就是无符号整形的数字。</p>
<p>wParam、lParam —— 是消息附带的两个参数。</p>
<h3 id="注册窗口"><a href="#注册窗口" class="headerlink" title="注册窗口"></a>注册窗口</h3><p> 一个窗口，在创建之前需要先向操作系统进行注册，这类似现实生活中我们开公司，要先向工商局进行注册一样。wce是一个WNDCLASSEX 类型的结构体，这就是一个窗口类，<strong>包含了我们所需要的窗口信息，包括菜单、图标、背景色等等。</strong>它最主要的是两个成员，hInstance是当前程序的实例句柄，lpszClassName是我们注册的类名称，其他的这里不再解释，可参照MSDN。</p>
<p>我们通过RegisterClassEx()这个API将窗口类在操作系统中进行注册，并通过其返回值判断是否注册成功。我们在WinMain函数中进行窗口的注册工作，请看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;注册窗口类</span><br><span class="line">    WNDCLASSEX wce &#x3D; &#123; 0 &#125;;</span><br><span class="line">    wce.cbSize &#x3D; sizeof(wce);</span><br><span class="line">    wce.cbClsExtra &#x3D; 0;</span><br><span class="line">    wce.cbWndExtra &#x3D; 0;</span><br><span class="line">    wce.hbrBackground &#x3D; (HBRUSH)(COLOR_WINDOW + 1);</span><br><span class="line">    wce.hCursor &#x3D; NULL;</span><br><span class="line">    wce.hIcon &#x3D; NULL;</span><br><span class="line">    wce.hIconSm &#x3D; NULL;</span><br><span class="line">    wce.hInstance &#x3D; hInstance;</span><br><span class="line">    wce.lpfnWndProc &#x3D; wndProc;</span><br><span class="line">    wce.lpszClassName &#x3D; “Main”;</span><br><span class="line">    wce.lpszMenuName &#x3D; NULL;</span><br><span class="line">    wce.style &#x3D; CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    ATOM nAtom &#x3D; RegisterClassEx(&amp;wce);</span><br><span class="line">    if (!nAtom )</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(NULL, &quot;注册失败&quot;, &quot;Infor&quot;, MB_OK);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><p>接下来我们创建窗口，创建窗口我们使用CreateWindowEx系统API，请留意下面它的第2、3两个参数，第二个参数使我们之前注册的窗口类名称，第三个参数是窗口的标题名称，其他的是一些窗口显示的参数，这里不再详细解释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HWND hWnd &#x3D; CreateWindowEx(0, “Main”, “Window”,</span><br><span class="line">WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, g_hInstance, NULL);</span><br></pre></td></tr></table></figure>



<h3 id="显示窗口"><a href="#显示窗口" class="headerlink" title="显示窗口"></a>显示窗口</h3><p><a href="https://blog.csdn.net/hyman_c/article/details/53453438">https://blog.csdn.net/hyman_c/article/details/53453438</a></p>
<p>创建了窗口之后，如果要想运行时能够看见窗口，我们还需要显式的设置显示窗口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ShowWindow(hWnd, SW_SHOW);</span><br><span class="line">UpdateWindow(hWnd);</span><br></pre></td></tr></table></figure>

<p>​       ShowWindow和UpdateWindow都是系统的API，前者是设置窗口的显示属性。后者重新更新窗口属性，只有更新之后，属性才会生效。</p>
<h3 id="编写消息循环函数"><a href="#编写消息循环函数" class="headerlink" title="编写消息循环函数"></a>编写消息循环函数</h3><p>所谓的消息循环，其实就是一个死循环，不断的通过GetMessage捕捉着窗口的消息，再通过TranslateMessage将虚拟键消息转换为字符消息,然后通过DispatchMessage将消息分派给我们的窗口程序进行处理（所谓处理就是调用我们定义的窗口处理函数WinProc）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Message()</span><br><span class="line">&#123;</span><br><span class="line">    MSG nMsg &#x3D; &#123; 0 &#125;;</span><br><span class="line">    while (GetMessage(&amp;nMsg, NULL, 0, 0))</span><br><span class="line">    &#123;</span><br><span class="line">        TranslateMessage(&amp;nMsg);</span><br><span class="line">        DispatchMessage(&amp;nMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最终代码"><a href="#最终代码" class="headerlink" title="### 最终代码"></a>### 最终代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">HINSTANCE g_hInstance &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;窗口处理函数</span><br><span class="line">LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	switch (uMsg)</span><br><span class="line">	&#123;</span><br><span class="line">	case WM_DESTROY:</span><br><span class="line">		PostQuitMessage(0);&#x2F;&#x2F;可以使GetMessage返回0</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	return DefWindowProc(hWnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;注册窗口类</span><br><span class="line">BOOL Register(LPSTR lpClassName, WNDPROC wndProc)</span><br><span class="line">&#123;</span><br><span class="line">	WNDCLASSEX wce &#x3D; &#123; 0 &#125;;</span><br><span class="line">	wce.cbSize &#x3D; sizeof(wce);</span><br><span class="line">	wce.cbClsExtra &#x3D; 0;</span><br><span class="line">	wce.cbWndExtra &#x3D; 0;</span><br><span class="line">	wce.hbrBackground &#x3D; (HBRUSH)(COLOR_WINDOW + 1);</span><br><span class="line">	wce.hCursor &#x3D; NULL;</span><br><span class="line">	wce.hIcon &#x3D; NULL;</span><br><span class="line">	wce.hIconSm &#x3D; NULL;</span><br><span class="line">	wce.hInstance &#x3D; g_hInstance;</span><br><span class="line">	wce.lpfnWndProc &#x3D; wndProc;</span><br><span class="line">	wce.lpszClassName &#x3D; lpClassName;</span><br><span class="line">	wce.lpszMenuName &#x3D; NULL;</span><br><span class="line">	wce.style &#x3D; CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">	ATOM nAtom &#x3D; RegisterClassEx(&amp;wce);</span><br><span class="line">	if (nAtom &#x3D;&#x3D; 0)</span><br><span class="line">		return FALSE;</span><br><span class="line">	return true;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;创建主窗口</span><br><span class="line">HWND CreateMain(LPSTR lpClassName, LPSTR lpWndName)</span><br><span class="line">&#123;</span><br><span class="line">	HWND hWnd &#x3D; CreateWindowEx(0, lpClassName, lpWndName,</span><br><span class="line">		WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, g_hInstance, NULL);</span><br><span class="line">	return hWnd;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;显示窗口</span><br><span class="line">void Display(HWND hWnd)</span><br><span class="line">&#123;</span><br><span class="line">	ShowWindow(hWnd, SW_SHOW);</span><br><span class="line">	UpdateWindow(hWnd);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;消息循环</span><br><span class="line">void Message()</span><br><span class="line">&#123;</span><br><span class="line">	MSG nMsg &#x3D; &#123; 0 &#125;;</span><br><span class="line">	while (GetMessage(&amp;nMsg, NULL, 0, 0))</span><br><span class="line">	&#123;</span><br><span class="line">		TranslateMessage(&amp;nMsg);</span><br><span class="line">		DispatchMessage(&amp;nMsg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int APIENTRY wWinMain(_In_ HINSTANCE hInstance,</span><br><span class="line">	_In_opt_ HINSTANCE hPrevInstance,</span><br><span class="line">	_In_ LPWSTR    lpCmdLine,</span><br><span class="line">	_In_ int       nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; TODO: Place code here.</span><br><span class="line"> </span><br><span class="line">	g_hInstance &#x3D; hInstance;</span><br><span class="line">	BOOL nRet &#x3D; Register(&quot;Main&quot;, WndProc);</span><br><span class="line">	if (!nRet)</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(NULL, &quot;注册失败&quot;, &quot;Infor&quot;, MB_OK);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	HWND hWnd &#x3D; CreateMain(&quot;Main&quot;, &quot;window&quot;);</span><br><span class="line">	Display(hWnd);</span><br><span class="line">	Message();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Base64的编码与解码"><a href="#Base64的编码与解码" class="headerlink" title="Base64的编码与解码"></a>Base64的编码与解码</h2><p>原理：</p>
<p><a href="http://blog.chacuo.net/719.html">http://blog.chacuo.net/719.html</a></p>
<p>c语言实现：</p>
<p><a href="https://blog.csdn.net/qq_26093511/article/details/78836087">https://blog.csdn.net/qq_26093511/article/details/78836087</a></p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。<br>right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。<br>inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。<br>full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。</p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_39220472/article/details/81193617">https://blog.csdn.net/weixin_39220472/article/details/81193617</a></p>
<h1 id="vscode的cpp配置"><a href="#vscode的cpp配置" class="headerlink" title="vscode的cpp配置"></a>vscode的cpp配置</h1><p><a href="https://zhuanlan.zhihu.com/p/87864677">https://zhuanlan.zhihu.com/p/87864677</a></p>
<!--more-->

<p>task.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; See https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkId&#x3D;733558 </span><br><span class="line">    &#x2F;&#x2F; for the documentation about the tasks.json format</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;label&quot;: &quot;g++.exe build active file&quot;,&#x2F;&#x2F;任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置</span><br><span class="line">            &quot;command&quot;: &quot;D:\\Program Files (x86)\\mingw64\\bin\\g++.exe&quot;,</span><br><span class="line">            &quot;args&quot;: [&#x2F;&#x2F;编译时候的参数</span><br><span class="line">                &quot;-g&quot;,&#x2F;&#x2F;添加gdb调试选项</span><br><span class="line">                &quot;$&#123;file&#125;&quot;,</span><br><span class="line">                &quot;-o&quot;,&#x2F;&#x2F;指定生成可执行文件的名称</span><br><span class="line">                &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;options&quot;: &#123;</span><br><span class="line">                &quot;cwd&quot;: &quot;D:\\Program Files (x86)\\mingw64\\bin&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: [</span><br><span class="line">                &quot;$gcc&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true&#x2F;&#x2F;表示快捷键Ctrl+Shift+B可以运行该任务</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>launch.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Use IntelliSense to learn about possible attributes.</span><br><span class="line">    &#x2F;&#x2F; Hover to view descriptions of existing attributes.</span><br><span class="line">    &#x2F;&#x2F; For more information, visit: https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;(gdb) Launch&quot;,</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;g++.exe build active file&quot;,&#x2F;&#x2F;调试前执行的任务，就是之前配置的tasks.json中的label字段</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,&#x2F;&#x2F;配置类型，只能为cppdbg</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,&#x2F;&#x2F;请求配置类型，可以为launch（启动）或attach（附加）</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,&#x2F;&#x2F;调试程序的路径名称</span><br><span class="line">            &quot;args&quot;: [],&#x2F;&#x2F;调试传递参数</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: true,&#x2F;&#x2F;true显示外置的控制台窗口，false显示内置终端</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;D:\\Program Files (x86)\\mingw64\\bin\\gdb.exe&quot;,</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="LPWSTR-to-char-转换"><a href="#LPWSTR-to-char-转换" class="headerlink" title="LPWSTR to char* 转换"></a>LPWSTR to char* 转换</h1><p><a href="https://blog.csdn.net/moonlightpeng/article/details/80821872?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight">https://blog.csdn.net/moonlightpeng/article/details/80821872?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int num &#x3D; WideCharToMultiByte(CP_OEMCP, NULL, (LPWSTR)szKeyName, -1, NULL, 0, NULL, FALSE);</span><br><span class="line">			char* pchar &#x3D; new char[num];</span><br><span class="line">			WideCharToMultiByte(CP_OEMCP, NULL, (LPWSTR)szKeyName, -1, pchar, num, NULL, FALSE);</span><br><span class="line">			printf(&quot;%s\n&quot;, pchar);</span><br></pre></td></tr></table></figure>

<h1 id="string-to-LPCWSTR"><a href="#string-to-LPCWSTR" class="headerlink" title="string to LPCWSTR"></a>string to LPCWSTR</h1><p><a href="https://blog.csdn.net/wangshubo1989/article/details/50274103">https://blog.csdn.net/wangshubo1989/article/details/50274103</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_t size &#x3D; vProvList[i].length();</span><br><span class="line">        wchar_t* buffer &#x3D; new wchar_t[size + 1];</span><br><span class="line">        MultiByteToWideChar(CP_ACP, 0, vProvList[i].c_str(), size, buffer, size * sizeof(wchar_t));</span><br><span class="line">        buffer[size] &#x3D; 0;  &#x2F;&#x2F;确保以 &#39;\0&#39; 结尾</span><br></pre></td></tr></table></figure>

<h1 id="char转wchar-t"><a href="#char转wchar-t" class="headerlink" title="char转wchar_t"></a>char<em>转wchar_t</em></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char *s &#x3D; &quot;一二三四五六七八&quot;;</span><br><span class="line">   DWORD dwNum &#x3D; MultiByteToWideChar(CP_ACP, 0, s, -1, NULL, 0); &#x2F;&#x2F; 转换成 宽字节大小9 (8+1)</span><br><span class="line">   WCHAR *wch &#x3D; new WCHAR[dwNum]; &#x2F;&#x2F; 按宽字节 new 内存</span><br><span class="line">   memset(wch, 0, dwNum*sizeof(wchar_t)); &#x2F;&#x2F; 全置0  可以用这句 memset(wch, 0, sizeof(wch));</span><br><span class="line">   &#x2F;&#x2F; memset( the_array, &#39;\0&#39;, sizeof(the_array) ); 这是将一个数组的所以分量设置成零的很便捷的方法</span><br><span class="line"></span><br><span class="line">   MultiByteToWideChar(CP_ACP, 0, s, -1, wch, dwNum*sizeof(wchar_t)); &#x2F;&#x2F;s转换到宽字节wch</span><br><span class="line"></span><br><span class="line">   wcout &lt;&lt; wch &lt;&lt; endl; &#x2F;&#x2F; 宽字节输出</span><br></pre></td></tr></table></figure>

</div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/09/28/Base64%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Base64编码与解码</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/09/25/ascii%E7%A0%81%E8%A1%A8/"><span class="level-item">ascii码表</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: '6fcfd8db3e282426b4012e7214144ba2',
            repo: 'Jmlong23.github.io',
            owner: 'Jmlong23',
            clientID: 'bc8a046fee35afa66dfd',
            clientSecret: '657361040368baf39fd80cbe1d911c92eb0bf8c1',
            admin: ["Jmlong23"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/avatar.png" alt="topLOW"></figure><p class="title is-size-4 is-block line-height-inherit">topLOW</p><p class="is-size-6 is-block">topLOW的博客</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>广东广州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">46</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">16</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#cpp开发工程师学习资料"><span class="mr-2">1</span><span>cpp开发工程师学习资料</span></a></li><li><a class="is-flex" href="#cpp基础"><span class="mr-2">2</span><span>cpp基础</span></a><ul class="menu-list"><li><a class="is-flex" href="#重载（overload）覆盖（override）和重写（overwrite）区别"><span class="mr-2">2.1</span><span>重载（overload）覆盖（override）和重写（overwrite）区别</span></a></li><li><a class="is-flex" href="#C-中是如何申请内存的"><span class="mr-2">2.2</span><span>C++中是如何申请内存的</span></a></li><li><a class="is-flex" href="#new与malloc"><span class="mr-2">2.3</span><span>new与malloc</span></a></li><li><a class="is-flex" href="#多态"><span class="mr-2">2.4</span><span>多态</span></a></li><li><a class="is-flex" href="#虚函数表机制"><span class="mr-2">2.5</span><span>虚函数表机制</span></a><ul class="menu-list"><li><a class="is-flex" href="#虚函数与数据封装private"><span class="mr-2">2.5.1</span><span>虚函数与数据封装private</span></a></li></ul></li><li><a class="is-flex" href="#多继承与虚继承"><span class="mr-2">2.6</span><span>多继承与虚继承</span></a><ul class="menu-list"><li><a class="is-flex" href="#多重继承（Multiple-Inheritance）"><span class="mr-2">2.6.1</span><span>多重继承（Multiple Inheritance）</span></a></li><li><a class="is-flex" href="#虚继承（Virtual-Inheritance）"><span class="mr-2">2.6.2</span><span>虚继承（Virtual Inheritance）</span></a></li></ul></li><li><a class="is-flex" href="#类型转换（Type-Conversions）"><span class="mr-2">2.7</span><span>类型转换（Type Conversions）</span></a></li><li><a class="is-flex" href="#数组与链表的区别"><span class="mr-2">2.8</span><span>数组与链表的区别</span></a></li><li><a class="is-flex" href="#智能指针"><span class="mr-2">2.9</span><span>智能指针</span></a></li><li><a class="is-flex" href="#指针和引用的区别"><span class="mr-2">2.10</span><span>指针和引用的区别</span></a></li><li><a class="is-flex" href="#cpp的左值和右值"><span class="mr-2">2.11</span><span>cpp的左值和右值</span></a></li><li><a class="is-flex" href="#cpp程序编译过程"><span class="mr-2">2.12</span><span>cpp程序编译过程</span></a></li><li><a class="is-flex" href="#变量作用域"><span class="mr-2">2.13</span><span>变量作用域</span></a></li><li><a class="is-flex" href="#RTTI（run-time-type-identification-运行时类型识别"><span class="mr-2">2.14</span><span>RTTI（run-time type identification) 运行时类型识别</span></a></li><li><a class="is-flex" href="#请你回答一下C-中拷贝赋值函数的形参能否进行值传递？"><span class="mr-2">2.15</span><span>请你回答一下C++中拷贝赋值函数的形参能否进行值传递？</span></a></li><li><a class="is-flex" href="#bits-stdc-h头文件"><span class="mr-2">2.16</span><span>bits/stdc++.h头文件</span></a></li><li><a class="is-flex" href="#fork（）函数"><span class="mr-2">2.17</span><span>fork（）函数</span></a></li><li><a class="is-flex" href="#类中的引用成员变量"><span class="mr-2">2.18</span><span>类中的引用成员变量</span></a></li><li><a class="is-flex" href="#异常处理"><span class="mr-2">2.19</span><span>异常处理</span></a><ul class="menu-list"><li><a class="is-flex" href="#noexcept异常说明"><span class="mr-2">2.19.1</span><span>noexcept异常说明</span></a></li></ul></li><li><a class="is-flex" href="#野指针"><span class="mr-2">2.20</span><span>野指针</span></a><ul class="menu-list"><li><a class="is-flex" href="#lt-lt-移位运算"><span class="mr-2">2.20.1</span><span>&lt;&lt;移位运算</span></a></li></ul></li><li><a class="is-flex" href="#请你说说内存泄漏如何判断"><span class="mr-2">2.21</span><span>请你说说内存泄漏如何判断</span></a></li><li><a class="is-flex" href="#cpp多线程"><span class="mr-2">2.22</span><span>cpp多线程</span></a></li><li><a class="is-flex" href="#构造函数为什么不能是虚指针"><span class="mr-2">2.23</span><span>构造函数为什么不能是虚指针</span></a></li></ul></li><li><a class="is-flex" href="#STL"><span class="mr-2">3</span><span>STL</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex" href="#六大组件"><span class="mr-2">3.1.1</span><span>六大组件</span></a></li><li><a class="is-flex" href="#常用容器"><span class="mr-2">3.1.2</span><span>常用容器</span></a></li><li><a class="is-flex" href="#序列式容器"><span class="mr-2">3.1.3</span><span>序列式容器</span></a></li><li><a class="is-flex" href="#关联式容器"><span class="mr-2">3.1.4</span><span>关联式容器</span></a></li></ul><li><a class="is-flex" href="#迭代器-iterator"><span class="mr-2">3.2</span><span>迭代器 iterator</span></a></li><li><a class="is-flex" href="#常见容器的操作时间复杂度"><span class="mr-2">3.3</span><span>常见容器的操作时间复杂度</span></a></li><li><a class="is-flex" href="#stl常见容器api总结"><span class="mr-2">3.4</span><span>stl常见容器api总结</span></a></li><li><a class="is-flex" href="#stl常用算法总结"><span class="mr-2">3.5</span><span>stl常用算法总结</span></a></li></ul></li><li><a class="is-flex" href="#数据结构与算法"><span class="mr-2">4</span><span>数据结构与算法</span></a><ul class="menu-list"><li><a class="is-flex" href="#求二叉树的最大高度"><span class="mr-2">4.1</span><span>求二叉树的最大高度</span></a><ul class="menu-list"><li><a class="is-flex" href="#二叉树定义与遍历"><span class="mr-2">4.1.1</span><span>二叉树定义与遍历</span></a></li></ul></li><li><a class="is-flex" href="#堆排序"><span class="mr-2">4.2</span><span>堆排序</span></a></li><li><a class="is-flex" href="#快速排序"><span class="mr-2">4.3</span><span>快速排序</span></a></li><li><a class="is-flex" href="#折半查找"><span class="mr-2">4.4</span><span>折半查找</span></a></li><li><a class="is-flex" href="#常见的排序算法"><span class="mr-2">4.5</span><span>常见的排序算法</span></a></li><li><a class="is-flex" href="#哈夫曼编码"><span class="mr-2">4.6</span><span>哈夫曼编码</span></a></li></ul></li><li><a class="is-flex" href="#项目"><span class="mr-2">5</span><span>项目</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex" href="#功能概述"><span class="mr-2">5.1.1</span><span>功能概述</span></a></li></ul><li><a class="is-flex" href="#windows程序创建过程"><span class="mr-2">5.2</span><span>windows程序创建过程</span></a><ul class="menu-list"><li><a class="is-flex" href="#定义WinMain函数（这是windows界面程序的入口）"><span class="mr-2">5.2.1</span><span>定义WinMain函数（这是windows界面程序的入口）</span></a></li><li><a class="is-flex" href="#定义窗口处理函数。"><span class="mr-2">5.2.2</span><span>定义窗口处理函数。</span></a></li><li><a class="is-flex" href="#注册窗口"><span class="mr-2">5.2.3</span><span>注册窗口</span></a></li><li><a class="is-flex" href="#创建窗口"><span class="mr-2">5.2.4</span><span>创建窗口</span></a></li><li><a class="is-flex" href="#显示窗口"><span class="mr-2">5.2.5</span><span>显示窗口</span></a></li><li><a class="is-flex" href="#编写消息循环函数"><span class="mr-2">5.2.6</span><span>编写消息循环函数</span></a></li><li><a class="is-flex" href="#最终代码"><span class="mr-2">5.2.7</span><span>### 最终代码</span></a></li></ul></li><li><a class="is-flex" href="#Base64的编码与解码"><span class="mr-2">5.3</span><span>Base64的编码与解码</span></a></li></ul></li><li><a class="is-flex" href="#数据库"><span class="mr-2">6</span><span>数据库</span></a><ul class="menu-list"><li><a class="is-flex" href="#连接查询"><span class="mr-2">6.1</span><span>连接查询</span></a></li></ul></li><li><a class="is-flex" href="#vscode的cpp配置"><span class="mr-2">7</span><span>vscode的cpp配置</span></a></li><li><a class="is-flex" href="#LPWSTR-to-char-转换"><span class="mr-2">8</span><span>LPWSTR to char* 转换</span></a></li><li><a class="is-flex" href="#string-to-LPCWSTR"><span class="mr-2">9</span><span>string to LPCWSTR</span></a></li><li><a class="is-flex" href="#char转wchar-t"><span class="mr-2">10</span><span>char转wchar_t</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/c-%E5%AE%89%E5%85%A8%E5%AD%A6/"><span class="level-start"><span class="level-item">c++安全学</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/cpp/"><span class="level-start"><span class="level-item">cpp</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/cpp/c-primer/"><span class="level-start"><span class="level-item">c++ primer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/windows%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/"><span class="level-start"><span class="level-item">windows窗口程序</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">深度学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">环境搭建</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ftp%E9%85%8D%E7%BD%AE/"><span class="level-start"><span class="level-item">ftp配置</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">博客搭建</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BB%84%E7%BD%91%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">组网技术</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">编译原理</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ArrayList/"><span class="tag">ArrayList</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ftp/"><span class="tag">ftp</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hcl/"><span class="tag">hcl</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"><span class="tag">环境搭建</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B8%A9%E5%9D%91/"><span class="tag">踩坑</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2021-04-05T07:08:36.000Z">2021-04-05</time></p><p class="title is-6"><a class="link-muted" href="/2021/04/05/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">mysql学习笔记</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-04-03T13:53:07.000Z">2021-04-03</time></p><p class="title is-6"><a class="link-muted" href="/2021/04/03/js%E5%AD%A6%E4%B9%A0/">js学习</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-03-17T07:18:26.000Z">2021-03-17</time></p><p class="title is-6"><a class="link-muted" href="/2021/03/17/linux%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88/">linux操作集合</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/linux/">linux</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-03-10T12:18:53.000Z">2021-03-10</time></p><p class="title is-6"><a class="link-muted" href="/2021/03/10/%E5%89%91%E6%8C%87offer/">剑指offer</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/leetcode/">leetcode</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-02-27T09:14:36.000Z">2021-02-27</time></p><p class="title is-6"><a class="link-muted" href="/2021/02/27/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/">第七章 类</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/cpp/">cpp</a> / <a class="link-muted" href="/categories/cpp/c-primer/">c++ primer</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="topLOW的博客" height="28"></a><p class="size-small"><span>&copy; 2021 long</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://sanguocloud.cn',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>