<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>c++基础语法 - topLOW的博客</title><meta description="begin:"><meta property="og:type" content="blog"><meta property="og:title" content="c++基础语法"><meta property="og:url" content="https://sanguocloud.cn/2020/09/26/cpp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"><meta property="og:site_name" content="topLOW的博客"><meta property="og:description" content="begin:"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://sanguocloud.cn/img/og_image.png"><meta property="article:published_time" content="2020-09-26T04:58:55.000Z"><meta property="article:modified_time" content="2021-03-17T03:04:46.320Z"><meta property="article:author" content="long"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://sanguocloud.cn/2020/09/26/cpp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},"headline":"topLOW的博客","image":["https://sanguocloud.cn/img/og_image.png"],"datePublished":"2020-09-26T04:58:55.000Z","dateModified":"2021-03-17T03:04:46.320Z","author":{"@type":"Person","name":"long"},"description":"begin:"}</script><link rel="canonical" href="https://sanguocloud.cn/2020/09/26/cpp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="topLOW的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">目录</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-09-26T04:58:55.000Z" title="2020-09-26T04:58:55.000Z">2020-09-26</time><span class="level-item"><a class="link-muted" href="/categories/cpp/">cpp</a></span><span class="level-item">1 小时 读完 (大约 8766 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">c++基础语法</h1><div class="content"><p>begin:</p>
<a id="more"></a>

<h1 id="cpp开发工程师学习资料"><a href="#cpp开发工程师学习资料" class="headerlink" title="cpp开发工程师学习资料"></a>cpp开发工程师学习资料</h1><p>前言，牛客面经：<a href="https://www.nowcoder.com/tutorial/93/8ba2828006dd42879f3a9029eabde9f1">https://www.nowcoder.com/tutorial/93/8ba2828006dd42879f3a9029eabde9f1</a></p>
<ol>
<li>cpp primer 第5版 </li>
</ol>
<p>c++学习手册：<a href="https://zh.cppreference.com/w/cpp">https://zh.cppreference.com/w/cpp</a></p>
<p>学习笔记：<a href="https://github.com/czs108/Cpp-Primer-5th-Notes-CN">https://github.com/czs108/Cpp-Primer-5th-Notes-CN</a></p>
<ol start="2">
<li><p>stl源码剖析</p>
</li>
<li><p>面经：</p>
</li>
</ol>
<p><a href="https://leetcode-cn.com/u/crystal_yyf/">https://leetcode-cn.com/u/crystal_yyf/</a> </p>
<p><a href="https://blog.csdn.net/qq_41589622/article/details/109813884">https://blog.csdn.net/qq_41589622/article/details/109813884</a></p>
<ol start="4">
<li>剑指offer：</li>
</ol>
<p><a href="https://github.com/gatieme/CodingInterviews">https://github.com/gatieme/CodingInterviews</a></p>
<p><a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/50c26h/">https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/50c26h/</a></p>
<ol start="5">
<li>设计模式：单例模式和工厂模式</li>
</ol>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html">https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html</a></p>
<p><a href="https://www.bilibili.com/video/BV1KW411t7FV">https://www.bilibili.com/video/BV1KW411t7FV</a></p>
<ol start="6">
<li>计算机网络：<a href="https://jiangren.work/2020/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/">https://jiangren.work/2020/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</a></li>
<li>数据库：<a href="https://leetcode-cn.com/u/crystal_yyf/">https://leetcode-cn.com/u/crystal_yyf/</a></li>
<li>项目：网融公司实习</li>
<li>qt:</li>
</ol>
<p>时间、资料、方法</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>请你说说内存泄漏如何判断</p>
<p>1.尽量不去手动<a href="https://www.baidu.com/s?wd=分配内存&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">分配内存</a>。比如，我一般不使用数组，而使用STL的vector.</p>
<p> 2.如果需要手动分配数组，尽量使用STL中的分配方式，或者使用STL和BOOST中的<a href="https://www.baidu.com/s?wd=智能指针&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">智能指针</a>。</p>
<p> 3.某些应用，比如MSXML，尽量使用<a href="https://www.baidu.com/s?wd=智能指针&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">智能指针</a>。</p>
<p> 4.凡是使用new和delete的地方，首先注意指针的初始化，然后要注意new和delete的配对，再就是要注意错误的捕捉。很多时候，内存泄漏不是因为new和delete的配对造成的，而是在自己没有考虑到的可能结果中，程序中断而没有delete手动分配的内存.</p>
<p> 5.貌似有专门的方法来检测内存泄漏。不过我只听说过，没用过。</p>
<h1 id="cpp基础"><a href="#cpp基础" class="headerlink" title="cpp基础"></a>cpp基础</h1><h2 id="重载（overload）覆盖（override）和重写（overwrite）区别"><a href="#重载（overload）覆盖（override）和重写（overwrite）区别" class="headerlink" title="重载（overload）覆盖（override）和重写（overwrite）区别"></a>重载（overload）覆盖（override）和重写（overwrite）区别</h2><p>重载指同一作用域内，的同名函数、不同参数类型或者个数不同。称这些函数为重载函数 是静多态的一种。</p>
<p>覆盖指子类重新实现了父类的虚函数，要求同名同参同返回，此时子类虚函数表中只存在子类虚函数入口。是动多态的条件之一。</p>
<p>重写指父类与子类中存在同名函数，不考虑参数与返回值，此时在子类中默认访问子类新的实现体，如果要访问父类版实现，需要显式写出父类作用域，这种情况也称子类隐藏了父类函数。</p>
<p><strong>一、重载（overload）</strong><br>指函数名相同，但是它的参数列表个数或顺序，类型不同。但是不能靠返回类型来判断,即不以返回值类型不同作为函数重载的条件<br>（1）同一类中（在同一个作用域中） ；<br>（2）函数名字相同；<br>（3）参数不同；<br>（4）virtual 关键字可有可无。<br>（5）返回值可以不同；</p>
<p><strong>二、覆盖 （override）</strong><br>是指派生类重新定义基类的虚函数，特征是：<br>（1）不在同一个作用域（分别位于派生类与基类） ；<br>（2）函数名字相同；<br>（3）参数相同；<br>（4）基类函数必须有 virtual 关键字，不能有 static 。<br>（5）返回值相同（或是协变），否则报错；&lt;—-协变这个概念我也是第一次才知道…</p>
<p>（6）重写函数的访问修饰符可以不同。尽管 virtual 是 private 的，派生类中重写改写为 public,protected 也是可以的</p>
<p><strong>三、重写（overwrite）</strong></p>
<p>指父类与子类中存在同名函数，不考虑参数与返回值，此时在子类中默认访问子类新的实现体，如果要访问父类版实现，需要显式写出父类作用域，这种情况也称子类隐藏了父类函数。</p>
<p>（1）不在同一个作用域（分别位于派生类与基类） ；<br>（2）函数名字相同；<br>（3）返回值可以不同；<br>（4）参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载以及覆盖混淆） 。<br>（5）参数相同，但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 。</p>
<h2 id="C-中是如何申请内存的"><a href="#C-中是如何申请内存的" class="headerlink" title="C++中是如何申请内存的"></a>C++中是如何申请内存的</h2><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</p>
<p>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
<p>映射区:存储动态链接库以及调用mmap函数进行的文件映射</p>
<p>堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。</p>
<p>bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</p>
<p>数据段：存储程序中已初始化的全局变量和静态变量</p>
<p>代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p><a href="https://www.runoob.com/cplusplus/cpp-dynamic-memory.html">https://www.runoob.com/cplusplus/cpp-dynamic-memory.html</a></p>
<p><a href="https://blog.csdn.net/qq_33266987/article/details/51965221">https://blog.csdn.net/qq_33266987/article/details/51965221</a></p>
<ul>
<li>虚拟内存的五大段，内存的五大分区</li>
</ul>
<p><a href="https://blog.csdn.net/ganpengjin1/article/details/38269989">https://blog.csdn.net/ganpengjin1/article/details/38269989</a></p>
<p>少了一个映射区</p>
<h2 id="new与malloc"><a href="#new与malloc" class="headerlink" title="new与malloc"></a>new与malloc</h2><p>new是关键字不需要引入库，malloc是库函数，new返回完整类型指针，malloc返回（void*）类型需要强转。malloc失败返回null指针，new失败抛出异常（bad_alloc）.</p>
<table>
<thead>
<tr>
<th align="center">特征</th>
<th align="center">new/delete</th>
<th align="center">malloc/free</th>
</tr>
</thead>
<tbody><tr>
<td align="center">分配内存的位置</td>
<td align="center">自由存储区</td>
<td align="center">堆</td>
</tr>
<tr>
<td align="center">内存分配成功的返回值</td>
<td align="center">完整类型指针</td>
<td align="center">void*</td>
</tr>
<tr>
<td align="center">内存分配失败的返回值</td>
<td align="center">默认抛出异常</td>
<td align="center">返回NULL</td>
</tr>
<tr>
<td align="center">分配内存的大小</td>
<td align="center">由编译器根据类型计算得出</td>
<td align="center">必须显式指定字节数</td>
</tr>
<tr>
<td align="center">处理数组</td>
<td align="center">有处理数组的new版本new[]</td>
<td align="center">需要用户计算数组的大小后进行内存分配</td>
</tr>
<tr>
<td align="center">已分配内存的扩充</td>
<td align="center">无法直观地处理</td>
<td align="center">使用realloc简单完成</td>
</tr>
<tr>
<td align="center">是否相互调用</td>
<td align="center">可以，看具体的operator new/delete实现</td>
<td align="center">不可调用new</td>
</tr>
<tr>
<td align="center">分配内存时内存不足</td>
<td align="center">客户能够指定处理函数或重新制定分配器</td>
<td align="center">无法通过用户代码进行处理</td>
</tr>
<tr>
<td align="center">函数重载</td>
<td align="center">允许</td>
<td align="center">不允许</td>
</tr>
<tr>
<td align="center">构造函数与析构函数</td>
<td align="center">调用</td>
<td align="center">不调用</td>
</tr>
</tbody></table>
<p><a href="https://www.cnblogs.com/qg-whz/p/5140930.html">https://www.cnblogs.com/qg-whz/p/5140930.html</a></p>
<p><a href="https://blog.csdn.net/nie19940803/article/details/76358673">https://blog.csdn.net/nie19940803/article/details/76358673</a></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><a href="https://github.com/czs108/Cpp-Primer-5th-Notes-CN/tree/master/Chapter-15%20Object-Oriented%20Programming">https://github.com/czs108/Cpp-Primer-5th-Notes-CN/tree/master/Chapter-15%20Object-Oriented%20Programming</a></p>
<p>三个条件<br>1、基类有虚函数<br>2、派生类覆盖（override）了基类虚函数。（要求函数名，返值类型，函数参数个数及类型全部匹配。并根据派生类的需要重新定义函数体。可以为任意访问权限）<br>3、通过基类指针或引用指向派生类对象，调用公共接口（虚函数）</p>
<p>如果派生类重写（overwrite）基类的函数比如没加virtual，以及函数重载和模板，那叫静多态，因为函数调用在程序执行前就准备好了。</p>
<h2 id="虚函数表机制"><a href="#虚函数表机制" class="headerlink" title="虚函数表机制"></a>虚函数表机制</h2><p><a href="https://blog.csdn.net/lihao21/article/details/50688337">https://blog.csdn.net/lihao21/article/details/50688337</a></p>
<ul>
<li>虚函数与多态</li>
</ul>
<p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载、模板，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。<br>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。（父类和子类分别有自己的虚函数表）使用了虚函数，会增加访问内存开销，降低效率。</p>
<h3 id="虚函数与数据封装private"><a href="#虚函数与数据封装private" class="headerlink" title="虚函数与数据封装private"></a>虚函数与数据封装private</h3><p>C++中<strong>, 虚函数</strong>可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。</p>
<p>一个成员函数被定义为private属性，标志着其只能被当前类的其他成员函数(或友元函数)所访问。而virtual修饰符则强调父类的成员函数可以在子类中被重写，因为重写之时并没有与父类发生任何的调用关系，故而重写是被允许的。</p>
<p>编译器不检查虚函数的各类属性。被virtual修饰的成员函数，不论他们是private、protect或是public的，都会被统一的放置到虚函数表中。对父类进行派生时，子类会继承到拥有相同偏移地址的虚函数表（相同偏移地址指，各虚函数相对于VPTR指针的偏移），则子类就会被允许对这些虚函数进行覆盖。且覆盖时可以给重载函数定义新的属性，例如public，其只标志着该重载函数在该子类中的访问属性为public，和父类的private属性没有任何关系！</p>
<p><strong>纯虚函数</strong>可以设计成私有的，不过这样不允许在本类之外的非友元函数中直接调用它，子类中只有覆盖这种纯虚函数的义务，却没有调用它的权利。</p>
<p><a href="https://www.cnblogs.com/yangguang-it/p/6547314.html">https://www.cnblogs.com/yangguang-it/p/6547314.html</a></p>
<h2 id="多继承与虚继承"><a href="#多继承与虚继承" class="headerlink" title="多继承与虚继承"></a>多继承与虚继承</h2><p><a href="https://blog.csdn.net/qq_41589622/article/details/109783029">https://blog.csdn.net/qq_41589622/article/details/109783029</a></p>
<p><a href="https://github.com/czs108/Cpp-Primer-5th-Notes-CN/blob/master/Chapter-18%20Tools%20for%20Large%20Programs/README.md#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BFmultiple-and-virtual-inheritance">https://github.com/czs108/Cpp-Primer-5th-Notes-CN/blob/master/Chapter-18%20Tools%20for%20Large%20Programs/README.md#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BFmultiple-and-virtual-inheritance</a></p>
<h3 id="多重继承（Multiple-Inheritance）"><a href="#多重继承（Multiple-Inheritance）" class="headerlink" title="多重继承（Multiple Inheritance）"></a>多重继承（Multiple Inheritance）</h3><p>是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。</p>
<h3 id="虚继承（Virtual-Inheritance）"><a href="#虚继承（Virtual-Inheritance）" class="headerlink" title="虚继承（Virtual Inheritance）"></a>虚继承（Virtual Inheritance）</h3><p>尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。如果某个类在派生过程中出现了多次，则派生类中会包含该类的多个子对象。这种默认情况对某些类并不适用，存在二义性。虚继承可以让某个类共享它的基类，其中共享的基类子对象称为虚基类（virtual base class）。在该机制下，不论虚基类在继承体系中出现了多少次，派生类都只包含唯一一个共享的虚基类子对象。</p>
<h2 id="类型转换（Type-Conversions）"><a href="#类型转换（Type-Conversions）" class="headerlink" title="类型转换（Type Conversions）"></a>类型转换（Type Conversions）</h2><p>无须程序员介入，会自动执行的类型转换叫做隐式转换（implicit conversions）。</p>
<ul>
<li>算术转换（Integral Promotions）</li>
</ul>
<p>把一种算术类型转换成另一种算术类型叫做算术转换。</p>
<p>整型提升（integral promotions）负责把小整数类型转换成较大的整数类型。</p>
<ul>
<li>其他隐式类型转换（Other Implicit Conversions）</li>
</ul>
<p>在大多数表达式中，数组名字自动转换成指向数组首元素的指针。</p>
<p>常量整数值0或字面值<code>nullptr</code>能转换成任意指针类型；指向任意非常量的指针能转换成<code>void*</code>；指向任意对象的指针能转换成<code>const void*</code>。</p>
<p>任意一种算术类型或指针类型都能转换成布尔类型。如果指针或算术类型的值为0，转换结果是<code>false</code>，否则是<code>true</code>。</p>
<p>指向非常量类型的指针能转换成指向相应的常量类型的指针。</p>
<ul>
<li>显式转换（Explicit Conversions）</li>
</ul>
<p>显式类型转换也叫做强制类型转换（cast）。命名的强制类型转换（named cast）形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-name&lt;type&gt;(expression);</span><br></pre></td></tr></table></figure>

<p>其中<em>type</em>是转换的目标类型，<em>expression</em>是要转换的值。如果<em>type</em>是引用类型，则转换结果是左值。<em>cast-name</em>是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>中的一种，用来指定转换的方式。</p>
<ul>
<li><code>dynamic_cast</code>：运行时类型识别。当expression指向目标类型时，返回目标类型对象地址，否则返回0，0，720</li>
<li><code>static_cast</code>：用于各种隐式转换，比如非const转const，void*转指针等</li>
<li><code>const_cast</code>：用于将const变量转为非const</li>
<li><code>reinterpret_cast</code>：几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</li>
</ul>
<p>早期版本的C++语言中，显式类型转换包含两种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type (expression);    &#x2F;&#x2F; function-style cast notation</span><br><span class="line">(type) expression;    &#x2F;&#x2F; C-language-style cast notation</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qq_41589622/article/details/106464662">https://blog.csdn.net/qq_41589622/article/details/106464662</a></p>
<h2 id="数组与链表的区别"><a href="#数组与链表的区别" class="headerlink" title="数组与链表的区别"></a>数组与链表的区别</h2><p>链表：可以无限拉链，分配的空间可以不连续</p>
<p>数组：分配的空间必须连续，数组如果溢出，需要新建更大的数组再搬迁数据，比较麻烦。</p>
<p>查找：效率的话，数组是优于链表的，因为通过下标访问是O(1)。而链表需要遍历，O(n)。<br>插入删除：链表比较方便，需要断开节点，插入或者删除节点，而数组可能需要后移数据。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p><a href="https://www.cnblogs.com/lanxuezaipiao/p/4132096.html">https://www.cnblogs.com/lanxuezaipiao/p/4132096.html</a></p>
<p>C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。</p>
<p>为什么要使用智能指针：</p>
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>
<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><p>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）<br>指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间（是否占内存）<br>指针可以为空，但是引用必须绑定对象（是否可为空）<br>指针可以有多级，但是引用只能一级（是否能为多级）</p>
<p>作者：Crystal<br>链接：<a href="https://leetcode-cn.com/circle/discuss/f40g4J/">https://leetcode-cn.com/circle/discuss/f40g4J/</a></p>
<h2 id="cpp的左值和右值"><a href="#cpp的左值和右值" class="headerlink" title="cpp的左值和右值"></a>cpp的左值和右值</h2><p><em>左值 (lvalue, locator value)</em> 表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</p>
<p><em>右值 (rvalue)</em> 则使用排除法来定义。一个表达式不是 <em>左值</em> 就是 <em>右值</em> 。 那么，右值是一个 <em>不</em> 表示内存中某个可识别位置的对象的表达式。</p>
<p><a href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/</a></p>
<h2 id="cpp程序编译过程"><a href="#cpp程序编译过程" class="headerlink" title="cpp程序编译过程"></a>cpp程序编译过程</h2><p><a href="https://leetcode-cn.com/circle/discuss/f40g4J/">https://leetcode-cn.com/circle/discuss/f40g4J/</a></p>
<p>编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接</p>
<p>编译预处理：处理以 # 开头的指令<br>编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码<br>汇编：将汇编代码 .s 翻译成机器指令 .o 文件<br>链接：汇编程序生成的目标文件并不会立即执行，可能有源文件中的函数引用了另一个源文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。</p>
<p>链接分类：</p>
<p>静态链接：代码从其所在的动态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中<br>动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间</p>
<p>二者的优缺点：</p>
<p>静态链接 浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容<br>动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要进行链接，性能会有一定的损失。</p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>作用域是程序的一个区域，一般来说有三个地方可以定义变量：</p>
<ul>
<li>在函数或一个代码块内部声明的变量，称为局部变量。</li>
<li>在函数参数的定义中声明的变量，称为形式参数。</li>
<li>在所有函数外部声明的变量，称为全局变量。</li>
</ul>
<h2 id="RTTI（run-time-type-identification-运行时类型识别"><a href="#RTTI（run-time-type-identification-运行时类型识别" class="headerlink" title="RTTI（run-time type identification) 运行时类型识别"></a>RTTI（run-time type identification) 运行时类型识别</h2><h2 id="请你回答一下C-中拷贝赋值函数的形参能否进行值传递？"><a href="#请你回答一下C-中拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="请你回答一下C++中拷贝赋值函数的形参能否进行值传递？"></a>请你回答一下C++中拷贝赋值函数的形参能否进行值传递？</h2><p>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。</p>
<h2 id="fork（）函数"><a href="#fork（）函数" class="headerlink" title="fork（）函数"></a>fork（）函数</h2><p><a href="https://cloud.tencent.com/developer/article/1338482">https://cloud.tencent.com/developer/article/1338482</a></p>
<h2 id="类中的引用成员变量"><a href="#类中的引用成员变量" class="headerlink" title="类中的引用成员变量"></a>类中的引用成员变量</h2><p><a href="https://blog.csdn.net/lazyq7/article/details/48186291">https://blog.csdn.net/lazyq7/article/details/48186291</a></p>
<ul>
<li>请你回答一下C++类内可以定义引用数据成员吗？</li>
</ul>
<p>可以，必须通过成员函数初始化列表初始化。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><a href="https://github.com/czs108/Cpp-Primer-5th-Notes-CN/tree/master/Chapter-18%20Tools%20for%20Large%20Programs#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86exception-handling">https://github.com/czs108/Cpp-Primer-5th-Notes-CN/tree/master/Chapter-18%20Tools%20for%20Large%20Programs#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86exception-handling</a></p>
<h3 id="noexcept异常说明"><a href="#noexcept异常说明" class="headerlink" title="noexcept异常说明"></a>noexcept异常说明</h3><p><a href="https://blog.csdn.net/LaoJiu_/article/details/50781352">https://blog.csdn.net/LaoJiu_/article/details/50781352</a></p>
<h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p><a href="https://blog.csdn.net/bl520025/article/details/8967648">https://blog.csdn.net/bl520025/article/details/8967648</a></p>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p><a href="https://leetcode-cn.com/circle/discuss/qNLDjE/">https://leetcode-cn.com/circle/discuss/qNLDjE/</a></p>
<h3 id="六大组件"><a href="#六大组件" class="headerlink" title="六大组件"></a>六大组件</h3><ul>
<li>空间配置器 allocator:负责动态空间的配置和管理</li>
<li>迭代器 iterators: 在23个设计模式中，有一种是迭代器模式（提供一种方法，使之能够依序访问某个容器所含的各个元素，而无需暴露该容器的内部表述方式），其行为类似于智能指针；STL的设计中，将数据容器和算法分开，彼此独立设计，通过迭代器(容器和算法的胶粘剂)将他们撮合在一起。</li>
<li>容器 containers ：各种数据结构，从实现的角度来看，STL容器是一种class template</li>
<li>算法 algorithms: 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。从实现角度来看，STL算法是一种function template</li>
<li>仿函数 functors:也叫函数对象，行为类似于函数；从实现角度来看，仿函数是重载了operator()的class或者class template </li>
<li>配接器 adapters:用来修饰容器或者迭代器接口</li>
</ul>
<h3 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h3><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><ul>
<li>vector：可变大小的数组。底层数据结构为数组，支持快速随机访问，在尾部之外的位置插入或者删除元素可能很慢</li>
</ul>
<ol>
<li>vector底层存储机制<br>vector是一个动态数组，里面是一个指针指向一片连续的空间，当空间不够用时，会自动申请一块更大的空间（一般是增加当前容量的50%或者100%），然后把原来的数据拷贝过去，接着释放原来的空间；当释放或者删除里面的数据时，其存储空间不释放，仅仅是清空了里面的数据</li>
</ol>
<ul>
<li>string：与vector相似的容器，专门用于存储字符。随机访问快，在尾位置插入/删除速度快</li>
<li>list：双向链表。底层数据结构为双向链表，支持双向顺序访问。在list任何位置插入/删除速度很快</li>
</ul>
<ol>
<li>list以节点为单位存放数据，节点的地址在内存中不一定连续，每次插入或者删除数据时，就配置或者释放一个元素的空间</li>
</ol>
<ul>
<li>deque：双端队列。底层数据结构为一个中央控制器和多个缓冲区，支持快速随机访问，在头尾位置插入/删除速度很快</li>
</ul>
<ol>
<li>deque底层存储机制<br>deque动态的以分段连续的空间组成，随时可以增加一段新的连续的空间并链接起来，不提供空间保留（reserve）功能。<br>deque采用一块map(不是STL的map容器)作为主控，其为一小块连续的空间，其中的每个元素都是指针，指向另一段较大的连续空间（缓冲区）</li>
</ol>
<ul>
<li><p>priority_queue：优先队列。底层用vector实现，堆heap为处理规则来管理底层容器的实现</p>
<p>源码剖析p183</p>
</li>
<li><p>stack：栈。底层用deque实现，封闭头部，在尾部进行插入和删除元素</p>
</li>
<li><p>queue：队列。底层用deque实现</p>
</li>
</ul>
<h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><ul>
<li><p>set：集合。底层为红黑树，元素有序，不重复</p>
</li>
<li><p>map：底层为红黑树，键有序，不重复</p>
<p>红黑树详解：<a href="https://xieguanglei.github.io/blog/post/red-black-tree.html">https://xieguanglei.github.io/blog/post/red-black-tree.html</a></p>
</li>
</ul>
<ol>
<li><p>map底层机制<br>map以红黑树作为底层机制，红黑树是平衡二叉树的一种，在要求上比AVL树更宽泛。通过map的迭代器只能修改其实值，不能修改其键值，所以map的迭代器既不能是const也不是mutable</p>
</li>
<li><p>红黑树满足以下几个条件：<br>每个节点不是红色就是黑色<br>根节点是黑色<br>红色节点的子节点必须是黑色（不能有连续的红节点）<br>从根节点到NULL的任何路径所含的黑节点数目相同<br>叶子节点是黑色的NULL节点（注：这里不是我们常说的二叉树中的叶节点，是它的子节点（NULL））</p>
</li>
<li><p>是弱平衡的二叉搜索树，查找删除添加时间复杂度都是log(n)</p>
</li>
</ol>
<ul>
<li>hash_map：底层为哈希表，无序，不重复</li>
</ul>
<ol>
<li>说一下unordered_map是底层是数组加链表，如果冲突则在相同哈希值的链表尾部添加节点。（拉链法）<br>说说其他解决哈希冲突的方法：再哈希还有线性探测。</li>
</ol>
<h2 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 iterator"></a>迭代器 iterator</h2><p><a href="https://leetcode-cn.com/circle/discuss/musCOX/">https://leetcode-cn.com/circle/discuss/musCOX/</a></p>
<p>数组型数据结构，如vector：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(<em>iter)(或erase(</em>iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);</p>
<p>链表型数据结构，如list：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).</p>
<p>树形数据结构，如set、map： 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。</p>
<p>注意：经过erase(iter)之后的迭代器完全失效，该迭代器iter不能参与任何运算，包括iter++,*ite《大佬的解释》</p>
<h2 id="常见容器的操作时间复杂度"><a href="#常见容器的操作时间复杂度" class="headerlink" title="常见容器的操作时间复杂度"></a>常见容器的操作时间复杂度</h2><p><a href="https://blog.csdn.net/qq_36631379/article/details/108833192">https://blog.csdn.net/qq_36631379/article/details/108833192</a></p>
<h2 id="stl常见容器api总结"><a href="#stl常见容器api总结" class="headerlink" title="stl常见容器api总结"></a>stl常见容器api总结</h2><p><a href="http://vernlium.github.io/2019/12/29/C-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8API%E6%80%BB%E7%BB%93/">http://vernlium.github.io/2019/12/29/C-STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8API%E6%80%BB%E7%BB%93/</a></p>
<h2 id="stl常用算法总结"><a href="#stl常用算法总结" class="headerlink" title="stl常用算法总结"></a>stl常用算法总结</h2><p><a href="https://www.cnblogs.com/linuxAndMcu/p/10264339.html">https://www.cnblogs.com/linuxAndMcu/p/10264339.html</a></p>
<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="求二叉树的最大高度"><a href="#求二叉树的最大高度" class="headerlink" title="求二叉树的最大高度"></a>求二叉树的最大高度</h2><p><a href="https://cloud.tencent.com/developer/article/1491138">https://cloud.tencent.com/developer/article/1491138</a></p>
<p><a href="https://www.geeksforgeeks.org/iterative-method-to-find-height-of-binary-tree/">https://www.geeksforgeeks.org/iterative-method-to-find-height-of-binary-tree/</a></p>
<p>层次遍历求高度</p>
<p>递归遍历</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><a href="https://blog.csdn.net/qq_41589622/article/details/107853558">https://blog.csdn.net/qq_41589622/article/details/107853558</a></p>
<p>王道p330</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/ohwddh/">https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/ohwddh/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void quickSort(vector&lt;int&gt;&amp; arr, int l, int r) &#123;</span><br><span class="line">     &#x2F;&#x2F; 子数组长度为 1 时终止递归</span><br><span class="line">     if (l &gt;&#x3D; r) return;</span><br><span class="line">     &#x2F;&#x2F; 哨兵划分操作（以 arr[l] 作为基准数）</span><br><span class="line">     int i &#x3D; l, j &#x3D; r;</span><br><span class="line">     while (i &lt; j) &#123;</span><br><span class="line">         while (i &lt; j &amp;&amp; arr[j] &gt;&#x3D; arr[l]) j--; &#x2F;&#x2F;不能用i &lt;&#x3D; j，会出错</span><br><span class="line">         while (i &lt; j &amp;&amp; arr[i] &lt;&#x3D; arr[l]) i++;</span><br><span class="line">         swap(arr[i], arr[j]);</span><br><span class="line">     &#125;</span><br><span class="line">     swap(arr[i], arr[l]);</span><br><span class="line">     &#x2F;&#x2F; 递归左（右）子数组执行哨兵划分</span><br><span class="line">     quickSort(arr, l, i - 1);</span><br><span class="line">     quickSort(arr, i + 1, r);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>链表的快速排序（不交换节点只交换值）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *sortList(ListNode *head) &#123;</span><br><span class="line">        &#x2F;&#x2F; IMPORTANT: Please reset any member data you declared, as</span><br><span class="line">        &#x2F;&#x2F; the same Solution instance will be reused for each test case.</span><br><span class="line">        &#x2F;&#x2F;链表快速排序</span><br><span class="line">        if(head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL)return head;</span><br><span class="line">        qsortList(head, NULL);</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    void qsortList(ListNode*head, ListNode*tail)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;链表范围是[low, high)</span><br><span class="line">        if(head !&#x3D; tail &amp;&amp; head-&gt;next !&#x3D; tail)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* mid &#x3D; partitionList(head, tail);</span><br><span class="line">            qsortList(head, mid);</span><br><span class="line">            qsortList(mid-&gt;next, tail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* partitionList(ListNode*low, ListNode*high)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;链表范围是[low, high)</span><br><span class="line">        int key &#x3D; low-&gt;val;</span><br><span class="line">        ListNode* loc &#x3D; low;</span><br><span class="line">        for(ListNode*i &#x3D; low-&gt;next; i !&#x3D; high; i &#x3D; i-&gt;next)</span><br><span class="line">            if(i-&gt;val &lt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                loc &#x3D; loc-&gt;next;</span><br><span class="line">                swap(i-&gt;val, loc-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        swap(loc-&gt;val, low-&gt;val);</span><br><span class="line">        return loc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*base64.h*&#x2F;</span><br><span class="line">#ifndef _BASE64_H  </span><br><span class="line">#define _BASE64_H  </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line"></span><br><span class="line">unsigned char* base64_encode(unsigned char* str);</span><br><span class="line"></span><br><span class="line">unsigned char* bae64_decode(unsigned char* code);</span><br><span class="line"></span><br><span class="line">#endif  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned char* base64_encode(unsigned char* str)</span><br><span class="line">&#123;</span><br><span class="line">    long len;</span><br><span class="line">    long str_len;</span><br><span class="line">    unsigned char* res;</span><br><span class="line">    int i, j;</span><br><span class="line">    &#x2F;&#x2F;定义base64编码表  </span><br><span class="line">    unsigned char* base64_table &#x3D; (unsigned char* )(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算经过base64编码后的字符串长度  </span><br><span class="line">    str_len &#x3D; strlen((const char*)str);</span><br><span class="line">    if (str_len % 3 &#x3D;&#x3D; 0)</span><br><span class="line">        len &#x3D; str_len &#x2F; 3 * 4;</span><br><span class="line">    else</span><br><span class="line">        len &#x3D; (str_len &#x2F; 3 + 1) * 4;</span><br><span class="line"></span><br><span class="line">    res &#x3D; (unsigned char*)malloc(sizeof(unsigned char) * len + 1);</span><br><span class="line">    res[len] &#x3D; &#39;\0&#39;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;以3个8位字符为一组进行编码  </span><br><span class="line">    for (i &#x3D; 0, j &#x3D; 0; i &lt; len - 2; j +&#x3D; 3, i +&#x3D; 4)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i] &#x3D; base64_table[str[j] &gt;&gt; 2]; &#x2F;&#x2F;取出第一个字符的前6位并找出对应的结果字符  </span><br><span class="line">        res[i + 1] &#x3D; base64_table[(str[j] &amp; 0x3) &lt;&lt; 4 | (str[j + 1] &gt;&gt; 4)]; &#x2F;&#x2F;将第一个字符的后位与第二个字符的前4位进行组合并找到对应的结果字符  </span><br><span class="line">        res[i + 2] &#x3D; base64_table[(str[j + 1] &amp; 0xf) &lt;&lt; 2 | (str[j + 2] &gt;&gt; 6)]; &#x2F;&#x2F;将第二个字符的后4位与第三个字符的前2位组合并找出对应的结果字符  </span><br><span class="line">        res[i + 3] &#x3D; base64_table[str[j + 2] &amp; 0x3f]; &#x2F;&#x2F;取出第三个字符的后6位并找出结果字符  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (str_len % 3)</span><br><span class="line">    &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        res[i - 2] &#x3D; &#39;&#x3D;&#39;;</span><br><span class="line">        res[i - 1] &#x3D; &#39;&#x3D;&#39;;</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        res[i - 1] &#x3D; &#39;&#x3D;&#39;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char* base64_decode(unsigned char* code)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;根据base64表，以字符找到对应的十进制数据  </span><br><span class="line">    int table[] &#x3D; &#123; 0,0,0,0,0,0,0,0,0,0,0,0,</span><br><span class="line">             0,0,0,0,0,0,0,0,0,0,0,0,</span><br><span class="line">             0,0,0,0,0,0,0,0,0,0,0,0,</span><br><span class="line">             0,0,0,0,0,0,0,62,0,0,0,</span><br><span class="line">             63,52,53,54,55,56,57,58,</span><br><span class="line">             59,60,61,0,0,0,0,0,0,0,0,</span><br><span class="line">             1,2,3,4,5,6,7,8,9,10,11,12,</span><br><span class="line">             13,14,15,16,17,18,19,20,21,</span><br><span class="line">             22,23,24,25,0,0,0,0,0,0,26,</span><br><span class="line">             27,28,29,30,31,32,33,34,35,</span><br><span class="line">             36,37,38,39,40,41,42,43,44,</span><br><span class="line">             45,46,47,48,49,50,51</span><br><span class="line">    &#125;;</span><br><span class="line">    long len;</span><br><span class="line">    long str_len;</span><br><span class="line">    unsigned char* res;</span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算解码后的字符串长度  </span><br><span class="line">    len &#x3D; strlen((const char*)code);</span><br><span class="line">    &#x2F;&#x2F;判断编码后的字符串后是否有&#x3D;  </span><br><span class="line">    if (strstr(code, &quot;&#x3D;&#x3D;&quot;))</span><br><span class="line">        str_len &#x3D; len &#x2F; 4 * 3 - 2;</span><br><span class="line">    else if (strstr(code, &quot;&#x3D;&quot;))</span><br><span class="line">        str_len &#x3D; len &#x2F; 4 * 3 - 1;</span><br><span class="line">    else</span><br><span class="line">        str_len &#x3D; len &#x2F; 4 * 3;</span><br><span class="line"></span><br><span class="line">    res &#x3D; (unsigned char*)malloc(sizeof(unsigned char) * str_len + 1);</span><br><span class="line">    res[str_len] &#x3D; &#39;\0&#39;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;以4个字符为一位进行解码  </span><br><span class="line">    for (i &#x3D; 0, j &#x3D; 0; i &lt; len - 2; j +&#x3D; 3, i +&#x3D; 4)</span><br><span class="line">    &#123;</span><br><span class="line">        res[j] &#x3D; ((unsigned char)table[code[i]]) &lt;&lt; 2 | (((unsigned char)table[code[i + 1]]) &gt;&gt; 4); &#x2F;&#x2F;取出第一个字符对应base64表的十进制数的前6位与第二个字符对应base64表的十进制数的后2位进行组合  </span><br><span class="line">        res[j + 1] &#x3D; (((unsigned char)table[code[i + 1]]) &lt;&lt; 4) | (((unsigned char)table[code[i + 2]]) &gt;&gt; 2); &#x2F;&#x2F;取出第二个字符对应base64表的十进制数的后4位与第三个字符对应bas464表的十进制数的后4位进行组合  </span><br><span class="line">        res[j + 2] &#x3D; (((unsigned char)table[code[i + 2]]) &lt;&lt; 6) | ((unsigned char)table[code[i + 3]]); &#x2F;&#x2F;取出第三个字符对应base64表的十进制数的后2位与第4个字符进行组合  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>又称二分查找</p>
<p>基本思想：首先给定值key与表中中间的位置的元素比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分。然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int Binary_Search(SeqList L, ElemType key)&#123;</span><br><span class="line">	int low &#x3D; 0, high &#x3D; L.length - 1, mid;</span><br><span class="line">	while(low &lt;&#x3D; high)&#123;</span><br><span class="line">		mid &#x3D; (low + high)&#x2F;2;</span><br><span class="line">		if(L[mid] &#x3D;&#x3D; key) return mid;</span><br><span class="line">		else if(L[mid] &gt; key)&#123;</span><br><span class="line">			high &#x3D; mid - 1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			low &#x3D; mid + 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="windows程序创建过程"><a href="#windows程序创建过程" class="headerlink" title="windows程序创建过程"></a>windows程序创建过程</h2><p><a href="https://blog.csdn.net/hyman_c/article/details/53447695">https://blog.csdn.net/hyman_c/article/details/53447695</a></p>
<p>创建一个Windows界面程序共分为7步：</p>
<p>（1）定义WinMain函数（这是windows界面程序的入口）。</p>
<p>（2）定义窗口处理函数。</p>
<p>（3）注册窗口</p>
<p>（4）创建窗口</p>
<p>（5）显示窗口</p>
<p>（6）编写消息循环函数</p>
<p>（7）处理消息(在第二步的窗口处理函数中)</p>
<h2 id="Base64的编码与解码"><a href="#Base64的编码与解码" class="headerlink" title="Base64的编码与解码"></a>Base64的编码与解码</h2><p>原理：</p>
<p><a href="http://blog.chacuo.net/719.html">http://blog.chacuo.net/719.html</a></p>
<p>c语言实现：</p>
<p><a href="https://blog.csdn.net/qq_26093511/article/details/78836087">https://blog.csdn.net/qq_26093511/article/details/78836087</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BYTE unsigned char</span><br><span class="line">unsigned char* base64_encode(BYTE* str, long str_len)</span><br><span class="line">&#123;</span><br><span class="line">	long len;</span><br><span class="line">	unsigned char* res;</span><br><span class="line">	int i, j;</span><br><span class="line">	&#x2F;&#x2F;定义base64编码表  </span><br><span class="line">	const char* base64_table &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&quot;;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;计算经过base64编码后的字符串长度  </span><br><span class="line">	if (str_len % 3 &#x3D;&#x3D; 0)</span><br><span class="line">		len &#x3D; str_len &#x2F; 3 * 4;</span><br><span class="line">	else</span><br><span class="line">		len &#x3D; (str_len &#x2F; 3 + 1) * 4;</span><br><span class="line"></span><br><span class="line">	res &#x3D; (unsigned char*)malloc(sizeof(unsigned char) * len + 1);</span><br><span class="line">	res[len] &#x3D; &#39;\0&#39;;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;以3个8位字符为一组进行编码  </span><br><span class="line">	for (i &#x3D; 0, j &#x3D; 0; i &lt; len - 2; j +&#x3D; 3, i +&#x3D; 4)</span><br><span class="line">	&#123;</span><br><span class="line">		res[i] &#x3D; base64_table[str[j] &gt;&gt; 2]; &#x2F;&#x2F;取出第一个字符的前6位并找出对应的结果字符  </span><br><span class="line">		res[i + 1] &#x3D; base64_table[(str[j] &amp; 0x3) &lt;&lt; 4 | (str[j + 1] &gt;&gt; 4)]; &#x2F;&#x2F;将第一个字符的后两位与第二个字符的前4位进行组合并找到对应的结果字符  </span><br><span class="line">		res[i + 2] &#x3D; base64_table[(str[j + 1] &amp; 0xf) &lt;&lt; 2 | (str[j + 2] &gt;&gt; 6)]; &#x2F;&#x2F;将第二个字符的后4位与第三个字符的前2位组合并找出对应的结果字符  </span><br><span class="line">		res[i + 3] &#x3D; base64_table[str[j + 2] &amp; 0x3f]; &#x2F;&#x2F;取出第三个字符的后6位并找出结果字符  </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	switch (str_len % 3)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;还剩一个字节补两个等号，否则补一个</span><br><span class="line">	case 1:</span><br><span class="line">		res[i - 2] &#x3D; &#39;&#x3D;&#39;;</span><br><span class="line">		res[i - 1] &#x3D; &#39;&#x3D;&#39;;</span><br><span class="line">		break;</span><br><span class="line">	case 2:</span><br><span class="line">		res[i - 1] &#x3D; &#39;&#x3D;&#39;;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。<br>right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。<br>inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。<br>full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。</p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_39220472/article/details/81193617">https://blog.csdn.net/weixin_39220472/article/details/81193617</a></p>
<h1 id="vscode的cpp配置"><a href="#vscode的cpp配置" class="headerlink" title="vscode的cpp配置"></a>vscode的cpp配置</h1><p><a href="https://zhuanlan.zhihu.com/p/87864677">https://zhuanlan.zhihu.com/p/87864677</a></p>
<!--more-->

<p>task.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; See https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkId&#x3D;733558 </span><br><span class="line">    &#x2F;&#x2F; for the documentation about the tasks.json format</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;label&quot;: &quot;g++.exe build active file&quot;,&#x2F;&#x2F;任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置</span><br><span class="line">            &quot;command&quot;: &quot;D:\\Program Files (x86)\\mingw64\\bin\\g++.exe&quot;,</span><br><span class="line">            &quot;args&quot;: [&#x2F;&#x2F;编译时候的参数</span><br><span class="line">                &quot;-g&quot;,&#x2F;&#x2F;添加gdb调试选项</span><br><span class="line">                &quot;$&#123;file&#125;&quot;,</span><br><span class="line">                &quot;-o&quot;,&#x2F;&#x2F;指定生成可执行文件的名称</span><br><span class="line">                &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;options&quot;: &#123;</span><br><span class="line">                &quot;cwd&quot;: &quot;D:\\Program Files (x86)\\mingw64\\bin&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: [</span><br><span class="line">                &quot;$gcc&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true&#x2F;&#x2F;表示快捷键Ctrl+Shift+B可以运行该任务</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>launch.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Use IntelliSense to learn about possible attributes.</span><br><span class="line">    &#x2F;&#x2F; Hover to view descriptions of existing attributes.</span><br><span class="line">    &#x2F;&#x2F; For more information, visit: https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;(gdb) Launch&quot;,</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;g++.exe build active file&quot;,&#x2F;&#x2F;调试前执行的任务，就是之前配置的tasks.json中的label字段</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,&#x2F;&#x2F;配置类型，只能为cppdbg</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,&#x2F;&#x2F;请求配置类型，可以为launch（启动）或attach（附加）</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,&#x2F;&#x2F;调试程序的路径名称</span><br><span class="line">            &quot;args&quot;: [],&#x2F;&#x2F;调试传递参数</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: true,&#x2F;&#x2F;true显示外置的控制台窗口，false显示内置终端</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;D:\\Program Files (x86)\\mingw64\\bin\\gdb.exe&quot;,</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="LPWSTR-to-char-转换"><a href="#LPWSTR-to-char-转换" class="headerlink" title="LPWSTR to char* 转换"></a>LPWSTR to char* 转换</h1><p><a href="https://blog.csdn.net/moonlightpeng/article/details/80821872?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight">https://blog.csdn.net/moonlightpeng/article/details/80821872?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int num &#x3D; WideCharToMultiByte(CP_OEMCP, NULL, (LPWSTR)szKeyName, -1, NULL, 0, NULL, FALSE);</span><br><span class="line">			char* pchar &#x3D; new char[num];</span><br><span class="line">			WideCharToMultiByte(CP_OEMCP, NULL, (LPWSTR)szKeyName, -1, pchar, num, NULL, FALSE);</span><br><span class="line">			printf(&quot;%s\n&quot;, pchar);</span><br></pre></td></tr></table></figure>

<h1 id="string-to-LPCWSTR"><a href="#string-to-LPCWSTR" class="headerlink" title="string to LPCWSTR"></a>string to LPCWSTR</h1><p><a href="https://blog.csdn.net/wangshubo1989/article/details/50274103">https://blog.csdn.net/wangshubo1989/article/details/50274103</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_t size &#x3D; vProvList[i].length();</span><br><span class="line">        wchar_t* buffer &#x3D; new wchar_t[size + 1];</span><br><span class="line">        MultiByteToWideChar(CP_ACP, 0, vProvList[i].c_str(), size, buffer, size * sizeof(wchar_t));</span><br><span class="line">        buffer[size] &#x3D; 0;  &#x2F;&#x2F;确保以 &#39;\0&#39; 结尾</span><br></pre></td></tr></table></figure>

<h1 id="char转wchar-t"><a href="#char转wchar-t" class="headerlink" title="char转wchar_t"></a>char<em>转wchar_t</em></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char *s &#x3D; &quot;一二三四五六七八&quot;;</span><br><span class="line">   DWORD dwNum &#x3D; MultiByteToWideChar(CP_ACP, 0, s, -1, NULL, 0); &#x2F;&#x2F; 转换成 宽字节大小9 (8+1)</span><br><span class="line">   WCHAR *wch &#x3D; new WCHAR[dwNum]; &#x2F;&#x2F; 按宽字节 new 内存</span><br><span class="line">   memset(wch, 0, dwNum*sizeof(wchar_t)); &#x2F;&#x2F; 全置0  可以用这句 memset(wch, 0, sizeof(wch));</span><br><span class="line">   &#x2F;&#x2F; memset( the_array, &#39;\0&#39;, sizeof(the_array) ); 这是将一个数组的所以分量设置成零的很便捷的方法</span><br><span class="line"></span><br><span class="line">   MultiByteToWideChar(CP_ACP, 0, s, -1, wch, dwNum*sizeof(wchar_t)); &#x2F;&#x2F;s转换到宽字节wch</span><br><span class="line"></span><br><span class="line">   wcout &lt;&lt; wch &lt;&lt; endl; &#x2F;&#x2F; 宽字节输出</span><br></pre></td></tr></table></figure>

</div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/09/28/Base64%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Base64编码与解码</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/09/25/ascii%E7%A0%81%E8%A1%A8/"><span class="level-item">ascii码表</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: '6fcfd8db3e282426b4012e7214144ba2',
            repo: 'Jmlong23.github.io',
            owner: 'Jmlong23',
            clientID: 'bc8a046fee35afa66dfd',
            clientSecret: '657361040368baf39fd80cbe1d911c92eb0bf8c1',
            admin: ["Jmlong23"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/avatar.png" alt="topLOW"></figure><p class="title is-size-4 is-block line-height-inherit">topLOW</p><p class="is-size-6 is-block">topLOW的博客</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>广东广州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">44</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#cpp开发工程师学习资料"><span class="mr-2">1</span><span>cpp开发工程师学习资料</span></a></li><li><a class="is-flex" href="#其他"><span class="mr-2">2</span><span>其他</span></a></li><li><a class="is-flex" href="#cpp基础"><span class="mr-2">3</span><span>cpp基础</span></a><ul class="menu-list"><li><a class="is-flex" href="#重载（overload）覆盖（override）和重写（overwrite）区别"><span class="mr-2">3.1</span><span>重载（overload）覆盖（override）和重写（overwrite）区别</span></a></li><li><a class="is-flex" href="#C-中是如何申请内存的"><span class="mr-2">3.2</span><span>C++中是如何申请内存的</span></a></li><li><a class="is-flex" href="#new与malloc"><span class="mr-2">3.3</span><span>new与malloc</span></a></li><li><a class="is-flex" href="#多态"><span class="mr-2">3.4</span><span>多态</span></a></li><li><a class="is-flex" href="#虚函数表机制"><span class="mr-2">3.5</span><span>虚函数表机制</span></a><ul class="menu-list"><li><a class="is-flex" href="#虚函数与数据封装private"><span class="mr-2">3.5.1</span><span>虚函数与数据封装private</span></a></li></ul></li><li><a class="is-flex" href="#多继承与虚继承"><span class="mr-2">3.6</span><span>多继承与虚继承</span></a><ul class="menu-list"><li><a class="is-flex" href="#多重继承（Multiple-Inheritance）"><span class="mr-2">3.6.1</span><span>多重继承（Multiple Inheritance）</span></a></li><li><a class="is-flex" href="#虚继承（Virtual-Inheritance）"><span class="mr-2">3.6.2</span><span>虚继承（Virtual Inheritance）</span></a></li></ul></li><li><a class="is-flex" href="#类型转换（Type-Conversions）"><span class="mr-2">3.7</span><span>类型转换（Type Conversions）</span></a></li><li><a class="is-flex" href="#数组与链表的区别"><span class="mr-2">3.8</span><span>数组与链表的区别</span></a></li><li><a class="is-flex" href="#智能指针"><span class="mr-2">3.9</span><span>智能指针</span></a></li><li><a class="is-flex" href="#指针和引用的区别"><span class="mr-2">3.10</span><span>指针和引用的区别</span></a></li><li><a class="is-flex" href="#cpp的左值和右值"><span class="mr-2">3.11</span><span>cpp的左值和右值</span></a></li><li><a class="is-flex" href="#cpp程序编译过程"><span class="mr-2">3.12</span><span>cpp程序编译过程</span></a></li><li><a class="is-flex" href="#变量作用域"><span class="mr-2">3.13</span><span>变量作用域</span></a></li><li><a class="is-flex" href="#RTTI（run-time-type-identification-运行时类型识别"><span class="mr-2">3.14</span><span>RTTI（run-time type identification) 运行时类型识别</span></a></li><li><a class="is-flex" href="#请你回答一下C-中拷贝赋值函数的形参能否进行值传递？"><span class="mr-2">3.15</span><span>请你回答一下C++中拷贝赋值函数的形参能否进行值传递？</span></a></li><li><a class="is-flex" href="#fork（）函数"><span class="mr-2">3.16</span><span>fork（）函数</span></a></li><li><a class="is-flex" href="#类中的引用成员变量"><span class="mr-2">3.17</span><span>类中的引用成员变量</span></a></li><li><a class="is-flex" href="#异常处理"><span class="mr-2">3.18</span><span>异常处理</span></a><ul class="menu-list"><li><a class="is-flex" href="#noexcept异常说明"><span class="mr-2">3.18.1</span><span>noexcept异常说明</span></a></li></ul></li><li><a class="is-flex" href="#野指针"><span class="mr-2">3.19</span><span>野指针</span></a></li></ul></li><li><a class="is-flex" href="#STL"><span class="mr-2">4</span><span>STL</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex" href="#六大组件"><span class="mr-2">4.1.1</span><span>六大组件</span></a></li><li><a class="is-flex" href="#常用容器"><span class="mr-2">4.1.2</span><span>常用容器</span></a></li><li><a class="is-flex" href="#序列式容器"><span class="mr-2">4.1.3</span><span>序列式容器</span></a></li><li><a class="is-flex" href="#关联式容器"><span class="mr-2">4.1.4</span><span>关联式容器</span></a></li></ul><li><a class="is-flex" href="#迭代器-iterator"><span class="mr-2">4.2</span><span>迭代器 iterator</span></a></li><li><a class="is-flex" href="#常见容器的操作时间复杂度"><span class="mr-2">4.3</span><span>常见容器的操作时间复杂度</span></a></li><li><a class="is-flex" href="#stl常见容器api总结"><span class="mr-2">4.4</span><span>stl常见容器api总结</span></a></li><li><a class="is-flex" href="#stl常用算法总结"><span class="mr-2">4.5</span><span>stl常用算法总结</span></a></li></ul></li><li><a class="is-flex" href="#数据结构与算法"><span class="mr-2">5</span><span>数据结构与算法</span></a><ul class="menu-list"><li><a class="is-flex" href="#求二叉树的最大高度"><span class="mr-2">5.1</span><span>求二叉树的最大高度</span></a></li><li><a class="is-flex" href="#堆排序"><span class="mr-2">5.2</span><span>堆排序</span></a></li><li><a class="is-flex" href="#快速排序"><span class="mr-2">5.3</span><span>快速排序</span></a></li><li><a class="is-flex" href="#折半查找"><span class="mr-2">5.4</span><span>折半查找</span></a></li></ul></li><li><a class="is-flex" href="#项目"><span class="mr-2">6</span><span>项目</span></a><ul class="menu-list"><li><a class="is-flex" href="#windows程序创建过程"><span class="mr-2">6.1</span><span>windows程序创建过程</span></a></li><li><a class="is-flex" href="#Base64的编码与解码"><span class="mr-2">6.2</span><span>Base64的编码与解码</span></a></li></ul></li><li><a class="is-flex" href="#数据库"><span class="mr-2">7</span><span>数据库</span></a><ul class="menu-list"><li><a class="is-flex" href="#连接查询"><span class="mr-2">7.1</span><span>连接查询</span></a></li></ul></li><li><a class="is-flex" href="#vscode的cpp配置"><span class="mr-2">8</span><span>vscode的cpp配置</span></a></li><li><a class="is-flex" href="#LPWSTR-to-char-转换"><span class="mr-2">9</span><span>LPWSTR to char* 转换</span></a></li><li><a class="is-flex" href="#string-to-LPCWSTR"><span class="mr-2">10</span><span>string to LPCWSTR</span></a></li><li><a class="is-flex" href="#char转wchar-t"><span class="mr-2">11</span><span>char转wchar_t</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/c-%E5%AE%89%E5%85%A8%E5%AD%A6/"><span class="level-start"><span class="level-item">c++安全学</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/cpp/"><span class="level-start"><span class="level-item">cpp</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/cpp/c-primer/"><span class="level-start"><span class="level-item">c++ primer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/windows%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/"><span class="level-start"><span class="level-item">windows窗口程序</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">深度学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">环境搭建</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ftp%E9%85%8D%E7%BD%AE/"><span class="level-start"><span class="level-item">ftp配置</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">博客搭建</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BB%84%E7%BD%91%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">组网技术</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">编译原理</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ArrayList/"><span class="tag">ArrayList</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ftp/"><span class="tag">ftp</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hcl/"><span class="tag">hcl</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"><span class="tag">环境搭建</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B8%A9%E5%9D%91/"><span class="tag">踩坑</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2021-03-17T07:18:26.000Z">2021-03-17</time></p><p class="title is-6"><a class="link-muted" href="/2021/03/17/linux%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88/">linux操作集合</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/linux/">linux</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-03-10T12:18:53.000Z">2021-03-10</time></p><p class="title is-6"><a class="link-muted" href="/2021/03/10/%E5%89%91%E6%8C%87offer/">剑指offer</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/leetcode/">leetcode</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-02-27T09:14:36.000Z">2021-02-27</time></p><p class="title is-6"><a class="link-muted" href="/2021/02/27/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/">第七章 类</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/cpp/">cpp</a> / <a class="link-muted" href="/categories/cpp/c-primer/">c++ primer</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-02-25T13:54:06.000Z">2021-02-25</time></p><p class="title is-6"><a class="link-muted" href="/2021/02/25/%E8%85%BE%E8%AE%AF%E4%BA%91centos%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEvnc%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2/">腾讯云centos服务器配置vnc可视化界面</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-02-20T04:27:55.000Z">2021-02-20</time></p><p class="title is-6"><a class="link-muted" href="/2021/02/20/vscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/">vscode远程连接</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="topLOW的博客" height="28"></a><p class="size-small"><span>&copy; 2021 long</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://sanguocloud.cn',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>